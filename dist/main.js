module.exports=function(e){var t={};function r(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:o})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=12)}([function(e,t,r){"use strict";function o(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}Object.defineProperty(t,"__esModule",{value:!0}),o(r(11)),o(r(1)),o(r(58)),o(r(59)),o(r(60)),o(r(61)),o(r(62))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.TaskComponent=class{constructor(e){this.register=(()=>{}),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(43),i=r(44),s=r(45),a=r(46),n={getGame:{objById:e=>Game.getObjectById(e),objsByIdArray(e){const t=[];return _.forEach(e,e=>t.push(Game.getObjectById(e))),_.compact(t)},objsToIdArray:e=>_.map(e,"id"),flagByName:e=>Game.flags[e],flagsByNameArray(e){const t=[];return _.forEach(e,e=>t.push(Game.flags[e])),_.compact(t)},flagsToNameArray:e=>_.map(e,"name")},formatNumber(e){let t=Math.log10(e)/3;if(!e)return"0";let r=e.toString();return t<1?r:t<2?r.substring(0,r.length-3)+"k":t<3?r.substring(0,r.length-6)+"M":t<4?r.substring(0,r.length-9)+"B":e.toString()},pad:(e,t="0",r=2,o=!0)=>(o&&(r-=e.toString().length),_.times(r,()=>t).join("")+e),get(e,t,r,o=!0){const i=_.get(e,t);return _.isUndefined(i)&&!_.isUndefined(r)&&o?(r=Util.fieldOrFunction(r),_.set(e,t,r),_.get(e,t)):i},areEqual:(...e)=>e.length<=1||e.every((e,t,r)=>_.isEqual(e,r[0])),set(e,t,r,o=!0){o?Util.get(e,t,r):_.set(e,t,r)},callIfExists(e,...t){if(e)return e(...t)},fieldOrFunction:(e,...t)=>_.isFunction(e)?e(...t):e,addById(e,t){e||(e=[]);const r=Game.getObjectById(t);return r&&e.push(r),e},processReports(){if(!_.isUndefined(Memory.statistics)&&!_.isUndefined(Memory.statistics.reports)&&Memory.statistics.reports.length){let e;Memory.statistics.reports.length<=REPORTS_PER_LOOP?(e=Memory.statistics.reports,Memory.statistics.reports=[]):e=Memory.statistics.reports.splice(0,REPORTS_PER_LOOP),_.forEach(e,Game.notify)}},guid:()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}),inQueue:e=>!!e&&(e.link&&(e={behaviour:e}),!!(e.name||e.behaviour||e.setup)&&_(Game.rooms).filter("my").map("memory").map(e=>e.spawnQueueHigh.concat(e.spawnQueueMedium,e.spawnQueueLow)).flatten().some(t=>(!e.room||!t.destiny||t.destiny.room===e.room)&&(e.behaviour?t.behaviour&&t.behaviour===e.behaviour||t.name.includes(e.behaviour):e.setup?t.setup===e.setup:void 0))),memoryUsage(e){let t="",r=0,o="";for(const i in e){i.length>o.length&&(o=i);const s=JSON.stringify(e[i]).length/1024;r+=s,t+=`<tr><td>${i}</td><td>${_.round(s,2)}</td></tr>`}return t+=`<tr><td>Total</td><td>${_.round(r,2)}</td></tr></table>`,`<table><tr><th>Key${Array(o.length+2).join(" ")}</th><th>Size (kb)</th></tr>`.concat(t)},_resources:_.memoize(()=>_.chain(global).pick((e,t)=>t.startsWith("RESOURCE_")).value()),resources(){return this._resources()},valueOrZero:e=>e||0,chargeScale(e,t,r){if(r===t)return e>r?1/0:-1/0;return(e-r)*(1/(r-t))+1},resetBoostProduction(e){let t,r=_.filter(Game.rooms,{my:!0});for(let o of r)void 0!==e&&o.name!==e||(t=o.memory.resources,Log.success(o.name,"reset!"),_.isUndefined(t)?Log.warn(o.name,"has no memory.resources"):(t.offers=[],t.orders=[],t.terminal[0]&&(t.terminal[0].orders=[]),t.storage[0]&&(t.storage[0].orders=[]),t.reactions&&(t.reactions.orders=[]),t.lab&&(t.lab=[],_.values(Game.structures).filter(e=>"lab"===e.structureType).map(e=>e.room.setStore(e.id,RESOURCE_ENERGY,2e3))),t.boostTiming={roomState:""}));void 0===e&&delete Memory.boostTiming}};t.default=_.assign(n,s.roomUtils,i.logUtils,o.dateUtils,a.marketUtils),t.Install=function(e,t,r=!1){_.isString(e)?(global[e]=t,r&&_.assign(global[e],r)):(_.assign(e,t),r&&_.assign(e,r))};var l=r(10);t.Emoji=l.Emoji,t.getUsername=_(Game.rooms).map("controller").filter("my").map("owner.username").first()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.VisualsBase=class{constructor(){this.resourcesColor={[RESOURCE_ENERGY]:"#FFE56D",[RESOURCE_POWER]:"#FF0000",[RESOURCE_CATALYST]:"#FF7A7A",[RESOURCE_GHODIUM]:"#FFFFFF",[RESOURCE_HYDROGEN]:"#CCCCCC",[RESOURCE_KEANIUM]:"#9370FF",[RESOURCE_LEMERGIUM]:"#89F4A5",[RESOURCE_OXYGEN]:"#CCCCCC",[RESOURCE_UTRIUM]:"#88D6F7",[RESOURCE_ZYNTHIUM]:"#F2D28B"},this.getResourceColour=(e=>{const t=this.resourcesColor[e];if(t)return t;let r=[RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_GHODIUM,RESOURCE_HYDROGEN,RESOURCE_OXYGEN].find(t=>e.includes(t));return _.include([RESOURCE_UTRIUM_LEMERGITE,RESOURCE_ZYNTHIUM_KEANITE],e)&&(r=RESOURCE_OXYGEN),this.resourcesColor[r]}),this.randomColour=(()=>{let e="#";for(;e.length<7;)e+=Math.random().toString(16).substr(-7).substr(-1);return e}),this.creepPathStyle=(e=>(Util.set(e.data,"pathColour",this.randomColour),{width:.15,color:e.data.pathColour,lineStyle:"dashed"}))}}},function(e,t,r){"use strict";t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')};var o=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,i=/^data:.+\,.+$/;function s(e){var t=e.match(o);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function a(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function n(e){var r=e,o=s(e);if(o){if(!o.path)return e;r=o.path}for(var i,n=t.isAbsolute(r),l=r.split(/\/+/),m=0,c=l.length-1;c>=0;c--)"."===(i=l[c])?l.splice(c,1):".."===i?m++:m>0&&(""===i?(l.splice(c+1,m),m=0):(l.splice(c,2),m--));return""===(r=l.join("/"))&&(r=n?"/":"."),o?(o.path=r,a(o)):r}function l(e,t){""===e&&(e="."),""===t&&(t=".");var r=s(t),o=s(e);if(o&&(e=o.path||"/"),r&&!r.scheme)return o&&(r.scheme=o.scheme),a(r);if(r||t.match(i))return t;if(o&&!o.host&&!o.path)return o.host=t,a(o);var l="/"===t.charAt(0)?t:n(e.replace(/\/+$/,"")+"/"+t);return o?(o.path=l,a(o)):l}t.urlParse=s,t.urlGenerate=a,t.normalize=n,t.join=l,t.isAbsolute=function(e){return"/"===e.charAt(0)||o.test(e)},t.relative=function(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var o=e.lastIndexOf("/");if(o<0)return t;if((e=e.slice(0,o)).match(/^([^\/]+:\/)?\/*$/))return t;++r}return Array(r+1).join("../")+t.substr(e.length+1)};var m=!("__proto__"in Object.create(null));function c(e){return e}function u(e){if(!e)return!1;var t=e.length;if(t<9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return!1;return!0}function d(e,t){return e===t?0:null===e?1:null===t?-1:e>t?1:-1}t.toSetString=m?c:function(e){return u(e)?"$"+e:e},t.fromSetString=m?c:function(e){return u(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var o=d(e.source,t.source);return 0!==o?o:0!=(o=e.originalLine-t.originalLine)?o:0!=(o=e.originalColumn-t.originalColumn)||r?o:0!=(o=e.generatedColumn-t.generatedColumn)?o:0!=(o=e.generatedLine-t.generatedLine)?o:d(e.name,t.name)},t.compareByGeneratedPositionsDeflated=function(e,t,r){var o=e.generatedLine-t.generatedLine;return 0!==o?o:0!=(o=e.generatedColumn-t.generatedColumn)||r?o:0!==(o=d(e.source,t.source))?o:0!=(o=e.originalLine-t.originalLine)?o:0!=(o=e.originalColumn-t.originalColumn)?o:d(e.name,t.name)},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r?r:0!=(r=e.generatedColumn-t.generatedColumn)?r:0!==(r=d(e.source,t.source))?r:0!=(r=e.originalLine-t.originalLine)?r:0!=(r=e.originalColumn-t.originalColumn)?r:d(e.name,t.name)},t.parseSourceMapInput=function(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))},t.computeSourceURL=function(e,t,r){if(t=t||"",e&&("/"!==e[e.length-1]&&"/"!==t[0]&&(e+="/"),t=e+t),r){var o=s(r);if(!o)throw new Error("sourceMapURL could not be parsed");if(o.path){var i=o.path.lastIndexOf("/");i>=0&&(o.path=o.path.substring(0,i+1))}t=l(a(o),t)}return n(t)}},function(e,t,r){"use strict";var o=r(6),i=r(4),s=r(7).ArraySet,a=r(16).MappingList;function n(e){e||(e={}),this._file=i.getArg(e,"file",null),this._sourceRoot=i.getArg(e,"sourceRoot",null),this._skipValidation=i.getArg(e,"skipValidation",!1),this._sources=new s,this._names=new s,this._mappings=new a,this._sourcesContents=null}n.prototype._version=3,n.fromSourceMap=function(e){var t=e.sourceRoot,r=new n({file:e.file,sourceRoot:t});return e.eachMapping(function(e){var o={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(o.source=e.source,null!=t&&(o.source=i.relative(t,o.source)),o.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(o.name=e.name)),r.addMapping(o)}),e.sources.forEach(function(o){var s=o;null!==t&&(s=i.relative(t,o)),r._sources.has(s)||r._sources.add(s);var a=e.sourceContentFor(o);null!=a&&r.setSourceContent(o,a)}),r},n.prototype.addMapping=function(e){var t=i.getArg(e,"generated"),r=i.getArg(e,"original",null),o=i.getArg(e,"source",null),s=i.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,o,s),null!=o&&(o=String(o),this._sources.has(o)||this._sources.add(o)),null!=s&&(s=String(s),this._names.has(s)||this._names.add(s)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:o,name:s})},n.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=i.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[i.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[i.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))},n.prototype.applySourceMap=function(e,t,r){var o=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');o=e.file}var a=this._sourceRoot;null!=a&&(o=i.relative(a,o));var n=new s,l=new s;this._mappings.unsortedForEach(function(t){if(t.source===o&&null!=t.originalLine){var s=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=s.source&&(t.source=s.source,null!=r&&(t.source=i.join(r,t.source)),null!=a&&(t.source=i.relative(a,t.source)),t.originalLine=s.line,t.originalColumn=s.column,null!=s.name&&(t.name=s.name))}var m=t.source;null==m||n.has(m)||n.add(m);var c=t.name;null==c||l.has(c)||l.add(c)},this),this._sources=n,this._names=l,e.sources.forEach(function(t){var o=e.sourceContentFor(t);null!=o&&(null!=r&&(t=i.join(r,t)),null!=a&&(t=i.relative(a,t)),this.setSourceContent(t,o))},this)},n.prototype._validateMapping=function(e,t,r,o){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||o)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:o}))},n.prototype._serializeMappings=function(){for(var e,t,r,s,a=0,n=1,l=0,m=0,c=0,u=0,d="",h=this._mappings.toArray(),g=0,p=h.length;g<p;g++){if(e="",(t=h[g]).generatedLine!==n)for(a=0;t.generatedLine!==n;)e+=";",n++;else if(g>0){if(!i.compareByGeneratedPositionsInflated(t,h[g-1]))continue;e+=","}e+=o.encode(t.generatedColumn-a),a=t.generatedColumn,null!=t.source&&(s=this._sources.indexOf(t.source),e+=o.encode(s-u),u=s,e+=o.encode(t.originalLine-1-m),m=t.originalLine-1,e+=o.encode(t.originalColumn-l),l=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=o.encode(r-c),c=r)),d+=e}return d},n.prototype._generateSourcesContent=function(e,t){return e.map(function(e){if(!this._sourcesContents)return null;null!=t&&(e=i.relative(t,e));var r=i.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null},this)},n.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},n.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=n},function(e,t,r){"use strict";var o=r(15);t.encode=function(e){var t,r="",i=function(e){return e<0?1+(-e<<1):0+(e<<1)}(e);do{t=31&i,(i>>>=5)>0&&(t|=32),r+=o.encode(t)}while(i>0);return r},t.decode=function(e,t,r){var i,s,a,n,l=e.length,m=0,c=0;do{if(t>=l)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(s=o.decode(e.charCodeAt(t++))))throw new Error("Invalid base64 digit: "+e.charAt(t-1));i=!!(32&s),m+=(s&=31)<<c,c+=5}while(i);r.value=(n=(a=m)>>1,1==(1&a)?-n:n),r.rest=t}},function(e,t,r){"use strict";var o=r(4),i=Object.prototype.hasOwnProperty,s="undefined"!=typeof Map;function a(){this._array=[],this._set=s?new Map:Object.create(null)}a.fromArray=function(e,t){for(var r=new a,o=0,i=e.length;o<i;o++)r.add(e[o],t);return r},a.prototype.size=function(){return s?this._set.size:Object.getOwnPropertyNames(this._set).length},a.prototype.add=function(e,t){var r=s?e:o.toSetString(e),a=s?this.has(e):i.call(this._set,r),n=this._array.length;a&&!t||this._array.push(e),a||(s?this._set.set(e,n):this._set[r]=n)},a.prototype.has=function(e){if(s)return this._set.has(e);var t=o.toSetString(e);return i.call(this._set,t)},a.prototype.indexOf=function(e){if(s){var t=this._set.get(e);if(t>=0)return t}else{var r=o.toSetString(e);if(i.call(this._set,r))return this._set[r]}throw new Error('"'+e+'" is not in the set.')},a.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},a.prototype.toArray=function(){return this._array.slice()},t.ArraySet=a},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Strategy={decorateAgent(e,...r){e.customStrategy||(e.customStrategy=function(e){}),e.staticCustomStrategy||(e.staticCustomStrategy=function(e){}),e.getStrategyHandler=function(e,t,...r){const o=this.currentStrategy||this.strategy(e),i=o[t],s=o.key,a=o.name;if(LOG_TRACE&&Log.trace("Strategy",{agent:this.name,strategyKey:s,strategyName:a,method:t}),void 0===i)return void Log.error("strategy handler returned undefined",{agent:this.name||this.id,strategyKey:s,strategyName:a,method:t,stack:(new Error).stack});if(0===r.length)return i;const n=i.apply(this.currentStrategy,r);if(void 0!==n)return n;Log.error("handler returned undefined for args",{agent:this.name||this.id,strategyKey:s,strategyName:a,method:t,args:r.toString(),stack:(new Error).stack})},e._strategyCache={},e.strategyKey=function(e){const t=[];for(let o=r.length-1;o>=0;o--)e[o]?t[o]=e[o]:t[o]=r[o].default(this);return t},e.selectClient=function(e,t){return e[t]&&r[t].select(e[t])},e.strategy=function(e){const o=this.strategyKey(e);let i=t.Strategy.getCachedStrategy(this,o);return i?t.Strategy.customizeStrategy(this,o,i):(i=t.Strategy.buildStrategy(o,t.Strategy.strategyChainUtils,r,this.staticCustomStrategy.apply(this,o)))?(t.Strategy.putCachedStrategy(this,o,i),t.Strategy.customizeStrategy(this,o,i)):(Log.error("no strategy",{agent:this.name||this.id,key:o}),{})},e.explain=function(){const e=this.strategyKey([]);let t=this.toString()+": ";this.explainAgent&&(t+=this.explainAgent()+" "),t+=`assigned:[${e}]`;for(let r=0;r<e.length;r++){const o=this.selectClient(r);o&&o.explain&&(t+=`\n\t${e[r]}: ${o.explain(this)}`)}return t}},allocateStrategy(e,...t){e.currentStrategy=e.strategy.apply(e,t)},freeStrategy(e){t.Strategy.freeStrategyChain(e.currentStrategy),delete e.currentStrategy},buildStrategy(e,r,o,i){const s={key:e,name:[]};let a;t.Strategy.appendstate(s,void 0,[r]);for(let r=0;r<o.length;r++){const i=e[r],n=i&&o[r].selector(i),l=n&&n.selectstate&&n.selectstate.apply(n,e);a=t.Strategy.appendstate(s,a,l)}if(i&&(a=t.Strategy.appendstate(s,a,[i])),a)return s},appendstate(e,t,r){if(!r)return t;for(let o=0;o<r.length;o++){const i=r[o];i&&(t=i,_.assign(e,i,(e,t,r)=>"name"===r?(e.push(t),e):t))}return t},freeStrategyChain(e){},customizeStrategy(e,t,r){const o=e.customStrategy.apply(e,t);return o?_.assign({},r,o,(e,t,r)=>"name"===r?Array.isArray(t)?t.slice(0):(e.push(t),e):t):r},strategyChainUtils:{toString(){const e=this.name.toString();return t.Strategy.freeStrategy(this),e},[Symbol.toPrimitive](){return this.toString()}},getCachedStrategy:(e,t)=>_.get(e._strategyCache,t),putCachedStrategy(e,t,r){Object.freeze(r),_.set(e._strategyCache,t,r)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.OK=0]="OK",e[e.ERR_NOT_OWNER=-1]="ERR_NOT_OWNER",e[e.ERR_NO_PATH=-2]="ERR_NO_PATH",e[e.ERR_NAME_EXISTS=-3]="ERR_NAME_EXISTS",e[e.ERR_BUSY=-4]="ERR_BUSY",e[e.ERR_NOT_FOUND=-5]="ERR_NOT_FOUND",e[e.ERR_NOT_ENOUGH_ENERGY=-6]="ERR_NOT_ENOUGH_ENERGY",e[e.ERR_NOT_ENOUGH_RESOURCES=-6]="ERR_NOT_ENOUGH_RESOURCES",e[e.ERR_INVALID_TARGET=-7]="ERR_INVALID_TARGET",e[e.ERR_FULL=-8]="ERR_FULL",e[e.ERR_NOT_IN_RANGE=-9]="ERR_NOT_IN_RANGE",e[e.ERR_INVALID_ARGS=-10]="ERR_INVALID_ARGS",e[e.ERR_TIRED=-11]="ERR_TIRED",e[e.ERR_NO_BODYPART=-12]="ERR_NO_BODYPART",e[e.ERR_NOT_ENOUGH_EXTENSIONS=-6]="ERR_NOT_ENOUGH_EXTENSIONS",e[e.ERR_RCL_NOT_ENOUGH=-14]="ERR_RCL_NOT_ENOUGH",e[e.ERR_GCL_NOT_ENOUGH=-15]="ERR_GCL_NOT_ENOUGH"}(t.ErrorType||(t.ErrorType={}))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Emoji={skull:String.fromCodePoint(128128),tick:String.fromCodePoint(9989),cross:String.fromCodePoint(10060),warn:String.fromCodePoint(128549),info:String.fromCodePoint(8505),debug:String.fromCodePoint(128027),home:String.fromCodePoint(127968),reload:String.fromCodePoint(8987),flag:String.fromCodePoint(128681),baby:String.fromCodePoint(128118),walk:String.fromCodePoint(128095),wait:String.fromCodePoint(128684),harvest:String.fromCodePoint(9935),upgrade:String.fromCodePoint(128509),build:String.fromCodePoint(127959),repair:String.fromCodePoint(9874),fuel:String.fromCodePoint(9981)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.Component=class{constructor(){this.extend=(e=>{}),this.fresh=(e=>{}),this.analyze=(e=>{}),this.register=(e=>{}),this.run=(e=>{}),this.cleanup=(e=>{})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});r(13);const o=r(22),i=r(23);o.Splash();const s=()=>{Memory.pause||(_.isUndefined(global.isRoot)&&i.default.install(),i.default.loop(),Game.cacheTime=Game.time)};t.loop=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(14);class i{static get consumer(){return null==this._consumer&&(this._consumer=new o.SourceMapConsumer(r(21))),this._consumer}static sourceMappedStackTrace(e){const t=e instanceof Error?e.stack:e;if(this.cache.hasOwnProperty(t))return this.cache[t];const r=/^\s+at\s+(.+?\s+)?\(?([0-z._\-\\/]+):(\d+):(\d+)\)?$/gm;let o,i=e.toString();for(;(o=r.exec(t))&&"main"===o[2];){const e=this.consumer.originalPositionFor({column:parseInt(o[4],10),line:parseInt(o[3],10)});if(null==e.line)break;e.name?i+=`\n    at ${e.name} (${e.source}:${e.line}:${e.column})`:o[1]?i+=`\n    at ${o[1]} (${e.source}:${e.line}:${e.column})`:i+=`\n    at ${e.source}:${e.line}:${e.column}`}return this.cache[t]=i,i}static wrapLoop(e){return()=>{try{e()}catch(e){if(!(e instanceof Error))throw e;if("sim"in Game.rooms){const t="Source maps don't work in the simulator - displaying original error";console.log(`<span style='color:red'>${t}<br>${_.escape(e.stack)}</span>`)}else console.log(`<span style='color:red'>${_.escape(this.sourceMappedStackTrace(e))}</span>`)}}}}i.cache={},t.ErrorMapper=i},function(e,t,r){"use strict";t.SourceMapGenerator=r(5).SourceMapGenerator,t.SourceMapConsumer=r(17).SourceMapConsumer,t.SourceNode=r(20).SourceNode},function(e,t,r){"use strict";var o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.encode=function(e){if(0<=e&&e<o.length)return o[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){return 65<=e&&e<=90?e-65:97<=e&&e<=122?e-97+26:48<=e&&e<=57?e-48+52:43==e?62:47==e?63:-1}},function(e,t,r){"use strict";var o=r(4);function i(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}i.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},i.prototype.add=function(e){var t,r,i,s,a,n;t=this._last,r=e,i=t.generatedLine,s=r.generatedLine,a=t.generatedColumn,n=r.generatedColumn,s>i||s==i&&n>=a||o.compareByGeneratedPositionsInflated(t,r)<=0?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e))},i.prototype.toArray=function(){return this._sorted||(this._array.sort(o.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.MappingList=i},function(e,t,r){"use strict";var o=r(4),i=r(18),s=r(7).ArraySet,a=r(6),n=r(19).quickSort;function l(e,t){var r=e;return"string"==typeof e&&(r=o.parseSourceMapInput(e)),null!=r.sections?new u(r,t):new m(r,t)}function m(e,t){var r=e;"string"==typeof e&&(r=o.parseSourceMapInput(e));var i=o.getArg(r,"version"),a=o.getArg(r,"sources"),n=o.getArg(r,"names",[]),l=o.getArg(r,"sourceRoot",null),m=o.getArg(r,"sourcesContent",null),c=o.getArg(r,"mappings"),u=o.getArg(r,"file",null);if(i!=this._version)throw new Error("Unsupported version: "+i);l&&(l=o.normalize(l)),a=a.map(String).map(o.normalize).map(function(e){return l&&o.isAbsolute(l)&&o.isAbsolute(e)?o.relative(l,e):e}),this._names=s.fromArray(n.map(String),!0),this._sources=s.fromArray(a,!0),this._absoluteSources=this._sources.toArray().map(function(e){return o.computeSourceURL(l,e,t)}),this.sourceRoot=l,this.sourcesContent=m,this._mappings=c,this._sourceMapURL=t,this.file=u}function c(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}function u(e,t){var r=e;"string"==typeof e&&(r=o.parseSourceMapInput(e));var i=o.getArg(r,"version"),a=o.getArg(r,"sections");if(i!=this._version)throw new Error("Unsupported version: "+i);this._sources=new s,this._names=new s;var n={line:-1,column:0};this._sections=a.map(function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var r=o.getArg(e,"offset"),i=o.getArg(r,"line"),s=o.getArg(r,"column");if(i<n.line||i===n.line&&s<n.column)throw new Error("Section offsets must be ordered and non-overlapping.");return n=r,{generatedOffset:{generatedLine:i+1,generatedColumn:s+1},consumer:new l(o.getArg(e,"map"),t)}})}l.fromSourceMap=function(e,t){return m.fromSourceMap(e,t)},l.prototype._version=3,l.prototype.__generatedMappings=null,Object.defineProperty(l.prototype,"_generatedMappings",{configurable:!0,enumerable:!0,get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),l.prototype.__originalMappings=null,Object.defineProperty(l.prototype,"_originalMappings",{configurable:!0,enumerable:!0,get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),l.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return";"===r||","===r},l.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},l.GENERATED_ORDER=1,l.ORIGINAL_ORDER=2,l.GREATEST_LOWER_BOUND=1,l.LEAST_UPPER_BOUND=2,l.prototype.eachMapping=function(e,t,r){var i,s=t||null;switch(r||l.GENERATED_ORDER){case l.GENERATED_ORDER:i=this._generatedMappings;break;case l.ORIGINAL_ORDER:i=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var a=this.sourceRoot;i.map(function(e){var t=null===e.source?null:this._sources.at(e.source);return{source:t=o.computeSourceURL(a,t,this._sourceMapURL),generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}},this).forEach(e,s)},l.prototype.allGeneratedPositionsFor=function(e){var t=o.getArg(e,"line"),r={source:o.getArg(e,"source"),originalLine:t,originalColumn:o.getArg(e,"column",0)};if(r.source=this._findSourceIndex(r.source),r.source<0)return[];var s=[],a=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,i.LEAST_UPPER_BOUND);if(a>=0){var n=this._originalMappings[a];if(void 0===e.column)for(var l=n.originalLine;n&&n.originalLine===l;)s.push({line:o.getArg(n,"generatedLine",null),column:o.getArg(n,"generatedColumn",null),lastColumn:o.getArg(n,"lastGeneratedColumn",null)}),n=this._originalMappings[++a];else for(var m=n.originalColumn;n&&n.originalLine===t&&n.originalColumn==m;)s.push({line:o.getArg(n,"generatedLine",null),column:o.getArg(n,"generatedColumn",null),lastColumn:o.getArg(n,"lastGeneratedColumn",null)}),n=this._originalMappings[++a]}return s},t.SourceMapConsumer=l,m.prototype=Object.create(l.prototype),m.prototype.consumer=l,m.prototype._findSourceIndex=function(e){var t,r=e;if(null!=this.sourceRoot&&(r=o.relative(this.sourceRoot,r)),this._sources.has(r))return this._sources.indexOf(r);for(t=0;t<this._absoluteSources.length;++t)if(this._absoluteSources[t]==e)return t;return-1},m.fromSourceMap=function(e,t){var r=Object.create(m.prototype),i=r._names=s.fromArray(e._names.toArray(),!0),a=r._sources=s.fromArray(e._sources.toArray(),!0);r.sourceRoot=e._sourceRoot,r.sourcesContent=e._generateSourcesContent(r._sources.toArray(),r.sourceRoot),r.file=e._file,r._sourceMapURL=t,r._absoluteSources=r._sources.toArray().map(function(e){return o.computeSourceURL(r.sourceRoot,e,t)});for(var l=e._mappings.toArray().slice(),u=r.__generatedMappings=[],d=r.__originalMappings=[],h=0,g=l.length;h<g;h++){var p=l[h],f=new c;f.generatedLine=p.generatedLine,f.generatedColumn=p.generatedColumn,p.source&&(f.source=a.indexOf(p.source),f.originalLine=p.originalLine,f.originalColumn=p.originalColumn,p.name&&(f.name=i.indexOf(p.name)),d.push(f)),u.push(f)}return n(r.__originalMappings,o.compareByOriginalPositions),r},m.prototype._version=3,Object.defineProperty(m.prototype,"sources",{get:function(){return this._absoluteSources.slice()}}),m.prototype._parseMappings=function(e,t){for(var r,i,s,l,m,u=1,d=0,h=0,g=0,p=0,f=0,R=e.length,y=0,_={},C={},T=[],E=[];y<R;)if(";"===e.charAt(y))u++,y++,d=0;else if(","===e.charAt(y))y++;else{for((r=new c).generatedLine=u,l=y;l<R&&!this._charIsMappingSeparator(e,l);l++);if(s=_[i=e.slice(y,l)])y+=i.length;else{for(s=[];y<l;)a.decode(e,y,C),m=C.value,y=C.rest,s.push(m);if(2===s.length)throw new Error("Found a source, but no line and column");if(3===s.length)throw new Error("Found a source and line, but no column");_[i]=s}r.generatedColumn=d+s[0],d=r.generatedColumn,s.length>1&&(r.source=p+s[1],p+=s[1],r.originalLine=h+s[2],h=r.originalLine,r.originalLine+=1,r.originalColumn=g+s[3],g=r.originalColumn,s.length>4&&(r.name=f+s[4],f+=s[4])),E.push(r),"number"==typeof r.originalLine&&T.push(r)}n(E,o.compareByGeneratedPositionsDeflated),this.__generatedMappings=E,n(T,o.compareByOriginalPositions),this.__originalMappings=T},m.prototype._findMapping=function(e,t,r,o,s,a){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[o]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[o]);return i.search(e,t,s,a)},m.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},m.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",o.compareByGeneratedPositionsDeflated,o.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(r>=0){var i=this._generatedMappings[r];if(i.generatedLine===t.generatedLine){var s=o.getArg(i,"source",null);null!==s&&(s=this._sources.at(s),s=o.computeSourceURL(this.sourceRoot,s,this._sourceMapURL));var a=o.getArg(i,"name",null);return null!==a&&(a=this._names.at(a)),{source:s,line:o.getArg(i,"originalLine",null),column:o.getArg(i,"originalColumn",null),name:a}}}return{source:null,line:null,column:null,name:null}},m.prototype.hasContentsOfAllSources=function(){return!!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(e){return null==e}))},m.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;var r=this._findSourceIndex(e);if(r>=0)return this.sourcesContent[r];var i,s=e;if(null!=this.sourceRoot&&(s=o.relative(this.sourceRoot,s)),null!=this.sourceRoot&&(i=o.urlParse(this.sourceRoot))){var a=s.replace(/^file:\/\//,"");if("file"==i.scheme&&this._sources.has(a))return this.sourcesContent[this._sources.indexOf(a)];if((!i.path||"/"==i.path)&&this._sources.has("/"+s))return this.sourcesContent[this._sources.indexOf("/"+s)]}if(t)return null;throw new Error('"'+s+'" is not in the SourceMap.')},m.prototype.generatedPositionFor=function(e){var t=o.getArg(e,"source");if((t=this._findSourceIndex(t))<0)return{line:null,column:null,lastColumn:null};var r={source:t,originalLine:o.getArg(e,"line"),originalColumn:o.getArg(e,"column")},i=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,o.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(i>=0){var s=this._originalMappings[i];if(s.source===r.source)return{line:o.getArg(s,"generatedLine",null),column:o.getArg(s,"generatedColumn",null),lastColumn:o.getArg(s,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},t.BasicSourceMapConsumer=m,u.prototype=Object.create(l.prototype),u.prototype.constructor=l,u.prototype._version=3,Object.defineProperty(u.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),u.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=i.search(t,this._sections,function(e,t){var r=e.generatedLine-t.generatedOffset.generatedLine;return r||e.generatedColumn-t.generatedOffset.generatedColumn}),s=this._sections[r];return s?s.consumer.originalPositionFor({line:t.generatedLine-(s.generatedOffset.generatedLine-1),column:t.generatedColumn-(s.generatedOffset.generatedLine===t.generatedLine?s.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},u.prototype.hasContentsOfAllSources=function(){return this._sections.every(function(e){return e.consumer.hasContentsOfAllSources()})},u.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var o=this._sections[r].consumer.sourceContentFor(e,!0);if(o)return o}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},u.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer._findSourceIndex(o.getArg(e,"source"))){var i=r.consumer.generatedPositionFor(e);if(i)return{line:i.line+(r.generatedOffset.generatedLine-1),column:i.column+(r.generatedOffset.generatedLine===i.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}},u.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var i=this._sections[r],s=i.consumer._generatedMappings,a=0;a<s.length;a++){var l=s[a],m=i.consumer._sources.at(l.source);m=o.computeSourceURL(i.consumer.sourceRoot,m,this._sourceMapURL),this._sources.add(m),m=this._sources.indexOf(m);var c=null;l.name&&(c=i.consumer._names.at(l.name),this._names.add(c),c=this._names.indexOf(c));var u={source:m,generatedLine:l.generatedLine+(i.generatedOffset.generatedLine-1),generatedColumn:l.generatedColumn+(i.generatedOffset.generatedLine===l.generatedLine?i.generatedOffset.generatedColumn-1:0),originalLine:l.originalLine,originalColumn:l.originalColumn,name:c};this.__generatedMappings.push(u),"number"==typeof u.originalLine&&this.__originalMappings.push(u)}n(this.__generatedMappings,o.compareByGeneratedPositionsDeflated),n(this.__originalMappings,o.compareByOriginalPositions)},t.IndexedSourceMapConsumer=u},function(e,t,r){"use strict";t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,r,o,i){if(0===r.length)return-1;var s=function e(r,o,i,s,a,n){var l=Math.floor((o-r)/2)+r,m=a(i,s[l],!0);return 0===m?l:m>0?o-l>1?e(l,o,i,s,a,n):n==t.LEAST_UPPER_BOUND?o<s.length?o:-1:l:l-r>1?e(r,l,i,s,a,n):n==t.LEAST_UPPER_BOUND?l:r<0?-1:r}(-1,r.length,e,r,o,i||t.GREATEST_LOWER_BOUND);if(s<0)return-1;for(;s-1>=0&&0===o(r[s],r[s-1],!0);)--s;return s}},function(e,t,r){"use strict";function o(e,t,r){var o=e[t];e[t]=e[r],e[r]=o}function i(e,t,r,s){if(r<s){var a=r-1;o(e,(c=r,u=s,Math.round(c+Math.random()*(u-c))),s);for(var n=e[s],l=r;l<s;l++)t(e[l],n)<=0&&o(e,a+=1,l);o(e,a+1,l);var m=a+1;i(e,t,r,m-1),i(e,t,m+1,s)}var c,u}t.quickSort=function(e,t){i(e,t,0,e.length-1)}},function(e,t,r){"use strict";var o=r(5).SourceMapGenerator,i=r(4),s=/(\r?\n)/,a="$$$isSourceNode$$$";function n(e,t,r,o,i){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==i?null:i,this[a]=!0,null!=o&&this.add(o)}n.fromStringWithSourceMap=function(e,t,r){var o=new n,a=e.split(s),l=0,m=function(){return e()+(e()||"");function e(){return l<a.length?a[l++]:void 0}},c=1,u=0,d=null;return t.eachMapping(function(e){if(null!==d){if(!(c<e.generatedLine)){var t=(r=a[l]||"").substr(0,e.generatedColumn-u);return a[l]=r.substr(e.generatedColumn-u),u=e.generatedColumn,h(d,t),void(d=e)}h(d,m()),c++,u=0}for(;c<e.generatedLine;)o.add(m()),c++;if(u<e.generatedColumn){var r=a[l]||"";o.add(r.substr(0,e.generatedColumn)),a[l]=r.substr(e.generatedColumn),u=e.generatedColumn}d=e},this),l<a.length&&(d&&h(d,m()),o.add(a.splice(l).join(""))),t.sources.forEach(function(e){var s=t.sourceContentFor(e);null!=s&&(null!=r&&(e=i.join(r,e)),o.setSourceContent(e,s))}),o;function h(e,t){if(null===e||void 0===e.source)o.add(t);else{var s=r?i.join(r,e.source):e.source;o.add(new n(e.originalLine,e.originalColumn,s,t,e.name))}}},n.prototype.add=function(e){if(Array.isArray(e))e.forEach(function(e){this.add(e)},this);else{if(!e[a]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e)}return this},n.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else{if(!e[a]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e)}return this},n.prototype.walk=function(e){for(var t,r=0,o=this.children.length;r<o;r++)(t=this.children[r])[a]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},n.prototype.join=function(e){var t,r,o=this.children.length;if(o>0){for(t=[],r=0;r<o-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},n.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[a]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},n.prototype.setSourceContent=function(e,t){this.sourceContents[i.toSetString(e)]=t},n.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][a]&&this.children[t].walkSourceContents(e);var o=Object.keys(this.sourceContents);for(t=0,r=o.length;t<r;t++)e(i.fromSetString(o[t]),this.sourceContents[o[t]])},n.prototype.toString=function(){var e="";return this.walk(function(t){e+=t}),e},n.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new o(e),i=!1,s=null,a=null,n=null,l=null;return this.walk(function(e,o){t.code+=e,null!==o.source&&null!==o.line&&null!==o.column?(s===o.source&&a===o.line&&n===o.column&&l===o.name||r.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:t.line,column:t.column},name:o.name}),s=o.source,a=o.line,n=o.column,l=o.name,i=!0):i&&(r.addMapping({generated:{line:t.line,column:t.column}}),s=null,i=!1);for(var m=0,c=e.length;m<c;m++)10===e.charCodeAt(m)?(t.line++,t.column=0,m+1===c?(s=null,i=!1):i&&r.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:t.line,column:t.column},name:o.name})):t.column++}),this.walkSourceContents(function(e,t){r.setSourceContent(e,t)}),{code:t.code,map:r}},t.SourceNode=n},function(e,t){e.exports=require("main.js.map")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Splash=(()=>{console.log('<p style="color:#AE81FF">\n _____ _____ _____ _____ _____ _____ _____    _____    __ _____ _____ \n|   __|     | __  |   __|   __|  _  |   __|  |     |__|  | __  |  |  |\n|__   |   --|    -|   __|   __|   __|__   |  |  |  |  |  | __ -|    -|\n|_____|_____|__|__|_____|_____|__|  |_____|  |_____|_____|_____|__|__|\nVersion: 1.0.0   |   Build Time: April 19th 2018, 11:43:54 pm \n</p>\n')})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(24);t.default=new class{constructor(){this.loop=(()=>{CPU.fresh(),this.fresh(),this.register(),this.run(),this.cleanup(),this.addon(),CPU.handleData()}),this.install=(()=>{o.install(),this.extend()}),this.extend=(()=>{Room.extend(),Flag.extend(),Task.extend(),Creep.extend(),CMemory.extend()}),this.fresh=(()=>{CPU.check("fresh"),Room.fresh(),Flag.fresh(),Task.fresh(),Population.fresh(),Creep.fresh(),CMemory.fresh(),CPU.end("fresh")}),this.analyze=(()=>{CPU.check("analyze","Flag"),Flag.analyze(),CPU.end("analyze","Flag"),CPU.check("analyze","Room"),Room.analyze(),CPU.end("analyze","Room"),CPU.check("analyze","Population"),Population.analyze(),CPU.end("analyze","Population")}),this.register=(()=>{CPU.check("register","Room"),Room.register(),CPU.end("register","Room"),this.analyze(),CPU.check("register","Task"),Task.register(),CPU.end("register","Task"),CPU.check("register","Creep"),Creep.register(),CPU.end("register","Creep"),CPU.check("register","StructureSpawn"),StructureSpawn.register(),CPU.end("register","StructureSpawn")}),this.run=(()=>{CPU.check("run","Layout"),Layout.run(),CPU.end("run","Layout"),CPU.check("run","Room"),Room.run(),CPU.end("run","Room"),CPU.check("run","Flag"),Flag.run(),CPU.end("run","Flag"),CPU.check("run","Task"),Task.run(),CPU.end("run","Task"),CPU.check("run","Population"),Population.run(),CPU.end("run","Population"),CPU.check("run","Creep"),Creep.run(),CPU.end("run","Creep"),CPU.check("run","StructureSpawn"),StructureSpawn.run(),CPU.end("run","StructureSpawn")}),this.cleanup=(()=>{CPU.check("cleanup"),Room.cleanup(),Flag.cleanup(),Population.cleanup(),CMemory.cleanup(),CPU.end("cleanup")}),this.addon=(()=>{SEND_STATISTIC_REPORTS&&((!Memory.statistics||Memory.statistics.tick&&Memory.statistics.tick+TIME_REPORT<=Game.time)&&Statistics.run(),Util.processReports()),CPU.check("addon","Visuals"),ROOM_VISUALS&&!Memory.CPU_CRITICAL&&Visuals.run(),CPU.end("addon","Visuals"),CPU.check("addon","Grafana"),GRAFANA&&Game.time%GRAFANA_INTERVAL==0&&Grafana.run(),CPU.end("addon","Grafana")})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(25),i=r(51),s=r(2);t.install=(()=>{console.log(s.Emoji.reload,"Code Reloading ...");const e=Game.cpu.getUsed();s.Install("_ME",s.getUsername),s.Install(global,r(53)),s.Install("Util",r(2).default,{DiamondIterator:r(54).default,SpiralIterator:r(55).default}),o.ProtoypeInstall(),i.TravelerInstall(),s.Install(global,r(56).default,{CPU:r(57).default,Dye:r(63).default,Log:r(64).default,CMemory:r(66).default,Layout:r(67).default,Population:r(68).default,Statistics:r(69).default}),s.Install(Flag,r(70).default),s.Install("Task",r(71).default,{guard:r(72).default,defense:r(73).default,mining:r(74).default,claim:r(75).default,reserve:r(76).default,pioneer:r(77).default,attackController:r(78).default,robbing:r(79).default,reputation:r(80).default,delivery:r(81).default,labTech:r(82).default,safeGen:r(83).default,scheduler:r(84).default}),s.Install(Creep,{Action:r(0).CreepAction,Behaviour:r(0).Behaviour,Setup:r(0).CreepSetup}),s.Install(Creep.action={},{attackController:r(85).default,avoiding:r(86).default,boosting:r(87).default,building:r(88).default,bulldozing:r(89).default,charging:r(90).default,claiming:r(91).default,defending:r(92).default,dismantling:r(93).default,dropping:r(94).default,feeding:r(95).default,fortifying:r(96).default,fueling:r(97).default,guarding:r(98).default,harvesting:r(99).default,healing:r(100).default,idle:r(101).default,invading:r(102).default,mining:r(103).default,picking:r(104).default,reallocating:r(105).default,recycling:r(106).default,repairing:r(107).default,reserving:r(108).default,robbing:r(109).default,safeGen:r(110).default,storing:r(111).default,travelling:r(112).default,uncharging:r(113).default,upgrading:r(114).default,withdrawing:r(115).default}),s.Install(Creep.behaviour={},{claimer:r(116).default,collapseWorker:r(117).default,hauler:r(118).default,healer:r(119).default,labTech:r(120).default,melee:r(121).default,miner:r(122).default,mineralMiner:r(123).default,remoteMiner:r(124).default,remoteHauler:r(125).default,remoteWorker:r(126).default,pioneer:r(127).default,privateer:r(128).default,recycler:r(129).default,ranger:r(130).default,upgrader:r(131).default,worker:r(132).default,safeGen:r(133).default}),s.Install(Creep.setup={},{hauler:r(134).default,healer:r(135).default,miner:r(136).default,mineralMiner:r(137).default,privateer:r(138).default,upgrader:r(139).default,worker:r(140).default}),s.Install(Creep,r(141).default),s.Install(Room,r(142).default,{manager:{construction:r(143).default,containers:r(144).default,defense:r(145).default,extensions:r(146).default,labs:r(147).default,links:r(148).default,nuker:r(149).default,observers:r(150).default,orders:r(151).default,power:r(152).default,resources:r(153).default,spawns:r(154).default,towers:r(155).default,fillRoomOrders:r(156).default,boostProduction:r(157).default}}),s.Install(StructureTower,r(158).default),s.Install(StructureSpawn,r(159).default),s.Install(global,{Grafana:GRAFANA?r(160).default:void 0,Visuals:r(161).default,Command:r(168)}),s.Install("isRoot",!0);const t=Game.cpu.getUsed();Log.success("Root Done",`[cpu-cost:${(t-e).toFixed(2)}]`)})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProtoypeInstall=(()=>{r(26),r(27),r(28),r(29),r(31),r(32),r(33),r(34),r(35),r(36),r(37),r(38),r(39),r(40),r(41),r(42),r(47),r(48),r(49),r(50)})},function(e,t){Object.defineProperties(global,{observerRequests:{get:()=>Util.get(global,"_observerRequests",[]),set(e){Util.get(global,"_observerRequests",[]).push(e)}},cacheValid:{get:()=>Memory.cacheValid},profiler:{get:()=>Memory.profiler}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(8);Object.defineProperties(Creep.prototype,{flee:{get(){if(this.data)return this.data.flee?this.data.flee=this.hits!==this.hitsMax:this.data.flee=this.hits/this.hitsMax<.35,this.data.flee},set(e){this.data.flee=e}},sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!==Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.carry)),this._sum}},carries:{get(){return(_.isUndefined(this._carries)||this._carrySet!==Game.time)&&(this._carrySet=Game.time,this._carries={},Object.keys(this.carry).forEach(e=>{_.isUndefined(this._carries[e])&&(this._carries[e]=this.carry[e])})),this._carries}},threat:{get(){return _.isUndefined(this._threat)&&(this._threat=Creep.bodyThreat(this.body)),this._threat}},trace:{get(){return Memory.debugTrace.creepName===this.name},set(e){e?Memory.debugTrace.creepName=this.name:this.trace&&delete Memory.debugTrace.creepName}},behaviour:{get(){return Creep.behaviour[this.data.creepType]}},assignAction:{value(e,t){if("string"==typeof e&&(e=Creep.action[e]),e&&e instanceof Creep.Action)return e.assign(this,t)}},assignBehaviour:{value(e){if("string"==typeof e&&(e=Creep.behaviour[e]),e&&e instanceof Creep.Behaviour)return e.assign(this)}},findGroupMemberByType:{value(e,t){return this.findGroupMemberBy(t=>t.creepType===e,t)}},findGroupMemberBy:{value(e,t){if(_.isUndefined(t)&&(t=this.data.flagName),!_.isUndefined(e)&&t){const r=_(Memory.population).filter({flagName:t}).find(e);return r?r.creepName:null}return Log.error(`${this.name} - Invalid arguments for Creep.findGroupMemberBy ${t} ${e}`),null}},findByType:{value(e){let t;for(let r in Memory.population)if((t=Memory.population[r]).creepType===e)return r}},getBodyparts:{value(e){return _(this.body).filter({type:e}).value().length}},hasActiveBodyparts:{value(e){return this.hasBodyparts(e,this.body.length-Math.ceil(.01*this.hits))}},hasBodyparts:{value(e,t=0){const r=this.body,o=r.length;Array.isArray(e)||(e=[e]);for(let i=t;i<o;i++)if(e.includes(r[i].type))return!0;return!1}},run:{value(e){if(!this.spawning){if(!e&&this.data&&this.data.creepType){if(e=Creep.behaviour[this.data.creepType],this.room.skip)return;if(Memory.CPU_CRITICAL&&!CRITICAL_ROLES.includes(this.data.creepType))return}if(this.data&&!_.contains(["remoteMiner","miner","upgrader"],this.data.creepType)&&(this.repairNearby(),this.buildNearby()),LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Behaviour:e&&e.name,Creep:"run"}),e)e.run(this);else if(!this.data){LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Creep:"run"},"memory init");let e=this.memory.setup,t=this.memory.cost,r=this.memory.home,o=this.memory.mother,i=this.memory.breeding;if(e&&t&&r&&o&&i){Log.module("Creep","Fixing corrupt creep without population entry: "+this.name);let s=Population.setCreep({creepName:this.name,creepType:e,weight:t,roomName:this.pos.roomName,homeRoom:r,motherSpawn:o,actionName:this.action?this.action.name:null,targetId:this.target?this.target.id||this.target.name:null,spawningTime:i,flagName:null,body:_.countBy(this.body,"type")});Population.countCreep(this.room,s)}else{Log.error("[Creep] Corrupt creep without population entry! : "+this.name,Log.stack());let e=_.countBy(this.body,"type");if(e[WORK]&&e[CARRY]){let t=e[WORK]*BODYPART_COST[WORK]+e[CARRY]*BODYPART_COST[CARRY]+e[MOVE]*BODYPART_COST[MOVE],r=Population.setCreep({creepName:this.name,creepType:"worker",weight:t,roomName:this.pos.roomName,homeRoom:this.pos.roomName,motherSpawn:null,actionName:null,targetId:null,spawningTime:-1,flagName:null,body:_.countBy(this.body,"type")});Population.countCreep(this.room,r)}else this.suicide()}}this.flee&&(this.fleeMove(),Creep.behaviour.ranger.heal(this),SAY_ASSIGNMENT&&this.say(String.fromCharCode(10133),SAY_PUBLIC))}o.Strategy.freeStrategy(this)}},leaveBorder:{value(){let e=0;return 0===this.pos.y?e=BOTTOM:0===this.pos.x?e=RIGHT:49===this.pos.y?e=TOP:49===this.pos.x&&(e=LEFT),e&&this.move(e),e}},honk:{value(){HONK&&this.say("⛔︎",SAY_PUBLIC)}},honkEvade:{value(){HONK&&this.say("🔀︎",SAY_PUBLIC)}},fleeMove:{value(){LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Action:"fleeMove",Creep:"run"});if(_.forEach(Object.keys(this.carry),e=>{this.carry[e]>0&&this.drop(e)}),this.fatigue>0)return;let e;if(!this.data.fleePath||this.data.fleePath.length<2||this.data.fleePath[0].x!==this.pos.x||this.data.fleePath[0].y!==this.pos.y||this.data.fleePath[0].roomName!==this.pos.roomName){const t=_.map(this.room.hostiles,e=>({pos:e.pos,range:5}));e=PathFinder.search(this.pos,t,{flee:!0,plainCost:2,swampCost:10,maxOps:500,maxRooms:2,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.creepMatrix}}).path,this.data.fleePath=e}else this.data.fleePath.shift(),e=this.data.fleePath;e&&e.length>0&&this.move(this.pos.getDirectionTo(new RoomPosition(e[0].x,e[0].y,e[0].roomName)))}},idleMove:{value(){if(this.fatigue>0)return;if(_(this.room.structures.piles).filter("pos",this.pos).concat(this.pos.lookFor(LOOK_STRUCTURES)).concat(this.pos.lookFor(LOOK_CONSTRUCTION_SITES)).size()){if(this.data.idle&&this.data.idle.path&&this.data.idle.path.length&&!this.pos.isEqualTo(this.data.idle.lastPos))this.data.idle.path=this.data.idle.path.substr(1);else{const e=Flag.find(FLAG_COLOR.command.idle,this.pos,!0,(e,t)=>{const r=Game.flags[t.name].pos.lookFor(LOOK_CREEPS);return r&&r.length?1/0:e});let t;if(e)t=PathFinder.search(this.pos,{pos:e.pos,range:0},{plainCost:2,swampCost:10,maxOps:350,maxRooms:1,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}});else{let e=this.room.structures.all.map(e=>({pos:e.pos,range:1})).concat(this.room.sources.map(e=>({pos:e.pos,range:2}))).concat(this.pos.findInRange(FIND_EXIT,2).map(e=>({pos:e,range:1}))).concat(this.room.myConstructionSites.map(e=>({pos:e.pos,range:1})));t=PathFinder.search(this.pos,e,{flee:!0,plainCost:2,swampCost:10,maxOps:350,maxRooms:1,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}})}this.data.idle={path:Traveler.serializePath(this.pos,t.path),lastPos:this.pos}}const e=parseInt(this.data.idle.path[0],10);e&&(this.data.idle.lastPos=this.pos,this.move(e)),this.data.idle.path&&!this.data.idle.path.length&&delete this.data.idle}}},repairNearby:{value(){if(!this.room.controller||!this.room.controller.owner||this.room.my||this.room.reserved||this.room.ally)if(this.carry.energy>0&&this.hasActiveBodyparts(WORK)){const e=this.data&&"remoteHauler"===this.data.creepType?REMOTE_HAULER.DRIVE_BY_REPAIR_RANGE:DRIVE_BY_REPAIR_RANGE,t=_(this.pos.findInRange(FIND_STRUCTURES,e)).find(e=>Room.shouldRepair(this.room,e));t&&(LOG_TRACE&&Log.trace("Creep",{creepName:this.name,Action:"repairing",Creep:"repairNearby"},t.pos),this.repair(t))}else LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Action:"repairing",Creep:"repairNearby"},"not repairing")}},buildNearby:{value(){if(!REMOTE_HAULER.DRIVE_BY_BUILDING||!this.data||"remoteHauler"!==this.data.creepType)return;const e=_(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES,REMOTE_HAULER.DRIVE_BY_BUILD_RANGE)).find(e=>REMOTE_HAULER.DRIVE_BY_BUILD_ALL||e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD);e?(LOG_TRACE&&Log.trace("Creep",{creepName:this.name,Action:"building",Creep:"buildNearby"},e.pos),this.build(e)):LOG_TRACE&&Log.trace("Creep",{creepName:this.name,Action:"building",Creep:"buildNearby"},"not building")}},controllerSign:{value(){const e=Util.fieldOrFunction(CONTROLLER_SIGN_MESSAGE,this.room);CONTROLLER_SIGN&&(!this.room.controller.sign||this.room.controller.sign.username!==this.owner.username||CONTROLLER_SIGN_UPDATE&&this.room.controller.sign.text!==e)&&this.signController(this.room.controller,e)}},handleError:{value(e){Creep.resolvingError||(this.resolvingError=e,e.preventDefault=(()=>{Creep.resolvingError=null}),Creep.error.trigger(e),Creep.resolvingError&&(Log.errorCode(this,e.errorCode),delete this.data.actionName,delete this.data.targetId,Creep.resolvingError=null))}},explainAgent:{value(){return this.action&&this.action.showAssignment(this,this.target),`ttl:${this.ticksToLive} pos:${this.pos}`}},travelTo:{value(e,t={}){return e=e.pos||e,global.traveler&&global.travelerTick!==Game.time&&(global.traveler=new Traveler),t=this.getStrategyHandler([],"moveOptions",t),_.defaults(t,{allowSK:!0,avoidSKCreeps:!0,debug:DEBUG,reportThreshold:TRAVELER_THRESHOLD,useFindRoute:_.get(global,"ROUTE_PRECALCULATION",!0),routeCallback:Room.routeCallback(this.pos.roomName,e.roomName,t),getStructureMatrix:e=>Room.getStructureMatrix(e.name||e,t),getCreepMatrix:e=>e.getCreepMatrix(t.getStructureMatrix(e))}),t.respectRamparts&&this.room.situation.invasion&&_.filter(this.pos.lookFor(LOOK_STRUCTURES),{my:!0,structureType:STRUCTURE_RAMPART}).length?OK:traveler.travelTo(this,e,t)}}})},function(e,t){Object.defineProperties(Flag.prototype,{print:{get(){return Util.makeFlagUrl(this.name)}},cloaking:{get(){return this.memory.cloaking||0},set(e){this.memory.cloaking=e}},compareTo:{value(e){return Flag.compare(this,e)}}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(30);Room.prototype._find=Room.prototype.find,Object.defineProperties(Room.prototype,{print:{get(){return Util.makeRoomUrl(this.name)}},find:{value(e,t){return _.isArray(e)?_(e).map(e=>this._find(e,t)).flatten().value():this._find(e,t)}},structures:{get(){return _.isUndefined(this._structures)&&(this._structures=new o.RoomStructures(this)),this._structures}},combatCreeps:{get(){return _.isUndefined(this._combatCreeps)&&(this._combatCreeps=this.creeps.filter(e=>["melee","ranger","healer","warrior"].includes(e.data.creepType))),this._combatCreeps}},casualties:{get(){if(_.isUndefined(this._casualties)){let e=e=>e.hits<e.hitsMax&&(void 0===e.towers||0==e.towers.length);this._casualties=_.sortBy(_.filter(this.creeps,e),"hits")}return this._casualties}},conserveForDefense:{get(){return this.my&&this.storage&&this.storage.charge<0}},defenseLevel:{get(){if(_.isUndefined(this._defenseLevel)){this._defenseLevel={towers:0,creeps:0,sum:0};let e=e=>{this._defenseLevel.creeps+=e.threat};this.combatCreeps.forEach(e),this._defenseLevel.towers=this.structures.towers.length,this._defenseLevel.sum=this._defenseLevel.creeps+this._defenseLevel.towers*CREEP_PART_THREAT.tower}return this._defenseLevel}},hostile:{get(){return this.memory.hostile}},hostiles:{get(){return _.isUndefined(this._hostiles)&&(this._hostiles=this.find(FIND_HOSTILE_CREEPS,{filter:Task.reputation.hostileOwner})),this._hostiles}},hostileIds:{get(){return _.isUndefined(this._hostileIds)&&(this._hostileIds=_.map(this.hostiles,"id")),this._hostileIds}},hostileThreatLevel:{get(){if(_.isUndefined(this._hostileThreatLevel)){this._hostileThreatLevel=0;let e=e=>{this._hostileThreatLevel+=e.threat};this.hostiles.forEach(e)}return this._hostileThreatLevel}},processInvaders:{value(){void 0===this.memory.hostileIds&&(this.memory.hostileIds=[]),SEND_STATISTIC_REPORTS?void 0===this.memory.statistics&&(this.memory.statistics={}):delete this.memory.statistics;_.forEach(this.hostiles,e=>{if(!Room.isCenterNineRoom(this.name)&&!this.memory.hostileIds.includes(e.id)&&(this.memory.hostileIds.push(e.id),this.newInvader.push(e),SEND_STATISTIC_REPORTS)){let t=JSON.stringify(_.countBy(e.body,"type"));void 0===this.memory.statistics.invaders&&(this.memory.statistics.invaders=[]),this.memory.statistics.invaders.push({owner:e.owner.username,id:e.id,body:t,enter:Game.time,time:Date.now()})}});_.forEach(this.memory.hostileIds,e=>{const t=Game.getObjectById(e);if((!t||!Task.reputation.hostileOwner(t))&&(this.goneInvader.push(e),SEND_STATISTIC_REPORTS&&this.memory.statistics&&void 0!==this.memory.statistics.invaders&&this.memory.statistics.invaders.length>0)){let t=t=>t.id==e&&void 0===t.leave,r=_.find(this.memory.statistics.invaders,t);void 0!=r&&(r.leave=Game.time)}}),this.memory.hostileIds=this.hostileIds}},registerIsHostile:{value(){this.controller&&(_.isUndefined(this.hostile)||"number"==typeof this.hostile)&&(!this.controller.owner||this.controller.my||this.ally?delete this.memory.hostile:this.memory.hostile=this.controller.level)}},flags:{get(){return Util.get(this,"_flags",_.filter(Flag.list,{roomName:this.name}))}},isCriticallyFortifyable:{get(){return _.some(this.structures.fortifyable,"isCriticallyFortifyable")}},relativeEnergyAvailable:{get(){return _.isUndefined(this._relativeEnergyAvailable)&&(this._relativeEnergyAvailable=this.energyCapacityAvailable>0?this.energyAvailable/this.energyCapacityAvailable:0),this._relativeEnergyAvailable}},relativeRemainingEnergyAvailable:{get(){return this.energyCapacityAvailable>0?this.remainingEnergyAvailable/this.energyCapacityAvailable:0}},remainingEnergyAvailable:{get(){return this.energyAvailable-this.reservedSpawnEnergy}},reservedSpawnEnergy:{get(){return _.isUndefined(this._reservedSpawnEnergy)&&(this._reservedSpawnEnergy=0),this._reservedSpawnEnergy},set(e){this._reservedSpawnEnergy=e}},creeps:{get(){return _.isUndefined(this._creeps)&&(this._creeps=this.find(FIND_MY_CREEPS)),this._creeps}},allCreeps:{get(){return _.isUndefined(this._allCreeps)&&(this._allCreeps=this.find(FIND_CREEPS)),this._allCreeps}},immobileCreeps:{get(){return _.isUndefined(this._immobileCreeps)&&(this._immobileCreeps=_.filter(this.creeps,e=>{const t=e.data&&e.data.determinatedSpot;return t&&e.pos.isEqualTo(e.room.getPositionAt(t.x,t.y))})),this._immobileCreeps}},situation:{get(){return _.isUndefined(this._situation)&&(this._situation={noEnergy:0==this.sourceEnergyAvailable,invasion:this.hostiles.length>0&&(!this.controller||!this.controller.safeMode)}),this._situation}},adjacentRooms:{get(){return _.isUndefined(this.memory.adjacentRooms)&&(this.memory.adjacentRooms=Room.adjacentRooms(this.name)),this.memory.adjacentRooms}},adjacentAccessibleRooms:{get(){return _.isUndefined(this.memory.adjacentAccessibleRooms)&&(this.memory.adjacentAccessibleRooms=Room.adjacentAccessibleRooms(this.name)),this.memory.adjacentAccessibleRooms}},privateerMaxWeight:{get(){if(_.isUndefined(this._privateerMaxWeight)&&(this._privateerMaxWeight=0,!this.situation.invasion&&!this.conserveForDefense)){let e,t,r,o,i=1e3*this.controller.level,s=e=>{e!=this.name&&Room.isMine(e)&&t++},a=a=>{this.adjacentAccessibleRooms.includes(a.roomName)&&((r=Game.rooms[a.roomName])?(e=r.adjacentAccessibleRooms,o=r.sources.length):(e=Room.adjacentAccessibleRooms(a.roomName),o=1),t=1,e.forEach(s),this._privateerMaxWeight+=o*i/t)};Flag.filter(FLAG_COLOR.invade.exploit).forEach(a)}return this._privateerMaxWeight}},claimerMaxWeight:{get(){if(_.isUndefined(this._claimerMaxWeight)){this._claimerMaxWeight=0;let e,t,r,o=1250,i=2,s=this.controller.level,a=a=>{if(s>3||a.color==FLAG_COLOR.claim.color&&a.secondaryColor==FLAG_COLOR.claim.secondaryColor){if((e=Room.roomDistance(this.name,a.roomName))>i)return;if((r=Game.flags[a.name]).room&&r.room.controller&&r.room.controller.reservation&&r.room.controller.reservation.ticksToEnd>2500)return;t=r.targetOf&&r.targetOf?_.sum(r.targetOf.map(e=>"claimer"==e.creepType?e.weight:0)):0,this._claimerMaxWeight+=o-t}};Flag.filter([FLAG_COLOR.claim,FLAG_COLOR.claim.reserve,FLAG_COLOR.invade.exploit]).forEach(a)}return this._claimerMaxWeight}},structureMatrix:{get(){if(_.isUndefined(this._structureMatrix)){const e=Room.getCachedStructureMatrix(this.name);if(e)this._structureMatrix=e;else{Log.room(this.name,"Matrix: Calculating cost matrix");const e=new PathFinder.CostMatrix;let t=t=>{const r=t instanceof ConstructionSite;if(r&&!t.my&&Task.reputation.allyOwner(t))return e.set(t.pos.x,t.pos.y,255);if(t.structureType===STRUCTURE_ROAD){if(!r||USE_UNBUILT_ROADS)return e.set(t.pos.x,t.pos.y,1)}else{if(t.structureType===STRUCTURE_PORTAL)return e.set(t.pos.x,t.pos.y,255);if(OBSTACLE_OBJECT_TYPES.includes(t.structureType)){if(!r||Task.reputation.allyOwner(t))return e.set(t.pos.x,t.pos.y,255)}else if(t.structureType===STRUCTURE_RAMPART&&!t.my&&!t.isPublic&&(!r||Task.reputation.allyOwner(t)))return e.set(t.pos.x,t.pos.y,255)}};this.structures.all.forEach(t),this.constructionSites.forEach(t),this.immobileCreeps.forEach(t=>e.set(t.pos.x,t.pos.y,255));const r=_.get(Room.pathfinderCache,[this.name,"updated"]);Room.pathfinderCache[this.name]={costMatrix:e,updated:Game.time,version:Room.COSTMATRIX_CACHE_VERSION},Room.pathfinderCacheDirty=!0,LOG_TRACE&&Log.trace("PathFinder",{roomName:this.name,prevTime:r,structures:this.structures.all.length,PathFinder:"CostMatrix"},"updated costmatrix"),this._structureMatrix=e}}return this._structureMatrix}},avoidSKMatrix:{get(){if(_.isUndefined(this._avoidSKMatrix)){const e=this.hostiles.filter(e=>"Source Keeper"===e.owner.username);this._avoidSKMatrix=this.getAvoidMatrix({"Source Keeper":e})}return this._avoidSKMatrix}},my:{get(){return _.isUndefined(this._my)&&(this._my=this.controller&&this.controller.my),this._my}},myReservation:{get(){return _.isUndefined(this._myReservation)&&(this._myReservation=this.reservation===ME),this._myReservation}},reserved:{get(){if(_.isUndefined(this._reserved))if(this.controller){const e=_.find(Game.spawns).owner.username;this._reserved=this.controller.my||this.controller.reservation&&this.controller.reservation.username===e}else this._reserved=!1;return this._reserved}},owner:{get(){return _.isUndefined(this._owner)&&(this.controller&&this.controller.owner?this._owner=this.controller.owner.username:this._owner=!1),this._owner}},reservation:{get(){return _.isUndefined(this._reservation)&&(this.controller&&this.controller.reservation?this._reservation=this.controller.reservation.username:this._reservation=!1),this._reservation}},ally:{get(){return _.isUndefined(this._ally)&&(this.reserved?this._ally=!0:this.controller?this._ally=Task.reputation.isAlly(this.owner)||Task.reputation.isAlly(this.reservation):this._ally=!1),this._ally}},pavementArt:{get(){return _.isUndefined(this.memory.pavementArt)&&(this.memory.pavementArt=[]),this.memory.pavementArt}},collapsed:{get(){if(_.isUndefined(this._collapsed)){if(!this.my)return void(this._collapsed=!1);if(!this.population)return void(this._collapsed=!0);let e=this.population.typeCount.worker?this.population.typeCount.worker:0,t=this.population.typeCount.hauler?this.population.typeCount.hauler:0,r=this.population.typeCount.pioneer?this.population.typeCount.pioneer:0;this._collapsed=e+t+r===0}return this._collapsed}},RCL:{get(){if(this.controller)return Util.get(this.memory,"RCL",this.controller.level)}},skip:{get(){return Util.get(this,"_skip",!!Flag.find(FLAG_COLOR.command.skipRoom,this))}},checkRCL:{value(){this.controller&&this.memory.RCL!==this.controller.level&&(Room.RCLChange.trigger(this),this.memory.RCL=this.controller.level)}},countMySites:{value(){const e=_.size(this.myConstructionSites);_.isUndefined(this.memory.myTotalSites)||e===this.memory.myTotalSites||Room.costMatrixInvalid.trigger(this),e>0?this.memory.myTotalSites=e:delete this.memory.myTotalSites}},countMyStructures:{value(){const e=_.size(this.structures.my);_.isUndefined(this.memory.myTotalStructures)||e===this.memory.myTotalStructures?delete this.memory.myTotalStructures:(Room.costMatrixInvalid.trigger(this),this.saveExtensions(),this.saveSpawns())}},findRoute:{value(e,t=!0,r=!0,o=!0){if(this.name==e)return[];const i={checkOwner:t,preferHighway:r,allowSK:o};return Game.map.findRoute(this,e,{routeCallback:Room.routeCallback(this.name,e,i)})}},getBorder:{value(e){return _.findKey(Game.map.describeExits(this.name),function(e){return this.name===e},{name:e})}},recordMove:{value(e){if(!ROAD_CONSTRUCTION_ENABLE&&(!ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]||ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]&&-1==ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name].indexOf(this.name)))return;let t=e.pos.x,r=e.pos.y;if(0==t||0==r||49==t||49==r||0==e.carry.energy||"building"==e.data.actionName)return;let o=`${String.fromCharCode(32+t)}${String.fromCharCode(32+r)}_x${t}-y${r}`;this.roadConstructionTrace[o]?this.roadConstructionTrace[o]++:this.roadConstructionTrace[o]=1}},isWalkable:{value(e,t,r){return 0==(r=r?r[t][e]:this.lookAt(e,t)).filter(e=>e.type==LOOK_TERRAIN&&"wall"==e.terrain||OBSTACLE_OBJECT_TYPES.includes(e[e.type].structureType)).length}},exits:{value(e,t){let r,o,i;!0===t&&(t=.5),r=0===e?_.chain(this.find(FIND_STRUCTURES)).filter(function(e){return e.structureType===STRUCTURE_PORTAL}).map("pos").value():this.find(e);let s={},a=-1;const n=[];for(let e=0;e<r.length;e++){const l=r[e];_.get(s,[l.x-1,l.y])||_.get(s,[l.x,l.y-1])||(t&&-1!==a&&(n[a].x+=Math.ceil(t*(o-n[a].x)),n[a].y+=Math.ceil(t*(i-n[a].y))),n[++a]=_.pick(l,["x","y"]),o=l.x,i=l.y,s={}),_.set(s,[l.x,l.y],!0),o=Math.max(o,l.x),i=Math.max(i,l.y)}return t&&-1!==a&&(n[a].x+=Math.ceil(t*(o-n[a].x)),n[a].y+=Math.ceil(t*(i-n[a].y))),n}},showCostMatrix:{value(e=this.structureMatrix,t){const r=new RoomVisual(this.name);let o=0,i=50,s=0,a=50;t&&(o=Math.max(0,t.y-3),i=Math.min(50,t.y+4),s=Math.max(0,t.x-3),a=Math.min(50,t.x+4));const n=_.max(e._bits);for(let t=o;t<i;t++)for(let o=s;o<a;o++){const i=e.get(o,t);i&&r.text(i,o,t),r.rect(o-.5,t-.5,1,1,{fill:(l=i/n,`hsl(${(120*(1-l)).toString(10)}, 100%, 50%)`)})}var l}},getAvoidMatrix:{value(e){const t=this.structureMatrix.clone();for(const r in e){const o=e[r];for(const e of o)for(let r=Math.max(0,e.pos.x-3);r<=Math.min(49,e.pos.x+3);r++){const o=r<e.pos.x?e.pos.x-r:r-e.pos.x;for(let i=Math.max(0,e.pos.y-3);i<=Math.min(49,e.pos.y+3);i++)if(this.isWalkable(r,i)){const s=i<e.pos.y?e.pos.y-i:i-e.pos.y,a=17-2*Math.max(o,s);t.set(r,i,a)}}}return t}},getCreepMatrix:{value(e=this.structureMatrix){if(_.isUndefined(this._creepMatrix)){const t=e.clone();this.allCreeps.forEach(function(e){t.set(e.pos.x,e.pos.y,255)}),this._creepMatrix=t}return this._creepMatrix}},invalidateCostMatrix:{value(){Room.costMatrixInvalid.trigger(this.name)}},highwayHasWalls:{value(){return!!Room.isHighwayRoom(this.name)&&!!_.find(this.getPositionAt(25,25).lookFor(LOOK_STRUCTURES),e=>e instanceof StructureWall)}},isTargetAccessible:{value(e,t){if(!e||!t)return;e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos);for(const r of["x","y","roomName"])if(!Reflect.has(e,r)||!Reflect.has(t,r))return;if(!Room.isHighwayRoom(this.name))return;if(!this.highwayHasWalls())return!0;const[r,o]=Room.calcCoordinates(this.name,(e,t)=>[e,t]),i=e=>0===Math.floor(e.x/25)?LEFT:RIGHT,s=e=>0===Math.floor(e.y/25)?TOP:BOTTOM,a=e=>{const t=i(e),r=s(e);return t===LEFT?r===TOP?TOP_LEFT:BOTTOM_LEFT:r===TOP?TOP_RIGHT:BOTTOM_RIGHT};if(r%10==0){if(o%10==0){const r=!!_.find(this.getPositionAt(25,24).lookFor(LOOK_STRUCTURES),e=>e instanceof StructureWall),o=!!_.find(this.getPositionAt(24,25).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall)),n=!!_.find(this.getPositionAt(25,26).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall)),l=!!_.find(this.getPositionAt(26,25).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall));if(a(e)===a(t))return!0;if(r&&o&&n&&l)return a(e)===a(t);if(r){if(n)return o?Util.areEqual(RIGHT,i(e),i(t)):Util.areEqual(LEFT,i(e),i(t));if(o&&l)return s(e)===s(t)&&Util.areEqual(BOTTOM,s(e),s(t));if(Util.areEqual(BOTTOM,s(e),s(t)))return!0;if(o){if(Util.areEqual(RIGHT,i(e),i(t)))return!0;if(a(e)===TOP_LEFT&&a(t)!==TOP_LEFT)return!1}else{if(Util.areEqual(LEFT,i(e),i(t)))return!0;if(a(e)===TOP_RIGHT&&a(t)!==TOP_RIGHT)return!1}}else{if(o&&l)return s(e)===s(t)&&Util.areEqual(TOP,s(e),s(t));if(Util.areEqual(TOP,s(e),s(t)))return!0;if(o){if(Util.areEqual(RIGHT,i(e),i(t)))return!0;if(a(e)===BOTTOM_LEFT&&a(t)!==BOTTOM_LEFT)return!1}else{if(Util.areEqual(LEFT,i(e),i(t)))return!0;if(a(e)===BOTTOM_RIGHT&&a(t)!==BOTTOM_RIGHT)return!1}}return!0}if(i(e)===i(t))return!0}return o%10==0&&(s(e),s(t)),!0}},targetAccessible:{value(e){if(!e)return;e instanceof RoomObject&&(e=e.pos);for(const t of["x","y","roomName"])if(!Reflect.has(e,t))return;if(!Room.isHighwayRoom(this.name))return;if(!this.highwayHasWalls())return!0;const t=_(Game.rooms).filter("my").min(e=>Game.map.getRoomLinearDistance(e.name,this.name));if(t===1/0)return;const[r,o]=Room.calcGlobalCoordinates(this.name,(e,t)=>[e,t]),[i,s]=Room.calcGlobalCoordinates(t,(e,t)=>[e,t]);let a="";if(o-s<0?a+="south":o-s>0&&(a+="north"),r-i<0?a+="east":r-i>0&&(a+="west"),r%10==0){if(o%10==0){if(a.includes("south")&&a.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,49),e);if(a.includes("south")&&a.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,49),e);if(a.includes("north")&&a.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,0),e);if(a.includes("north")&&a.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,0),e)}if(a.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,25),e);if(a.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,25),e)}if(o%10==0){if(a.includes("south"))return this.isTargetAccessible(this.getPositionAt(25,49),e);if(a.includes("north"))return this.isTargetAccessible(this.getPositionAt(25,0),e)}return!0}},GCOrders:{value(){const e=this.memory.resources,t=_.filter(Game.rooms,{my:!0});if(_.isUndefined(e))return void Log.room(this.name,`there is no ${this.name}.memory.resources.`);if(0===e.orders.length)return;Log.room(this.name,`garbage collecting ${this.name} roomOrders`);const r=e.reactions;if(r.orders.length>0&&r.orders[0].amount>0){const t=r.orders[0],o=LAB_REACTIONS[t.type][0],i=LAB_REACTIONS[t.type][1];e.orders=_.filter(e.orders,e=>e.amount>0&&(e.type===o||e.type===i||!_.isUndefined(COMPOUNDS_TO_ALLOCATE[e.type])&&COMPOUNDS_TO_ALLOCATE[e.type].allocate))}else e.orders=_.filter(e.orders,e=>e.amount>0&&!_.isUndefined(COMPOUNDS_TO_ALLOCATE[e.type])&&COMPOUNDS_TO_ALLOCATE[e.type].allocate);if(this.ordersWithOffers())return e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,!1;Log.room(this.name,`not enough or no offers found. Updating room orders in room ${this.name}`),_.isUndefined(e.boostTiming.getOfferAttempts)?e.boostTiming.getOfferAttempts=0:e.boostTiming.getOfferAttempts++,Log.room(this.name,`${this.name} running GCAllRoomOffers`);for(let e of t){if(!e.memory.resources)continue;const t=e.memory.resources.offers;let r;for(let o=0;o<t.length;o++){let i=t[o],s=Game.rooms[i.room];if(!(s&&s.memory&&s.memory.resources&&s.memory.resources.orders))continue;let a=s.memory.resources.orders.find(e=>e.id===i.id&&e.type===i.type);a&&(r=a.offers.findIndex(t=>t.room===e.name)),a&&-1!==r||(Log.room(e.name,`Orphaned offer found and deleted in ${e.name}`),t.splice(o,1),o--)}}if(e.boostTiming.getOfferAttempts<3)return this.updateRoomOrders(),e.boostTiming.ordersPlaced=Game.time,e.boostTiming.checkRoomAt=Game.time+1,!0;e.orders=[],e.reactions.orders[0].amount=0,delete e.boostTiming.getOfferAttempts,Log.room(this.name,`${this.name} no offers found. Reaction and orders DELETED`)}},GCOffers:{value(){const e=this.memory.resources;let t=!1,r=0;if(_.isUndefined(e))return Log.room(this.name,`there is no ${this.name}.memory.resources.`),{readyOffersFound:r,terminalOrderPlaced:t};if(0===e.offers.length)return{readyOffersFound:r,terminalOrderPlaced:t};if(Log.room(this.name,`garbage collecting ${this.name} roomOffers`),e.offers=_.filter(e.offers,e=>{const t=Game.rooms[e.room],r=t.memory.resources.orders,o=this.resourcesAll[e.type];for(let i=0;i<r.length;i++){let s=r[i];if(e.id===s.id&&!_.isUndefined(o)&&o>=0)return!0;if(e.id===s.id)return t.memory.resources.orders[i].offers=[],!1}return!1}),e.offers.length>0)for(let o of e.offers){let i=this.terminal.store[o.type]||0;if(Log.room(this.name,`${i} / ${o.amount} ${o.type} are in ${this.name} terminal`),i>=.5*o.amount&&i<o.amount-MIN_OFFER_AMOUNT||i>=o.amount)Log.room(o.room,`${Math.min(i,o.amount)} ${o.type} are ready to send from ${this.name}`),r++;else{0===this.memory.resources.terminal.length&&this.memory.resources.terminal.push({id:this.terminal.id,orders:[]});const r=this.memory.resources.terminal[0],o=this.memory.resources.terminal[0].id,i=this.terminal;r.orders.length>0&&(r.orders=_.filter(r.orders,t=>(t.orderRemaining>0||t.storeAmount>0)&&_.some(e.offers,e=>e.type===t.type&&e.amount===t.orderRemaining+(i.store[e.type]||0))));for(let s of e.offers){const e=Util.sumCompoundType(r.orders,"orderRemaining"),a=(e[s.type]||0)+(i.store[s.type]||0);s.amount>a?(Log.room(this.name,`no / not enough terminal order found in ${this.name} for ${s.amount} ${s.type}`),Log.room(this.name,`terminal stores: ${i.store[s.type]||0} ordered: ${e[s.type]||0}`),Log.room(this.name,`terminal order placed for ${Math.max(s.amount,MIN_OFFER_AMOUNT)} ${s.type}`),this.placeOrder(o,s.type,Math.max(s.amount,MIN_OFFER_AMOUNT)),t=!0):Log.room(this.name,`${this.name} terminal orders for ${s.amount} ${s.type} is OK.`)}}}return{readyOffersFound:r,terminalOrderPlaced:t}}},GCLabs:{value(){Log.room(this.name,`garbage collecting labOrders in ${this.name}`);const e=this.memory.resources,t=e.lab,r=e.reactions.orders[0];for(let o=0;o<t.length;o++){const i=t[o];let s;if(i.orders.length>0){if(e.reactions.orders.length>0){const e=LAB_REACTIONS[r.type][0],t=LAB_REACTIONS[r.type][1];s=_.filter(i.orders,r=>{if((r.orderAmount>0||r.orderRemaining>0||r.storeAmount>0)&&(r.type===e||r.type===t||"energy"===r.type||"Storage"===i.reactionState))return r})}else s=_.filter(i.orders,e=>{if("energy"===e.type||"Storage"===i.reactionState)return e});i.orders.length>s.length&&(this.memory.resources.lab[o].orders=s,Log.room(this.name,`lab orders fixed in ${this.name}, ${i.id}`))}}}},checkOffers:{value(){if(Memory.boostTiming.multiOrderingRoomName===this)return Log.room(this.name,`${this.name} early roomCheck, multiOrdering in progress`),!0;const e=this.memory.resources,t=e.orders;let r,o=[],i=!1;for(let e of t)if(e.offers.length>0)for(let t of e.offers){if(!_.some(o,e=>e.room===t.room)){(r=Game.rooms[t.room].GCOffers()).terminalOrderPlaced&&(i=!0),r.readyOffersFound>0&&o.push({room:t.room,readyOffers:r.readyOffersFound})}}if(1!==o.length||1!==o[0].readyOffers||!_.isUndefined(e.boostTiming.ordersReady))return(o.length>=1||1===o.length&&o[0].readyOffers>1)&&_.isUndefined(e.boostTiming.ordersReady)?(Log.room(this.name,`${this.name} has more than one offers ready, boostTiming.ordersReady created`),Log.stringify(o),e.boostTiming.ordersReady={time:Game.time,orderCandidates:o},Memory.boostTiming||(Memory.boostTiming={}),Memory.boostTiming.multiOrderingRoomName=this.name,e.boostTiming.checkRoomAt=Game.time+_.sum(o,"readyOffers")+1,!0):r.terminalOrderPlaced?(Log.room(this.name,`terminal orders placed for room ${this.name}`),e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,!1):(Log.room(this.name,`${this.name} no readyOffers found`),e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,!1);{let t=Game.rooms[o[0].room];Log.room(this.name,`${o[0].room} there is only one offersReady for ${this.name}, running fillARoomOrder()`);let r=!1;if(0!==t.terminal.cooldown)return e.boostTiming.checkRoomAt=Game.time+t.terminal.cooldown+1,Log.room(t.name,`${t.name} terminal cooldown is: ${t.terminal.cooldown}`),Log.room(this.name,`${this.name} time: ${Game.time}, boosTiming:`),Log.stringify(e.boostTiming),!1;if(!0===(r=t.fillARoomOrder())&&0===e.orders.length||0===_.sum(e.orders,"amount"))return e.boostTiming.checkRoomAt=Game.time+1,Log.room(t.name,`${t.name} terminal send was successful. And there are no more orders`),Log.room(this.name,`${this.name} time: ${Game.time} boostTiming:`),Log.stringify(e.boostTiming),!0;if(!0===r)return e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,Log.room(t.name,`${t.name} terminal send was successful. BTW, there are orders remained to fulfill`),Log.room(this.name,`${this.name} time: ${Game.time}, boostTiming:`),Log.stringify(e.boostTiming),!0}}},ordersWithOffers:{value(){const e=this.memory.resources.orders;return 0!==e.length&&_.some(e,e=>{return(_.sum(e.offers,"amount")||0)>=e.amount&&e.amount>0})}},makeReaction:{value(){let e,t={};const r=(e,t,r)=>{let o=Game.rooms[e];if(!o.memory.labs)return!1;if(o.memory.labs.length<3)return!1;if(3===o.memory.labs.length&&!MAKE_REACTIONS_WITH_3LABS)return!1;if(_.isUndefined(o.memory.resources))return!1;if(_.isUndefined(o.memory.resources.reactions))return!1;const i=o.memory.resources.reactions,s=((e,t)=>{if(1===e.length&&"G"!==e)return;const r=(e,t)=>{const r=(e=>{const t=_.filter(Game.rooms,{my:!0});let r=0;for(let o of t){let t=o.resourcesAll[e]||0;t>=MIN_OFFER_AMOUNT&&(r+=t)}return r})(e),i=o.resourcesAll[e]||0;let s;return r-i<TRADE_THRESHOLD?(s=t-i)<0?s=0:s<MIN_COMPOUND_AMOUNT_TO_MAKE&&(s=MIN_COMPOUND_AMOUNT_TO_MAKE):(s=t-r)<0?s=0:s<MIN_COMPOUND_AMOUNT_TO_MAKE&&(s=MIN_COMPOUND_AMOUNT_TO_MAKE),Util.roundUpTo(s,MIN_OFFER_AMOUNT)},i=(e,t)=>{let o={},i={};return o[e]=((e,t)=>{const o=LAB_REACTIONS[e][0],i=LAB_REACTIONS[e][1];return{[o]:r(o,t),[i]:r(i,t)}})(e,t),Object.keys(o).forEach(e=>{Object.keys(o[e]).forEach(t=>{(t.length>1||"G"===t)&&(i[t]=o[e][t])})}),{product:o,slice:(e=>0!==Object.keys(e).length&&e)(i)}};let s=i(e,t),a=s.product,n=s.slice;do{let e=[];Object.keys(n).forEach(t=>{s=i(t,n[t]),a[t]=s.product[t],e.push(s.slice)}),n={};for(let t of e)n=Object.assign(n,t)}while(_.some(n,Object));return a})(t,r);let a,n=!1,l=!1,m=[];return o.storage&&o.terminal?_.isUndefined(o.memory.labs)||0===o.memory.labs.length?(Log.warn(`there are no labs in ${o.name}`),!1):!1!==o.terminal.isActive()&&!1!==o.storage.isActive()&&!1!==Game.getObjectById(o.memory.labs[0].id).isActive()&&(Object.keys(s).forEach(t=>{Object.keys(s[t]).forEach(r=>{let a=s[t][r];if(a>0&&!n){if(1===r.length&&"G"!==r&&(o.resourcesAll[r]||0)<a&&!n&&!(n=((e,t,r)=>{if(!PURCHASE_MINERALS)return Log.error(`${e} needs to buy ${r} ${t} but PURCHASE_MINERALS is false`),!1;if(o.storage.charge<STORE_CHARGE_PURCHASE)return Log.warn(`storage.charge in ${e} is ${o.storage.charge}, purchase for ${t} is delayed`),!1;if(o.terminal.cooldown>0)return Log.warn(`terminal.coolDown in ${e} is ${o.terminal.cooldown}, purchase for ${t} is delayed`),!1;if("idle"!==i.reactorMode)return!1;let s,a,n;Log.success(`buying ${r} ${t} in ${e}`),AUTOMATED_RATIO_COUNT?(s=Util.countPrices("sell",t,e),Log.info(`average sellRatio: ${e} ${t} ${s}`)):s=MAX_BUY_RATIO[t];const l=Game.market.getAllOrders(o=>{const i=Game.rooms[e];let a,n;return"sell"===o.type&&o.resourceType===t&&(o.transactionAmount=Math.min(o.amount,r),!((a=Game.market.calcTransactionCost(o.transactionAmount,o.roomName,e))>i.terminal.store[RESOURCE_ENERGY]||(n=o.transactionAmount*o.price,Game.market.credits<n&&(o.transactionAmount=Game.market.credits/o.price,0===o.transactionAmount)||(o.ratio=(n-a*ENERGY_VALUE_CREDITS)/o.transactionAmount,o.ratio>s||o.amount<100))))});return l.length>0?(a=_.min(l,"ratio"),Log.info("selected order: "),Log.table(a),a&&Log.info(`Game.market.deal("${a.id}", ${a.transactionAmount}, "${e}");`),(n=Game.market.deal(a.id,a.transactionAmount,e))===OK?(Log.success(`Purchased ${a.transactionAmount} ${t} at price: ${a.price} it costs: ${a.transactionAmount*a.price}`),!0):(Log.error(`purchase was FAILED error code: ${Util.translateErrorCode(n)}`),Log.error(n),!1)):(0===s?Log.warn(`There are no sellOrders for ${t}`):(Log.warn(`No sell order found for ${r} ${t} at ratio ${MAX_BUY_RATIO[t]} in room ${e}`),Log.warn(`You need to adjust MAX_BUY_RATIO or use AUTOMATED_RATIO_COUNT: true in parameters, current is: ${MAX_BUY_RATIO[t]}, recommended: ${s}`)),!1)})(e,r,a)))return{ingredientMade:l,mineralPurchased:n};n||(r.length>1||"G"===r)&&m.push({compound:r,amount:a})}})}),0===m.length&&m.push({compound:t,amount:r}),n||(a=m[m.length-1],l=((e,t,r)=>{if(_.isUndefined(i))return Log.warn(`labs in room ${e} are not registered as flower`),!1;if("flower"!==i.reactorType)return Log.warn(`labs in room ${e} are not registered as flower`),!1;const o=Game.rooms[e];let s=!1;"idle"===i.reactorMode&&(Log.room(e,`${o.name} - placeReactionOrder(${t}, ${t}, ${r})`),o.GCLabs(),o.placeReactionOrder(t,t,r),Memory.boostTiming.roomTrading.boostProduction=!0,Memory.boostTiming.timeStamp=Game.time,Log.room(o,`${o.name}, placeReaction ${r} ${t} at time: ${Game.time}`),o.memory.resources.boostTiming.roomState="reactionPlaced",s=!0);return s})(e,a.compound,a.amount)),{ingredientMade:l,mineralPurchased:n}):(Log.warn(`there are no storage/terminal in ${o.name}`),!1)};return Object.keys(COMPOUNDS_TO_MAKE).forEach(o=>{if(COMPOUNDS_TO_MAKE[o].make&&!t.ingredientMade&&(this.name.indexOf(COMPOUNDS_TO_MAKE[o].rooms)>-1||0===COMPOUNDS_TO_MAKE[o].rooms.length)){let i=this.resourcesAll[o]||0;0===i?(e=Util.roundUpTo(COMPOUNDS_TO_MAKE[o].amount+COMPOUNDS_TO_MAKE[o].threshold,MIN_OFFER_AMOUNT),(t=r(this.name,o,e)).ingredientMade&&Log.room(this.name,`there is no ${o}, so start to make the compounds for ${COMPOUNDS_TO_MAKE[o].amount} ${o} in ${this.name}`)):i<=COMPOUNDS_TO_MAKE[o].threshold&&(e=Util.roundUpTo(COMPOUNDS_TO_MAKE[o].amount+COMPOUNDS_TO_MAKE[o].threshold-i,MIN_OFFER_AMOUNT),(t=r(this.name,o,e)).ingredientMade&&Log.room(this.name,`it is below the threshold, so start to make the compounds for ${e} ${o} in ${this.name}`))}}),t.ingredientMade||t.mineralPurchased}},storedMinerals:{value(e){let t=(this.resourcesStorage[e]||0)+(this.resourcesTerminal[e]||0)-(this.resourcesOffers[e]||0)-(this.resourcesReactions[e]||0);return t<0&&(t=0),t}},countCheckRoomAt:{value(){const e=this.memory.resources,t=e.boostTiming,r=e.lab.length,o=REACTION_TIME[e.reactions.orders[0].type],i=LAB_REACTION_AMOUNT*(r-_.filter(e.lab,e=>"Storage"===e.reactionState).length-2)/o,s=e.reactions.orders[0].amount;t.checkRoomAt=t.reactionMaking+Util.roundUpTo(s/i,o)+o}},getSeedLabOrders:{value(){let e=this.memory.resources;if(_.isUndefined(e)||_.isUndefined(e.reactions)||0===e.reactions.orders.length)return;const t=e.reactions.orders[0].type,r=LAB_REACTIONS[t][0],o=LAB_REACTIONS[t][1],i=e.lab.findIndex(t=>t.id===e.reactions.seed_a),s=e.lab.findIndex(t=>t.id===e.reactions.seed_b),a=_.filter(e.lab[i].orders,e=>e.type===r),n=_.filter(e.lab[s].orders,e=>e.type===o);return{labOrderAmountA:a[0].orderRemaining,labOrderAmountB:n[0].orderRemaining}}},newFlag:{value:(e,t,r)=>(t||(t=this.getPositionAt(25,25)),t.newFlag(e,r))}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.RoomStructures=class{constructor(e){this.extend=(()=>{Object.defineProperties(this,{all:{get(){return _.isUndefined(this._all)&&(this._all=this.room.find(FIND_STRUCTURES)),this._all}},my:{get(){return _.isUndefined(this._my)&&(this._my=this.room.find(FIND_MY_STRUCTURES)),this._my}},towers:{get(){if(_.isUndefined(this._towers)){this._towers=[];let e=e=>{Util.addById(this._towers,e)};_.forEach(this.room.memory.towers,e)}return this._towers}},repairable:{get(){return _.isUndefined(this._repairable)&&(this._repairable=_.sortBy(this.all.filter(e=>Room.shouldRepair(this.room,e)),"hits")),this._repairable}},urgentRepairable:{get(){if(_.isUndefined(this._urgentRepairableSites)){const e=e=>e.hits<LIMIT_URGENT_REPAIRING+(DECAY_AMOUNT[e.structureType]||0);this._urgentRepairableSites=_.filter(this.repairable,e)}return this._urgentRepairableSites}},feedable:{get(){return _.isUndefined(this._feedable)&&(this._feedable=this.extensions.concat(this.spawns)),this._feedable}},fortifyable:{get(){return _.isUndefined(this._fortifyableSites)&&(this._fortifyableSites=_.sortBy(this.all.filter(e=>this.room.my&&e.hits<e.hitsMax&&e.hits<MAX_FORTIFY_LIMIT[this.room.RCL]&&(e.structureType!=STRUCTURE_CONTAINER||e.hits<MAX_FORTIFY_CONTAINER)&&(!DECAYABLES.includes(e.structureType)||e.hitsMax-e.hits>3*GAP_REPAIR_DECAYABLE)&&(void 0===Memory.pavementArt[this.room.name]||Memory.pavementArt[this.room.name].indexOf("x"+e.pos.x+"y"+e.pos.y+"x")<0)&&!Flag.list.some(t=>t.roomName==e.pos.roomName&&t.color==COLOR_ORANGE&&t.x==e.pos.x&&t.y==e.pos.y)),"hits")),this._fortifyableSites}},fuelable:{get(){if(_.isUndefined(this._fuelables)){let e=this.room.situation.invasion?1:.82,t=t=>t.energy<t.energyCapacity*e;this._fuelables=_.sortBy(_.filter(this.towers,t),"energy")}return this._fuelables}},container:{get(){return _.isUndefined(this._container)&&(this._container=new Room.Containers(this.room)),this._container}},links:{get(){return _.isUndefined(this._links)&&(this._links=new Room.Links(this.room)),this._links}},labs:{get(){return _.isUndefined(this._labs)&&(this._labs=new Room.Labs(this.room)),this._labs}},virtual:{get(){return _.isUndefined(this._virtual)&&(this._virtual=_(this.all).concat(this.piles)),this._virtual}},piles:{get(){if(_.isUndefined(this._piles)){const e=this.room;this._piles=Flag.filter(FLAG_COLOR.command.drop,e.getPositionAt(25,25),!0).map(function(t){const r=Game.flags[t.name],o=e.lookForAt(LOOK_ENERGY,r.pos.x,r.pos.y);return o.length&&o[0]||r})}return this._piles}},observer:{get(){return _.isUndefined(this._observer)&&this.room.memory.observer&&(this._observer=Game.getObjectById(this.room.memory.observer.id)),this._observer}},nuker:{get(){return _.isUndefined(this._nuker)&&this.room.memory.nukers&&this.room.memory.nukers.length>0&&(this._nuker=Game.getObjectById(this.room.memory.nukers[0].id)),this._nuker}},nukers:{get(){return _.isUndefined(this._nukers)&&(this._nukers=new Room.Nuker(this.room)),this._nukers}},powerSpawn:{get(){return _.isUndefined(this._powerSpawn)&&this.room.memory.powerSpawns&&this.room.memory.powerSpawns.length>0&&(this._powerSpawn=Game.getObjectById(this.room.memory.powerSpawns[0].id)),this._powerSpawn}},powerSpawns:{get(){return _.isUndefined(this._powerSpawns)&&(this._powerSpawns=new Room.PowerSpawn(this.room)),this._powerSpawns}},extensions:{get(){return _.isUndefined(this.room.memory.extensions)&&this.room.saveExtensions(),_.isUndefined(this._extensions)&&(this._extensions=_.map(this.room.memory.extensions,e=>Game.getObjectById(e))),this._extensions}},spawns:{get(){if(_.isUndefined(this._spawns)){this._spawns=[];let e=e=>{Util.addById(this._spawns,e)};_.forEach(this.room.memory.spawns,e)}return this._spawns}}})}),this.room=e,this.extend()}}},function(e,t){Object.defineProperties(RoomPosition.prototype,{adjacent:{get(){if(_.isUndefined(this._adjacent)){this._adjacent=[];for(let e=this.x-1;e<this.x+2;e++)for(let t=this.y-1;t<this.y+2;t++)e>0&&e<49&&t>0&&t<49&&this._adjacent.push(new RoomPosition(e,t,this.roomName))}return this._adjacent}},radius:{value(e=1){if(1===e)return this.adjacent;if(e<1)return[this];const t=[];for(let r=this.x-e;r<=this.x+e;r++)for(let o=this.y-e;o<=this.y+e;o++){const e=new RoomPosition(r,o,this.roomName);r<50&&r>0&&o>0&&o<50&&!_.isEqual(this,e)&&t.push(e)}return t}},findClosestByPathFinder:{value(e,t=_.identity){let r=_.map(e,t);if(_.isEmpty(r))return{goal:null};let o=PathFinder.search(this,r,{maxOps:16e3,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}}),i=_.last(o.path);void 0==i&&(i=this);let s=_.min(e,e=>i.getRangeTo(e.pos));return{goal:Math.abs(s)!==1/0?s:null,cost:o.cost,ops:o.ops,incomplete:o.incomplete}}},findClosestSpawn:{value(){return this.findClosestByPathFinder(Game.spawns,e=>({pos:e.pos,range:1})).goal}},newFlag:{value(e,t){if(e||(e=_.get(FLAG_COLOR,e)),e)return this.createFlag(t,e.color,e.secondaryColor)}}})},function(e,t){Object.defineProperties(RoomObject.prototype,{accessibleFields:{get(){if(this.memory&&!_.isUndefined(this.memory.accessibleFields))return this.memory.accessibleFields;{let e=this.room.lookForAtArea(LOOK_TERRAIN,this.pos.y-1,this.pos.x-1,this.pos.y+1,this.pos.x+1,!0),t=_.countBy(e,"terrain").wall,r=void 0===t?9:9-t;return this.memory?this.memory.accessibleFields=r:r}}},cloak:{get(){const e=Memory.cloaked[this.id];return!!e&&(_.isNumber(e)&&Game.time>e?(delete Memory.cloaked[this.id],!1):e)},set(e){if(e)return _.isNumber(e)?e<Game.time&&(e=Game.time+e):e=!0,Memory.cloaked[this.id]=e;delete Memory.cloaked[this.id]}}})},function(e,t){Object.defineProperties(Source.prototype,{memory:{get(){if(_.isUndefined(Memory.sources)&&(Memory.sources={}),_.isObject(Memory.sources))return Memory.sources[this.id]=Memory.sources[this.id]||{}},set(e){if(_.isUndefined(Memory.sources)&&(Memory.sources={}),!_.isObject(Memory.sources))throw new Error("Could not set memory extension for sources");Memory.sources[this.id]=e}},container:{get(){return _.isUndefined(this.memory.container)&&this.room.saveContainers(),_.isUndefined(this._container)&&(this.memory.storage?(this._container=Game.getObjectById(this.memory.storage),this._container||delete this.memory.storage):this.memory.terminal?(this._container=Game.getObjectById(this.memory.terminal),this._container||delete this.memory.terminal):this.memory.container?(this._container=Game.getObjectById(this.memory.container),this._container||delete this.memory.container):this._container=null),this._container}},link:{get(){return _.isUndefined(this._link)&&(this.memory.link?(this._link=Game.getObjectById(this.memory.link),this._link||delete this.memory.link):this._link=null),this._link}}}),Object.defineProperties(Mineral.prototype,{memory:{get(){if(_.isUndefined(Memory.minerals)&&(Memory.minerals={}),_.isObject(Memory.minerals))return Memory.minerals[this.id]=Memory.minerals[this.id]||{}},set(e){if(_.isUndefined(Memory.minerals)&&(Memory.minerals={}),!_.isObject(Memory.minerals))throw new Error("Could not set memory extension for minerals");Memory.minerals[this.id]=e}},container:{get(){return _.isUndefined(this.memory.container)&&this.room.saveContainers(),_.isUndefined(this._container)&&(this.memory.terminal?(this._container=Game.getObjectById(this.memory.terminal),this._container||delete this.memory.terminal):this.memory.storage?(this._container=Game.getObjectById(this.memory.storage),this._container||delete this.memory.storage):this.memory.container?(this._container=Game.getObjectById(this.memory.container),this._container||delete this.memory.container):this._container=null),this._container}}})},function(e,t){Object.defineProperties(Structure.prototype,{towers:{get(){return(_.isUndefined(this._towers)||this._towersSet!==Game.time)&&(this._towersSet=Game.time,this._towers=[]),this._towers},set(e){this._towers=e}},active:{get(){return this.room.controller?!!this.room.owner&&(this.room.owner===this.owner.username&&_.get(this.room.memory,["structures",this.id,"active"],!0)):_.get(this.room.memory,["structures",this.id,"active"],!0)}}})},function(e,t){Object.defineProperties(StructureContainer.prototype,{active:{value:!0},sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!=Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.store)),this._sum}},getNeeds:{value(e){if(!this.room.memory.resources)return 0;let t=this.room.memory.resources.container.find(e=>e.id==this.id);if(t){let r=t.orders.find(t=>t.type==e);if(r){let t=Math.max(r.orderRemaining+(this.store[e]||0),r.storeAmount),o=r.orderAmount+r.storeAmount;o<0&&(o=0);let i=this.store[e]||0;if(i<t)return Math.min(t-i,this.storeCapacity-this.sum);if(i>1.05*o)return o-i}}return 0}}})},function(e,t){Object.defineProperties(StructureController.prototype,{memory:{get(){if(_.isUndefined(Memory.controllers)&&(Memory.controllers={}),_.isObject(Memory.controllers))return Memory.controllers[this.id]=Memory.controllers[this.id]||{}},set(e){if(_.isUndefined(Memory.controllers)&&(Memory.controllers={}),!_.isObject(Memory.controllers))throw new Error("Could not set memory extension for controller");Memory.controllers[this.id]=e}}})},function(e,t){Object.defineProperties(StructureLab.prototype,{active:{get(){return!!this.room.owner&&(this.room.owner===this.owner.username&&(!(this.room.RCL<6)&&_.get(this.room.memory,["structures",this.id,"active"],!0)))}},getNeeds:{value(e){if(!this.room.memory.resources)return 0;let t=0,r=0,o=this.room.memory.resources.reactions,i=this.room.memory.resources.lab.find(e=>e.id===this.id);if(i){let o=i.orders.find(t=>t.type===e);if(o){let i=0;e===RESOURCE_ENERGY?i=this.energy:e===this.mineralType&&(i=this.mineralAmount),t=Math.max(o.orderRemaining+i,o.storeAmount),(r=o.orderAmount+o.storeAmount)<0&&(r=0)}}let s=0,a=0,n=0;if(e===RESOURCE_ENERGY?(s=this.energy,a=this.energyCapacity-this.energy,n=this.energyCapacity):(this.mineralType===e&&(s=this.mineralAmount),a=this.mineralCapacity-this.mineralAmount,n=this.mineralCapacity),i&&o&&o.orders.length>0&&(this.id===o.seed_a||this.id===o.seed_b)&&(e!==LAB_REACTIONS[o.orders[0].type][0]||e!==LAB_REACTIONS[o.orders[0].type][1])&&s>r)return r-s;if(s<Math.min(t,n)/2)return Math.min(t-s,a);if(i&&i.reactionType===this.mineralType){if(s>r+(n-Math.min(r,n))/2)return r-s}else if(s>r)return r-s;return 0}}})},function(e,t){Object.defineProperties(StructureNuker.prototype,{getNeeds:{value(e){if(!this.room.isCriticallyFortifyable)return e==RESOURCE_ENERGY&&this.energy<this.energyCapacity?this.energyCapacity-this.energy:e==RESOURCE_GHODIUM&&this.ghodium<this.ghodiumCapacity?this.ghodiumCapacity-this.ghodium:0;if(!this.room.memory.resources||!this.room.memory.resources.nuker)return 0;let t=0,r=0,o=this.room.memory.resources.nuker.find(e=>e.id==this.id);if(o){let i=o.orders.find(t=>t.type==e);if(i){let o=0;e==RESOURCE_ENERGY?o=this.energy:e==RESOURCE_GHODIUM&&(o=this.ghodium),t=Math.max(i.orderRemaining+o,i.storeAmount),(r=i.orderAmount+i.storeAmount)<0&&(r=0)}}let i=0,s=0;return e==RESOURCE_ENERGY?(i=this.energy,s=this.energyCapacity-this.energy):e==RESOURCE_GHODIUM&&(i=this.ghodium,s=this.ghodiumCapacity-this.ghodium),i<t?Math.min(t-i,s):i>1.05*r?r-i:0}}})},function(e,t){Object.defineProperties(StructurePowerSpawn.prototype,{getNeeds:{value(e){if(FILL_POWERSPAWN&&!this.room.isCriticallyFortifyable)return e===RESOURCE_ENERGY&&this.energy<.75*this.energyCapacity?this.energyCapacity-this.energy:e===RESOURCE_POWER&&this.power<.25*this.powerCapacity?this.powerCapacity-this.power:0;if(!this.room.memory.resources||!this.room.memory.resources.powerSpawn)return 0;let t=0,r=0,o=this.room.memory.resources.powerSpawn.find(e=>e.id===this.id);if(o){let i=o.orders.find(t=>t.type===e);if(i){let o=0;e===RESOURCE_ENERGY?o=this.energy:e===RESOURCE_POWER&&(o=this.power),t=Math.max(i.orderRemaining+o,i.storeAmount),(r=i.orderAmount+i.storeAmount)<0&&(r=0)}}let i=0,s=0;return e===RESOURCE_ENERGY?(i=this.energy,s=this.energyCapacity-this.energy):e===RESOURCE_POWER&&(i=this.power,s=this.powerCapacity-this.power),i<t?Math.min(t-i,s):i>1.05*r?r-i:0}}})},function(e,t){Object.defineProperties(StructureRampart.prototype,{active:{get(){return this.room.RCL>1}},isCriticallyFortifyable:{get(){return this.hits<=MIN_FORTIFY_LIMIT[this.room.RCL]}}})},function(e,t){Object.defineProperties(StructureRoad.prototype,{active:{value:!0}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);Object.defineProperties(StructureSpawn.prototype,{run:{value(){if(this.spawning)return;let e=this.room;const t=t=>t.isValidSetup(e)&&this.createCreepBySetup(t),r=Util.get(this.room.memory,"spawnDelay",{});let o=this.createCreepByQueue(e.spawnQueueHigh,"High");return o||0!==e.spawnQueueHigh.length&&e.spawnQueueHigh.length!==r.High||Game.time%SPAWN_INTERVAL!=0||((o=_.some(StructureSpawn.priorityHigh,t))||(o=this.createCreepByQueue(e.spawnQueueMedium,"Medium")),o||0!==e.spawnQueueMedium.length&&e.spawnQueueMedium.length!==r.Medium||(o=_.some(StructureSpawn.priorityLow,t))||(o=this.createCreepByQueue(e.spawnQueueLow,"Low"))),o}},createCreepBySetup:{value(e){LOG_TRACE&&Log.trace("Spawn",{setupType:this.type,rcl:this.room.RCL,energy:this.room.energyAvailable,maxEnergy:this.room.energyCapacityAvailable,Spawn:"createCreepBySetup"},"creating creep");const t=e.buildParams(this);return this.create(t.parts,t.name,t.setup)?t:null}},createCreepByQueue:{value(e,t){const r=Util.get(this.room.memory,"spawnDelay",{});if(!e)return null;if(Memory.CPU_CRITICAL&&r[t]===e.length)return null;let o;for(const t in e){const r=e[t];Memory.CPU_CRITICAL&&!CRITICAL_ROLES.includes(r.behaviour)||(o=e.splice(t,1)[0])}if(!o)return e.length&&Log.module(this.pos.roomName,"No non-CRITICAL creeps to spawn, delaying spawn until CPU is not CRITICAL, or new entries are added."),r[t]=e.length,null;delete r[t];let i,s=0;if(o.parts.forEach(e=>{s+=BODYPART_COST[e]}),0===s)return Log.error(`[${this.pos.roomName}]`,"Zero parts body creep queued. Removed."),!1;if(s>this.room.remainingEnergyAvailable)return s>this.room.energyCapacityAvailable||s>300&&!this.room.creeps.length?(Log.error(`[${this.pos.roomName}]`,"Queued creep too big for room: "+JSON.stringify(o)),!1):(e.unshift(o),!0);let a=o.name;for(let e=1;null==i||Game.creeps[i]||Memory.population[i];e++)i=o.name+"-"+e;o.name=i;let n=this.create(o.parts,o.name,o.behaviour||o.setup,o.destiny);return n||(o.name=a,e.unshift(o)),n}},create:{value(e,t,r,i){if(0==e.length)return!1;let s=this.createCreep(e,t,null);if(t==s||void 0===Util.translateErrorCode(s)){let t=0;return e.forEach(function(e){t+=BODYPART_COST[e]}),this.room.reservedSpawnEnergy+=t,Population.registerCreep(s,r,t,this.room,this.name,e,i),this.newSpawn={name:s},Creep.spawningStarted.trigger({spawn:this.name,name:s,body:e,destiny:i,spawnTime:e.length*CREEP_SPAWN_TIME}),CENSUS_ANNOUNCEMENTS&&Log.room(this.pos.roomName,Dye(COLOR_YELLOW,o.Emoji.baby,"Spawning "+s+"!")),!0}return CENSUS_ANNOUNCEMENTS&&Log.error(`[${this.pos.roomName}]`,"Offspring failed: "+Util.translateErrorCode(s)+"<br/> - body: "+JSON.stringify(_.countBy(e))+"<br/> - name: "+t+"<br/> - behaviour: "+r+"<br/> - destiny: "+i),!1}}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.dateUtils={toLocalDate(e){e||(e=new Date);let t=TIME_ZONE;return USE_SUMMERTIME&&Util.isSummerTime(e)&&t++,new Date(e.getTime()+36e5*t)},toDateTimeString(e){const t=Util.pad;return t(e.getFullYear(),0,4)+"-"+t(e.getMonth()+1)+"-"+t(e.getDate())+" "+Util.toTimeString(e)},toTimeString(e){const t=Util.pad;return t(e.getHours())+":"+t(e.getMinutes())+":"+t(e.getSeconds())},isSummerTime:e=>(Reflect.has(Date.prototype,"stdTimezoneOffset")||Object.defineProperty(Date.prototype,"stdTimezoneOffset",{value(){const e=new Date(this.getFullYear(),0,1),t=new Date(this.getFullYear(),6,1);return Math.max(e.getTimezoneOffset(),t.getTimezoneOffset())}}),Reflect.has(Date.prototype,"dst")||Object.defineProperty(Date.prototype,"dst",{get(){return this.getTimezoneOffset()<this.stdTimezoneOffset()}}),e.dst)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(9);t.logUtils={translateErrorCode:e=>o.ErrorType[e],css(e){let t="";return _.forEach(e,(e,r)=>{t+=`${_.kebabCase(r)}: ${e};`}),t},jsonToTable(e){let t="";const r=Util.css({background:"rgba(0,0,0,.25)",border:"1px solid rgba(0,0,0,.5)"}),o=Util.css({padding:"2px 5px"});return _.forEach(e,(e,r)=>{const i=Dye(COLOR_GREEN,r)+Dye(COLOR_RED,":");let s="";_.isNumber(e)?(-1!==e.toString().indexOf(".")&&(e=e.toFixed(3)),s=Dye(COLOR_PURPLE,e)):_.isObject(e)||_.isArray(e)?(e=JSON.stringify(e).replace(/(\{|\}|\[|\]|,)/g,(e,t)=>Dye(COLOR_GREY,t)),s=Dye(COLOR_YELLOW,e)):s=Dye(COLOR_YELLOW,e),t+=`<tr><td style="${o}">${i}</td><td style="${o}">${s}</td></tr>`}),`<table style="${r}"><tbody>${t}</tbody></table>`}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.roomUtils={setRoomCenter(e,t,r){Memory.rooms[e].center={x:t,y:r}},getVisibleRooms(e){const t=Game.time-(e||5),r=[];for(const e in Memory.rooms){const o=Memory.rooms[e];o.lastViewed&&o.lastViewed>t&&r.push(e)}return r},getDistance:(e,t)=>Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),routeRange:(e,t)=>e===t?0:Util.get(Memory,`routeRange.${e}.${t}`,()=>{const r=e instanceof Room?e:Game.rooms[e];if(!r)return Room.roomDistance(e,t,!1);const o=r.findRoute(t,!1,!1);return o?o===ERR_NO_PATH?1/0:o.length:Room.roomDistance(e,t,!1)}),pave(e){const t=_.values(Game.flags).filter(t=>t.pos.roomName===e&&t.compareTo(FLAG_COLOR.pavementArt)),r=void 0===Memory.pavementArt[e]?"":Memory.pavementArt[e];Memory.pavementArt[e]=r+t.map(e=>`x${e.pos.x}y${e.pos.y}`).join("")+"x";t.forEach(e=>e.pos.createConstructionSite(STRUCTURE_WALL));t.forEach(e=>e.remove())},unpave(e){if(!Memory.pavementArt||!Memory.pavementArt[e])return!1;const t=Game.rooms[e];if(!t)return!1;const r=t.structures.all.filter(t=>Memory.pavementArt[e].indexOf(`x${t.pos.x}y${t.pos.y}x`)>=0);return r&&r.forEach(e=>e.destroy()),delete Memory.pavementArt[e],!0},getRoomLayout(e,t){const r=[],o=Game.rooms[e.roomName];if(!o)return;const i=e.x,s=e.y;_(o.find(FIND_STRUCTURES)).reject(e=>e instanceof StructureController).filter(e=>e.pos.x>=i&&e.pos.y>=s).filter(e=>!t||t(e)).value().forEach(e=>_.set(r,[e.pos.x-i,e.pos.y-s],e.structureType));const a={null:"",'"extension"':"STRUCTURE_EXTENSION",'"road"':"STRUCTURE_ROAD",'"tower"':"STRUCTURE_TOWER",'"spawn"':"STRUCTURE_SPAWN",'"link"':"STRUCTURE_LINK",'"storage"':"STRUCTURE_STORAGE",'"terminal"':"STRUCTURE_TERMINAL",'"nuker"':"STRUCTURE_NUKER",'"powerSpawn"':"STRUCTURE_POWER_SPAWN",'"observer"':"STRUCTURE_OBSERVER",'"rampart"':"STRUCTURE_RAMPART",'"lab"':"STRUCTURE_LAB"},n=new RegExp(Object.keys(a).join("|"),"g");return JSON.stringify(r).replace(n,e=>a[e])},makeRoomUrl:e=>'<a href="#!/room/'+Game.shard.name+"/"+e+'">'+e+"</a>",makeFlagUrl:e=>'<a href="#!/room/'+Game.shard.name+"/"+Memory.flags[e].roomName+'">'+e+"</a>"}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.marketUtils={countPrices(e,t,r){let o=(e,t,r,o)=>Game.market.getAllOrders(i=>{let s,a;return!(i.type!==e||i.resourceType!==t||i.amount<r)&&(!((s=Game.market.calcTransactionCost(r,i.roomName,o))>Game.rooms[o].terminal.store[RESOURCE_ENERGY])&&(a=r*i.price,i.transactionAmount=Math.min(i.amount,r),i.ratio=(a-s*ENERGY_VALUE_CREDITS)/i.transactionAmount,!0))});switch(Array.prototype.sum=function(){return this.reduce((e,t)=>e+Number(t),0)},Array.prototype.average=function(){return this.sum()/(this.length||1)},e){case ORDER_BUY:const i=o(ORDER_BUY,t,MIN_MINERAL_SELL_AMOUNT,r),s=_.min(i,"ratio"),a=_.filter(i,e=>e.id!==s.id);let n,l=[];for(let e of a)l.push(e.ratio);return n=Util.roundUp(l.average(),4);case ORDER_SELL:const m=o(ORDER_SELL,t,TRADE_THRESHOLD,r),c=_.max(m,"ratio"),u=_.filter(m,e=>e.id!==c.id);let d,h=[];for(let e of u)h.push(e.ratio);return d=Util.roundUp(h.average(),4)}},sumCompoundType:(e,t="amount")=>_(e).flatten().groupBy("type").transform((e,r,o)=>e[o]=_.sum(r,t)).value(),roundUp:(e,t=0)=>(t=Math.pow(10,t),Math.ceil(e*t)/t),roundUpTo:(e,t)=>(e%t!=0&&(e=e+t-e%t),e),orderingRoom(){let e=_.filter(Game.rooms,{my:!0});return _.filter(e,e=>{let t=e.memory.resources;return!_.isUndefined(t)&&!_.isUndefined(t.orders)&&(_.isUndefined(t.boostTiming)&&(t.boostTiming={}),t.orders.length>0&&_.sum(t.orders,"amount")>0)})}}},function(e,t){Object.defineProperties(StructureStorage.prototype,{sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!==Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.store)),this._sum}},charge:{get(){const e=this.room.RCL;return Util.chargeScale(this.store.energy,MIN_STORAGE_ENERGY[e],MAX_STORAGE_ENERGY[e])}},getNeeds:{value(e){let t=0;if(!this.room.memory.resources)return 0;const r=this.room.memory.resources.storage[0];let o=null;r&&(o=r.orders.find(t=>t.type===e)),o||(o={orderAmount:0,orderRemaining:0,storeAmount:0});const i=this.room.RCL,s=Math.max(o.orderRemaining+(this.store[e]||0),o.storeAmount+(e===RESOURCE_ENERGY?MIN_STORAGE_ENERGY[i]:MAX_STORAGE_MINERAL));let a=e===RESOURCE_ENERGY?this.storeCapacity-this.sum+this.store.energy:o.orderAmount+o.storeAmount+MAX_STORAGE_MINERAL;a<0&&(a=0);let n=this.store[e]||0;return n<s?t=Math.min(s-n,this.storeCapacity-this.sum):n>1.05*a&&(t=a-n),t}}})},function(e,t){Object.defineProperties(StructureTerminal.prototype,{sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!==Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.store)),this._sum}},charge:{get(){const e=this.getNeeds(RESOURCE_ENERGY),t=e?this.store[RESOURCE_ENERGY]+e:TERMINAL_ENERGY;return Util.chargeScale(this.store.energy,t,2*t)}},getNeeds:{value(e){let t=0;if(!this.room.memory.resources)return 0;const r=this.room.memory.resources.terminal[0];let o=null;r&&(o=r.orders.find(t=>t.type===e)),o||(o={orderAmount:0,orderRemaining:0,storeAmount:0});const i=Math.max(o.orderRemaining+(this.store[e]||0),o.storeAmount+(e===RESOURCE_ENERGY?TERMINAL_ENERGY:0));let s=o.orderAmount+o.storeAmount+(e===RESOURCE_ENERGY?TERMINAL_ENERGY:0);s<0&&(s=0);let a=this.store[e]||0;return a<i?t=Math.min(i-a,this.storeCapacity-this.sum):a>1.05*s&&(t=s-a),t}}})},function(e,t){Object.defineProperties(StructureTower.prototype,{active:{get(){return!!this.room.owner&&(this.room.owner===this.owner.username&&(!(this.room.RCL<3)&&_.get(this.room.memory,["structures",this.id,"active"],!0)))}}})},function(e,t){Object.defineProperties(StructureWall.prototype,{active:{get(){return this.room.RCL>1}},isCriticallyFortifyable:{get(){return this.hits<=MIN_FORTIFY_LIMIT[this.room.RCL]}}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(52);class i{constructor(){this.opts={maxOps:2e3,defaultStuckValue:TRAVELER_STUCK_TICKS,reportThreshold:TRAVELER_THRESHOLD,roomRange:TRAVELLING_BORDER_RANGE},this.findAllowedRooms=((e,t,r={})=>{if(_.defaults(r,{restrictDistance:10}),Game.map.getRoomLinearDistance(e,t)>r.restrictDistance)return;let o={[e]:!0,[t]:!0},i=Game.map.findRoute(e,t,{routeCallback:o=>{if(r.routeCallback){let e=r.routeCallback(o);if(void 0!==e)return e}if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;let i;if(r.preferHighway){if((i=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o))[1]%10==0||i[2]%10==0)return 1}if(!r.allowSK&&!Game.rooms[o]){i||(i=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o));let e=i[1]%10,t=i[2]%10;if(!(5===e&&5===t)&&e>=4&&e<=6&&t>=4&&t<=6)return 10}return!r.allowHostile&&this.getHostileRoom(o)&&o!==t&&o!==e?Number.POSITIVE_INFINITY:2.5}});if(!r.debug||_.isArray(i)){for(let e of i)o[e.room]=!0;return o.route=i,o}Log.error(`couldn't findRoute to ${t}`)}),this.findTravelPath=((e,t,r={})=>{_.defaults(r,{ignoreCreeps:!0,range:1,maxOps:this.opts.maxOps,obstacles:[]});const o=e.pos||e,s=t.pos||t;let a;(r.useFindRoute||void 0===r.useFindRoute&&Game.map.getRoomLinearDistance(o.roomName,s.roomName)>2)&&(a=this.findAllowedRooms(o.roomName,s.roomName,r));const n=PathFinder.search(o,{pos:s,range:r.range},{maxOps:r.maxOps,plainCost:r.ignoreRoads?1:2,roomCallback:t=>{if(r.roomCallback){let e=r.roomCallback(t,r.ignoreCreeps);if(void 0!==e)return e}if(a){if(!a[t])return!1}else if(this.getHostileRoom(t)&&!r.allowHostile&&t!==o.roomName&&t!==s.roomName)return!1;let n,l=Game.rooms[t];l?r.ignoreStructures?(n=new PathFinder.CostMatrix,r.ignoreCreeps||i.addCreepsToMatrix(l,n)):n=r.ignoreCreeps||t!==e.pos.roomName?this.getStructureMatrix(l,r):this.getCreepMatrix(l,r):n=this.getStructureMatrix(t,r);for(let e of r.obstacles)n.set(e.pos.x,e.pos.y,255);return n},swampCost:r.ignoreRoads?5:10});if(r.respectRamparts){const e=Game.rooms[o.roomName];if(e&&e.find(FIND_MY_STRUCTURES,{filter:{structureType:STRUCTURE_RAMPART}}).length)for(let e=0;e<n.path.length;e++)if(_.filter(n.path[e].lookFor(LOOK_STRUCTURES),{structureType:STRUCTURE_RAMPART}).length){n.path=n.path.slice(0,e+1);break}}return n.route=a&&a.route,n}),this.travelTo=((e,t,r={})=>{const o=e.pos,s=t.pos||t;this.registerHostileRoom(e.room),e.memory._travel||(e.memory._travel={stuck:0,tick:Game.time,cpu:0,count:0});let a=e.memory._travel;if(e.fatigue>0)return a.tick=Game.time,ERR_BUSY;if(!t)return ERR_INVALID_ARGS;let n=e.pos.getRangeTo(s);if(n<=r.range)return OK;if(n<=1)return 1!==n||r.range?OK:(r.returnData&&(r.returnData.nextPos=t.pos),e.move(e.pos.getDirectionTo(t)));let l=!0;if(a.prev){const t=e=>0===e.x||49===e.x||0===e.y||49===e.y,r=(e,r)=>t(e)&&t(r)&&e.roomName!==r.roomName&&(e.x===r.x||e.y===r.y);a.prev=i.initPosition(a.prev),o.inRangeTo(a.prev,0)||r(e.pos,a.prev)?(l=!1,a.stuck++):(e.room.recordMove(e),a.stuck=0)}if(a.stuck>=this.opts.defaultStuckValue&&!r.ignoreStuck&&(r.ignoreCreeps=!1,delete a.path),a.tick=Game.time,a.dest&&a.dest.x===s.x&&a.dest.y===s.y&&a.dest.roomName===s.roomName||delete a.path,!a.path){if(e.spawning)return ERR_BUSY;a.dest=s,a.prev=void 0;let t=Game.cpu.getUsed(),o=this.findTravelPath(e,s,r);if(a.cpu+=Game.cpu.getUsed()-t,a.count++,a.avg=_.round(a.cpu/a.count,2),a.count>25&&a.avg>r.reportThreshold&&r.debug&&Log.warn("[Traveler] heavy cpu use: ","<br>",Util.jsonToTable({creep:e.name,avg:a.cpu/a.count,total:_.round(a.cpu,2),from:e.pos,to:s})),o.incomplete){const t=o.route&&o.route.length;r.debug&&(0===r.range?Log.warn("[Traveler] incomplete path, destination may be blocked.","<br>",Util.jsonToTable({creep:e.name,from:e.pos,to:s})):Log.warn(`[Traveler] incomplete path . Route length ${t}.`,"<br>",Util.jsonToTable({creep:e.name,from:e.pos,to:s,range:r.range}))),t>1&&(o=this.findTravelPath(e,new RoomPosition(25,25,o.route[1].room),_.create(r,{range:this.opts.roomRange,useFindRoute:!1})),r.debug&&Log.info(`attempting path through next room using known route was ${o.incomplete?"not":""} successful`)),o.incomplete&&o.ops<2e3&&a.stuck<this.opts.defaultStuckValue&&(r.useFindRoute=!1,o=this.findTravelPath(e,s,r),r.debug&&Log.info(`attempting path without findRoute was ${o.incomplete?"not ":""}successful`))}a.path=i.serializePath(e.pos,o.path),a.stuck=0}if(!a.path||0===a.path.length)return ERR_NO_PATH;a.prev&&0===a.stuck&&(a.path=a.path.substr(1)),a.prev=e.pos;let m=parseInt(a.path[0],10);return r.returnData&&(r.returnData.nextPos=i.positionAtDirection(e.pos,m)),e.move(m)}),this.getStructureMatrix=((e,t)=>{if(t.getStructureMatrix)return t.getStructureMatrix(e);if(this.refreshMatrices(),!this.structureMatrixCache[e.name]){let t=new PathFinder.CostMatrix;this.structureMatrixCache[e.name]=i.addStructuresToMatrix(e,t,1)}return this.structureMatrixCache[e.name]}),this.getCreepMatrix=((e,t)=>t.getCreepMatrix?t.getCreepMatrix(e):(this.refreshMatrices(),this.creepMatrixCache[e.name]||(this.creepMatrixCache[e.name]=i.addCreepsToMatrix(e,this.getStructureMatrix(e,t).clone())),this.creepMatrixCache[e.name])),this.refreshMatrices=(()=>{Game.time!==this.currentTick&&(this.currentTick=Game.time,this.structureMatrixCache={},this.creepMatrixCache={})}),this.opts=_.defaults({maxOps:2e3,defaultStuckValue:3,reportThreshold:50,roomRange:22},this.opts),this.getHostileRoom=(e=>_.get(Memory,["rooms",e,"hostile"])),this.registerHostileRoom=(e=>e.registerIsHostile())}}i.initPosition=(e=>new RoomPosition(e.x,e.y,e.roomName)),i.addStructuresToMatrix=((e,t,r)=>{for(let o of e.find(FIND_STRUCTURES))o instanceof StructureRampart?o.my||o.isPublic||t.set(o.pos.x,o.pos.y,255):o instanceof StructureRoad?t.set(o.pos.x,o.pos.y,r):o.structureType!==STRUCTURE_CONTAINER&&t.set(o.pos.x,o.pos.y,255);for(let r of e.find(FIND_CONSTRUCTION_SITES))r.structureType!==STRUCTURE_CONTAINER&&r.structureType!==STRUCTURE_ROAD&&r.structureType!==STRUCTURE_RAMPART&&t.set(r.pos.x,r.pos.y,255);return t}),i.addCreepsToMatrix=((e,t)=>(e.find(FIND_CREEPS).forEach(e=>t.set(e.pos.x,e.pos.y,255)),t)),i.serializePath=((e,t)=>{let r="",o=e;for(let e of t)e.roomName===o.roomName&&(r+=o.getDirectionTo(e)),o=e;return r}),i.positionAtDirection=((e,t)=>{return new RoomPosition(e.x+[0,0,1,1,1,0,-1,-1,-1][t],e.y+[0,-1,-1,0,1,1,1,0,-1][t],e.roomName)}),t.TravelerInstall=(()=>{_.assign(global,{CompressedMatrix:new o.CompressedMatrix,Traveler:i,traveler:new i,travelerTick:Game.time})})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CompressedMatrix=class{constructor(){this.state={nSize:0,cSize:0},this.serialize=(e=>{let t=`${e._bits[0]}x`,r=1;for(let o=1;o<e._bits.length;o++){let i=e._bits[o];i!==e._bits[o-1]?(t+=`${r},${i}x`,r=1):r++}return t+=`${r}`}),this.deserialize=(e=>{const t=new PathFinder.CostMatrix;let r,o,i,s=0;return e.split(",").forEach(e=>{r=e.split("x"),o=r[0],i=r[1],o?_.times(i,e=>{t._bits[s]=o,s++}):s+=i}),t}),this.compareEfficiency=((e,t=new PathFinder.CostMatrix,r=!0)=>{let o,i,s,a;for(let n=0;n<e;n++)o=t.serialize(),r&&Log.module("Matrix","normal",o),s=i=JSON.stringify(o),r&&Log.module("Matrix","normal-deserialize",PathFinder.CostMatrix.deserialize(JSON.parse(i)).serialize()),o=this.serialize(t),r&&Log.module("Matrix","comp-serialize",o),a=i=JSON.stringify(o),r&&Log.module("Matrix","comp-deserialize",this.deserialize(JSON.parse(i)).serialize());this.state.nSize=s.length/1024,this.state.cSize=a.length/1024,Log.module("Matrix","normal size:",_.round(this.state.nSize,2),"compressed size:",_.round(this.state.cSize,2),"reduction(% of original size):",_.round(this.state.cSize/this.state.nSize,2))})}}},function(e,t){e.exports=require("config")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t){if(this.next=(()=>{const e=this._stepA,t=this._stepB,r={done:!1,value:{}};switch(this._dir){case TOP_RIGHT:r.value.x=Math.round(this.x-e),r.value.y=Math.round(this.y+t);break;case BOTTOM_RIGHT:r.value.x=Math.round(this.x-t),r.value.y=Math.round(this.y-e);break;case BOTTOM_LEFT:r.value.x=Math.round(this.x+e),r.value.y=Math.round(this.y-t);break;case TOP_LEFT:r.value.x=Math.round(this.x+e),r.value.y=Math.round(this.y+t);break;default:return{done:!0,value:!1}}return this._stepA=e-.5,this._stepB=t+.5,this._stepA<1&&(this._dir=this._dir+2,this._stepA=this._radius-.25,this._stepB=.25),r}),!_.isFinite(t))throw new Error("not finite: "+JSON.stringify([e,t]));this._radius=t,this.x=e.x,this.y=e.y,this._dir=TOP_RIGHT,this._stepA=t-.25,this._stepB=.25}}o.loop=((e,t)=>{const r=e,i=t;if(!_.isFinite(t))throw new Error("not finite: "+JSON.stringify([e,t]));return{[Symbol.iterator]:()=>new o(r,i)}}),o.inside=((e,t,r)=>Math.abs(t.x-e.x)+Math.abs(t.y-e.y)<r),t.default=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t,r){this.next=(()=>{if(o.dirTransform(this,this._dir),--this._step,this._step<=0)switch(this._step=2*this._ring,this._dir){case TOP:this._ring++,this._step++,this._dir=RIGHT;break;case RIGHT:this._dir=BOTTOM;break;case BOTTOM:this._dir=LEFT;break;case LEFT:this._step++,this._dir=TOP;break;default:throw new Error("illegal _dir="+this._dir)}return{done:this._ring>=this._ringLimit,value:{x:this.x,y:this.y}}}),this._dir=TOP,this.x=e.x,void 0===t?(this._ring=0,this._step=2,this.y=e.y+1):(this._ring=t-1,this._step=1,this.y=e.y),void 0===r?this._ringLimit=Math.min(2,this._ring+1):Number.isFinite(r)&&(this._ringLimit=r)}depth(){return this._ring}}o.dirTransform=((e,t)=>{switch(t){case TOP_RIGHT:e.x++;case TOP:e.y--;break;case BOTTOM_RIGHT:e.y++;case RIGHT:e.x++;break;case BOTTOM_LEFT:e.x--;case BOTTOM:e.y++;break;case TOP_LEFT:e.y--;case LEFT:e.x--}return e}),t.default=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=new class{constructor(){this.LAB_REACTIONS={},this.LAB_IDLE="idle",this.LAB_BOOST="boost",this.LAB_SEED="seed",this.LAB_MASTER="master",this.LAB_SLAVE_1="slave_1",this.LAB_SLAVE_2="slave_2",this.LAB_SLAVE_3="slave_3",this.REACTOR_TYPE_FLOWER="flower",this.REACTOR_MODE_IDLE="idle",this.REACTOR_MODE_BURST="burst",this.CREEP_PART_THREAT={move:{common:0,boosted:0},work:{common:1,boosted:3},carry:{common:0,boosted:0},attack:{common:2,boosted:5},ranged_attack:{common:2,boosted:5},heal:{common:4,boosted:10},claim:{common:1,boosted:3},tough:{common:1,boosted:3},tower:25},this.FLAG_COLOR={invade:{color:COLOR_RED,secondaryColor:COLOR_RED,exploit:{color:COLOR_RED,secondaryColor:COLOR_GREEN},robbing:{color:COLOR_RED,secondaryColor:COLOR_YELLOW},attackController:{color:COLOR_RED,secondaryColor:COLOR_CYAN}},labs:{color:COLOR_PURPLE,secondaryColor:COLOR_PURPLE,filter:{color:COLOR_PURPLE,secondaryColor:COLOR_PURPLE},labTech:{color:COLOR_PURPLE,secondaryColor:COLOR_WHITE,filter:{color:COLOR_PURPLE,secondaryColor:COLOR_WHITE}}},construct:{color:COLOR_CYAN,secondaryColor:COLOR_CYAN,spawn:{color:COLOR_CYAN,secondaryColor:COLOR_RED},tower:{color:COLOR_CYAN,secondaryColor:COLOR_PURPLE},link:{color:COLOR_CYAN,secondaryColor:COLOR_BLUE},lab:{color:COLOR_CYAN,secondaryColor:COLOR_GREEN},storage:{color:COLOR_CYAN,secondaryColor:COLOR_YELLOW},terminal:{color:COLOR_CYAN,secondaryColor:COLOR_ORANGE},observer:{color:COLOR_CYAN,secondaryColor:COLOR_BROWN},nuker:{color:COLOR_CYAN,secondaryColor:COLOR_GREY},powerSpawn:{color:COLOR_CYAN,secondaryColor:COLOR_WHITE}},claim:{color:COLOR_GREEN,secondaryColor:COLOR_GREEN,spawn:{color:COLOR_GREEN,secondaryColor:COLOR_WHITE},pioneer:{color:COLOR_GREEN,secondaryColor:COLOR_RED},reserve:{color:COLOR_GREEN,secondaryColor:COLOR_GREY},mining:{color:COLOR_GREEN,secondaryColor:COLOR_BROWN},delivery:{color:COLOR_GREEN,secondaryColor:COLOR_YELLOW}},defense:{color:COLOR_YELLOW,secondaryColor:COLOR_YELLOW},destroy:{color:COLOR_ORANGE,secondaryColor:COLOR_ORANGE,dismantle:{color:COLOR_ORANGE,secondaryColor:COLOR_YELLOW}},pavementArt:{color:COLOR_BROWN,secondaryColor:COLOR_BROWN},command:{color:COLOR_WHITE,drop:{color:COLOR_WHITE,secondaryColor:COLOR_YELLOW},_OCS:{color:COLOR_WHITE,secondaryColor:COLOR_PURPLE},roomLayout:{color:COLOR_WHITE,secondaryColor:COLOR_CYAN},invalidPosition:{color:COLOR_WHITE,secondaryColor:COLOR_RED},skipRoom:{color:COLOR_WHITE,secondaryColor:COLOR_GREEN},idle:{color:COLOR_WHITE,secondaryColor:COLOR_BROWN},safeGen:{color:COLOR_WHITE,secondaryColor:COLOR_BLUE}}},this.DECAY_AMOUNT={rampart:RAMPART_DECAY_AMOUNT,road:ROAD_DECAY_AMOUNT,container:CONTAINER_DECAY},this.DECAYABLES=[STRUCTURE_ROAD,STRUCTURE_CONTAINER,STRUCTURE_RAMPART],this.MEM_SEGMENTS={COSTMATRIX_CACHE:{start:99,end:95}},this.ACTION_SAY={ATTACK_CONTROLLER:String.fromCodePoint(128640),AVOIDING:String.fromCodePoint(128064),BOOSTING:String.fromCodePoint(128293),BUILDING:String.fromCodePoint(127959),BULLDOZING:String.fromCodePoint(128668),CHARGING:String.fromCodePoint(128268),CLAIMING:String.fromCodePoint(9971),DEFENDING:String.fromCodePoint(9876),DISMANTLING:String.fromCodePoint(9937),DROPPING:String.fromCodePoint(128169),FEEDING:String.fromCodePoint(127829),FORTIFYING:String.fromCodePoint(128679),FUELING:String.fromCodePoint(9981),GUARDING:String.fromCodePoint(128737),HARVESTING:String.fromCodePoint(9935),HEALING:String.fromCodePoint(128138),IDLE:String.fromCodePoint(127925),INVADING:String.fromCodePoint(128299),MINING:String.fromCodePoint(9935),PICKING:String.fromCodePoint(129508),REALLOCATING:String.fromCodePoint(128302),RECYCLING:String.fromCodePoint(128260),REPAIRING:String.fromCodePoint(128295),RESERVING:String.fromCodePoint(128681),ROBBING:String.fromCodePoint(128123),STORING:String.fromCodePoint(9196),TRAVELLING:String.fromCodePoint(127939),UNCHARGING:String.fromCodePoint(128267),UPGRADING:String.fromCodePoint(128591),WITHDRAWING:String.fromCodePoint(9195),SAFEGEN:String.fromCodePoint(128274)};for(let e in REACTIONS)for(let t in REACTIONS[e])this.LAB_REACTIONS[REACTIONS[e][t]]=[e,t]}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(),this.fresh=(()=>{Memory.cpu.loop={},Memory.CPU_CHECK||(Memory.CPU_CHECK=CPU_CHECK)}),this.check=((e,...t)=>{if(!Memory.CPU_CHECK)return;const r=[e].concat(t).join("-");_.set(Memory.cpu.loop,r,Game.cpu.getUsed())}),this.end=((e,...t)=>{if(!Memory.CPU_CHECK)return;const r=[e].concat(t).join("-"),o=Memory.cpu.loop[r];o?_.set(Memory.cpu.loop,r,(Game.cpu.getUsed()-o).toFixed(3)):Log.error("not find cpu namespace:",r)}),this.handleData=(()=>{if(!Memory.CPU_CHECK)return;const e=Game.cpu.getUsed().toFixed(3);Memory.cpu.cpu=e,Memory.cpu.cpus?Memory.cpu.cpus.push(e):Memory.cpu.cpus=[e],_.forEach(Memory.cpu.loop,(e,t)=>{Memory.cpu.loops[t]?Memory.cpu.loops[t].push(e):Memory.cpu.loops[t]=[e]})}),this.start=(()=>{Memory.CPU_CHECK=!0,Log.info("CPU Check Start!"),Memory.cpu={loop:{},loops:{},cpu:0,cpus:[]}}),this.stop=(()=>{Memory.CPU_CHECK=!1,Memory.cpu={loop:{},loops:{},cpu:0,cpus:[]},Log.info("CPU Check Stop..")}),this.status=(()=>(Log.info("CPU Check Status:",Memory.CPU_CHECK),Memory.CPU_CHECK)),this.report=(()=>{if(0===Object.keys(Memory.cpu).length)return this.status()||this.start(),void Log.info("CPU wait data...");const e=Memory.cpu.cpus;let t=(_.sum(e)/e.length).toFixed(3),r={};_.forEach(Memory.cpu.loops,(e,t)=>{r[t]=(_.sum(e)/e.length).toFixed(3)}),Log.trace("CPU",r,`usage: ${t} | avg: ${e.length} ticks`)}),this.reportOnce=(()=>{if(0===Object.keys(Memory.cpu.loop).length)return this.status()||this.start(),void Log.info("CPU wait data...");Log.trace("CPU",Memory.cpu.loop,`total-usage: ${Game.cpu.getUsed().toFixed(3)}`),this.stop()}),Memory.cpu||(Memory.cpu={loop:{},loops:{}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.EventConstructor=class{constructor(){this.handlers=[],this.on=(e=>{null!==e&&this.handlers.push(e)}),this.off=(e=>{this.handlers=this.handlers.filter(t=>t!==e)}),this.trigger=(e=>{try{this.handlers.slice(0).forEach(t=>t(e))}catch(e){Log.error("Error in LiteEvent.trigger: "+(e.stack||e))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepSetup=class{constructor(e){this.minControllerLevel=0,this.none={fixedBody:[],multiBody:[],minAbsEnergyAvailable:1/0,minEnergyAvailable:1,maxMulti:0,maxCount:0,maxWeight:0},this.globalMeasurement=!1,this.measureByHome=!1,this.sortedParts=!0,this.mixMoveParts=!1,this._fixedBody=(e=>this.getRCL(e,"fixedBody")),this._multiBody=(e=>this.getRCL(e,"multiBody")),this._minAbsEnergyAvailable=(e=>this.getRCL(e,"minAbsEnergyAvailable")),this._minEnergyAvailable=(e=>this.getRCL(e,"minEnergyAvailable")),this._minMulti=(e=>this.getRCL(e,"minMulti")),this._maxMulti=(e=>this.getRCL(e,"maxMulti")),this._maxCount=(e=>this.getRCL(e,"maxCount")),this._maxWeight=(e=>this.getRCL(e,"maxWeight")),this.buildParams=(e=>{let t={setup:null,name:null,parts:[],cost:0,mother:null,home:null,breeding:1};t.setup=this.type,t.parts=this.parts(e.room),t.cost=Creep.bodyCosts(t.parts),t.mother=e.name,t.home=e.pos.roomName;for(let e=1;null==t.name||Game.creeps[t.name]||Memory.population[t.name];e++)t.name=this.type+"-"+t.cost+"-"+e;return t}),this.isValidSetup=(e=>{if(e.RCL<this.minControllerLevel)return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,rcl:e.RCL,Setup:"isValidSetup"},"low RCL"),!1;let t=this._minAbsEnergyAvailable(e),r=this._minEnergyAvailable(e);const o=e.remainingEnergyAvailable,i=e.relativeRemainingEnergyAvailable;if(o<t||i<r)return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,absEnergy:o,energy:i,Setup:"isValidSetup"},"not enough energy"),!1;let s=this._maxCount(e),a=this._maxWeight(e);if(0===s||0===a)return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,maxCount:s,maxWeight:a,Setup:"isValidSetup"},"too many creeps"),!1;null==s&&(s=1/0),null==a&&(a=1/0);let n=0,l=0;if(this.measureByHome){let t=e.name,r=e=>{e.creepType==this.type&&e.homeRoom==t&&Creep.isWorkingAge(e)&&(n++,l+=e.weight)};_.forEach(Memory.population,r)}else{let t=this.globalMeasurement?Population:e.population;if(!t||!t.typeCount[this.type])return!0;n=t.typeCount[this.type]||0,l=t.typeWeight[this.type]||0}const m=n<s&&l<a;return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,returnVal:m,Setup:"isValidSetup"},"count:",n,"<",s,"weight:",l,"<",a),m}),this.existingWeight=(e=>{let t=0;if(this.measureByHome){let r=e.name,o=e=>{e.creepType==this.type&&e.homeRoom==r&&(t+=e.weight)};_.forEach(Memory.population,o)}else{let r=this.globalMeasurement?Population:e.population;t=r&&r.typeWeight[this.type]||0}return t}),this.parts=(e=>{const t=this._fixedBody(e),r=this._multiBody(e),o=this._minMulti(e),i=this._maxMulti(e),s=this._maxWeight(e);let a;return s&&(a=s-this.existingWeight(e)),LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,Setup:"parts",maxWeight:s,minMulti:o,maxMulti:i}),Creep.compileBody(e,{fixedBody:t,multiBody:r,minMulti:o,maxMulti:i,maxWeight:a,currentEnergy:!0,sort:this.sortedParts})}),this.mixParts=(e=>{let t=_.countBy(e),r=e.filter(e=>e!=MOVE),o=[];for(let e=r.length-1;e>=0;e--)t[MOVE]-- >0&&o.unshift(MOVE),o.unshift(r[e]);for(;t[MOVE]>0;)o.unshift(MOVE),t[MOVE]--;return o}),this.maxCost=(e=>Creep.bodyCosts(this._multiBody(e))*this._maxMulti(e)+Creep.bodyCosts(this._fixedBody(e))),this.maxPerFlag=((e,t,r)=>{if(!e)throw new Error("undefined flagFilter");return o=>{let i,s,a=0;return Flag.filter(e).forEach(e=>{(i=Util.routeRange(o.name,e.roomName))>t||(s=Game.flags[e.name],_.chain(s.targetOf).filter(e=>!r||e.homeRoom===o.name).every(Creep.isWorkingAge).value()?a++:a+=2)}),a}}),this.getRCL=((e,t)=>{const r=this.RCL[e.RCL][t];return _.isFunction(r)?r(e):r}),this.type=e}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.none,7:this.none,8:this.none}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepAction=class{constructor(e){this.maxPerTarget=1/0,this.maxPerAction=1/0,this.targetRange=1,this.reachedRange=1,this.renewTarget=!0,this.default={name:`default-${this.name}`,moveOptions:e=>e||{}},this.setDefault=(e=>{_.assign(this.default,e)}),this.getTargetId=(e=>e.id||e.name),this.getTargetById=(e=>Game.getObjectById(e)||Game.spawns[e]||Game.flags[e]),this.isValidAction=(e=>!0),this.isValidTarget=((e,t)=>null!=e),this.isAddableAction=(e=>this.maxPerAction===1/0||!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isAddableTarget=((e,t)=>!e.targetOf||this.maxPerTarget===1/0||_.filter(e.targetOf,{actionName:this.name}).length<this.maxPerTarget),this.newTarget=(e=>null),this.unassign=(e=>{delete e.data.actionName,delete e.data.targetId,delete e.action,delete e.target}),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);if(r!=OK)return e.handleError({errorCode:r,action:this,target:e.target,range:t,creep:e}),this.unassign(e);t=e.pos.getRangeTo(e.target)}if(e.target&&e.hasActiveBodyparts(MOVE))if(t>this.targetRange)e.travelTo(e.target,{range:this.targetRange});else if(t>this.reachedRange){const t=e.pos.getDirectionTo(e.target),r=Traveler.positionAtDirection(e.pos,t);e.room.isWalkable(r.x,r.y)?e.move(t):e.pos.isNearTo(e.target)||e.travelTo(e.target,{range:this.reachedRange})}}),this.work=(e=>ERR_INVALID_ARGS),this.validateActionTarget=((e,t)=>{if(this.isValidAction(e)){if(this.isValidTarget(t,e))return t;if(this.renewTarget)return delete e.data.path,this.newTarget(e)}return null}),this.assign=((e,t)=>(void 0===t&&(t=this.newTarget(e)),!(!t||!this.isAddableTarget(t,e)||(LOG_TRACE&&Log.trace("Action",{creepName:e.name,assign:this.name,target:!t||t.name||t.id,Action:"assign"}),e.action&&e.action.name==this.name&&e.target&&e.target.id===t.id&&e.target.name==t.name||(Population.registerAction(e,this,t),this.onAssignment(e,t)),0)))),this.showAssignment=((e,t)=>{SAY_ASSIGNMENT&&ACTION_SAY[this.name.toUpperCase()]&&e.say(ACTION_SAY[this.name.toUpperCase()],SAY_PUBLIC),(t instanceof RoomObject||t instanceof RoomPosition&&VISUALS.ACTION_ASSIGNMENT)&&Visuals.drawArrow(e,t)}),this.onAssignment=((e,t)=>{this.showAssignment(e,t)}),this.selectstate=(()=>[this.default]),this.isMember=(e=>_.find(e,e=>e.name===this.name,this)),this.getStrategy=((e,t,...r)=>_.isUndefined(r)?t.getStrategyHandler([this.name],e):t.getStrategyHandler([this.name],e,...r)),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepBehaviour=class{constructor(e){this.state={default:{name:`default-${this.name}`}},this.setState=(e=>{_.assign(this.state,e)}),this.mergeState=(e=>{_.merge(this.state,e)}),this.actions=(e=>[]),this.inflowActions=(e=>[]),this.outflowActions=(e=>[]),this.assignAction=((e,t,r,o)=>{"string"==typeof t&&(t=Creep.action[t]);const i=t.isValidAction(e);if(LOG_TRACE&&Log.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,valid:i,Action:"isValidAction"}),!i)return!1;const s=t.isAddableAction(e);if(LOG_TRACE&&Log.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,addable:s,Action:"isAddableAction"}),!s)return!1;const a=t.assignDebounce?t.assignDebounce(e,o,r):t.assign(e,r);return a?(LOG_TRACE&&Log.trace("Behaviour",{actionName:t.name,behaviourName:this.name,creepName:e.name,assigned:a,Behaviour:"nextAction",Action:"assign",target:e.target.id||e.target.name}),e.data.lastAction=t.name,e.data.lastTarget=e.target.id,!0):(LOG_TRACE&&Log.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,assigned:a,Behaviour:"assignAction",Action:"assign"}),!1)}),this.selectInflowAction=(e=>{const t={},r=this.outflowActions(e);for(let o of this.inflowActions(e))if(!t[o.name]&&(t[o.name]=!0,this.assignAction(e,o,void 0,r)))return;return Creep.action.idle.assign(e)}),this.selectAction=((e,t)=>{const r={};for(let o of t)if(!r[o.name]&&(r[o.name]=!0,this.assignAction(e,o)))return;return Creep.action.idle.assign(e)}),this.nextAction=(e=>this.selectAction(e,this.actions(e))),this.needEnergy=(e=>e.sum<e.carryCapacity/2),this.nextEnergyAction=(e=>{if(this.needEnergy(e))return this.selectInflowAction(e);if(e.data.nextAction&&e.data.nextTarget){const t=Creep.action[e.data.nextAction],r=Game.getObjectById(e.data.nextTarget);if(delete e.data.nextAction,delete e.data.nextTarget,this.assignAction(e,t,r))return!0}return this.selectAction(e,this.outflowActions(e))}),this.invalidAction=(e=>!e.action),this.run=(e=>{this.invalidAction(e)&&(e.data.destiny&&e.data.destiny.task&&Task[e.data.destiny.task]&&Task[e.data.destiny.task].nextAction?Task[e.data.destiny.task].nextAction(e):this.nextAction(e)),e.action&&e.target?(LOG_TRACE&&Log.trace("Behaviour",{actionName:e.action.name,behaviourName:this.name,creepName:e.name,target:e.target.id||e.target.name,Action:"run"}),e.action.step(e)):Log.error("Creep without action/activity!\nCreep: "+e.name+"\ndata: "+JSON.stringify(e.data))}),this.assign=(e=>{e.data.creepType=this.name}),this.selectstate=(e=>[this.state.default,this.state[e]]),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.RoomManager=class{constructor(e){this.extend=(()=>{this.prototypeExtend(),this.roomExtend()}),this.prototypeExtend=(()=>{}),this.roomExtend=(()=>{}),this.assignRoomPrototype=(e=>{Object.defineProperties(Room.prototype,e)}),this.assignRoom=(e=>{_.assign(Room,e)}),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o={[COLOR_RED]:"#F92672",[COLOR_PURPLE]:"#AE81FF",[COLOR_BLUE]:"#66D9EF",[COLOR_CYAN]:"#529B2F",[COLOR_GREEN]:"#A6E22E",[COLOR_YELLOW]:"#E6DB74",[COLOR_ORANGE]:"#FD971F",[COLOR_BROWN]:"#75715E",[COLOR_GREY]:"#999999",[COLOR_WHITE]:"#F8F8F0"},i=Object.assign({},o,{black:{color:"black",fontWeight:"bold"},system:{color:o[COLOR_GREY],fontSize:"9px"},success:{color:o[COLOR_GREEN],fontSize:"9px"},error:{color:o[COLOR_RED],fontSize:"9px"},warn:{color:o[COLOR_ORANGE],fontSize:"9px"},info:{color:o[COLOR_BLUE],fontSize:"9px"},debug:{color:o[COLOR_BROWN],fontSize:"9px"},room:{color:o[COLOR_PURPLE],fontSize:"9px"}});t.default=((e,...t)=>{const r=i[e],o=t.join(" ");return _.isObject(r)?`<span style="${Util.css(r)}">${o}</span>`:`<span style="color: ${r}">${o}</span>`})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(65),i=r(9),s=r(2);t.default=new class{constructor(){this.LogLevel=o.LogLevel[LOG_LEVEL],this.Emoji=LOG_EMOJI}success(...e){const t=this.Emoji?s.Emoji.tick:"[SUCCESS]";console.log(Dye("success",t)+" "+Dye(COLOR_GREEN,...e))}error(...e){if(this.LogLevel<2)return;const t=this.Emoji?s.Emoji.cross:"[ERROR]";console.log(Dye("error",t)+" "+Dye(COLOR_RED,...e))}errorCode(e,t){if(t){const r=i.ErrorType[t];e&&(r?e.say(r):e.say(t));let o=r+"\nroom: "+e.pos.roomName+"\ncreep: "+e.name+"\naction: "+e.data.actionName+"\ntarget: "+e.data.targetId;this.error(o),Game.notify(o,120)}else{let t="unknown error code\nroom: "+e.pos.roomName+"\ncreep: "+e.name+"\naction: "+e.data.actionName+"\ntarget: "+e.data.targetId;this.error(t,this.stack())}}warn(...e){if(this.LogLevel<3)return;const t=this.Emoji?s.Emoji.warn:"[WARN]";console.log(Dye("warn",t)+" "+Dye(COLOR_ORANGE,...e))}info(...e){if(this.LogLevel<4)return;const t=this.Emoji?s.Emoji.info:"[INFO]";console.log(Dye("info",t)+" "+Dye(COLOR_BLUE,...e))}debug(...e){if(this.LogLevel<5)return;const t=this.Emoji?s.Emoji.debug:"[DEBUG]";console.log(Dye("debug",t),...e)}module(e,...t){console.log(Dye("system",`[${e}]`),...t)}room(e,...t){e=_.isString(e)?Util.makeRoomUrl(e):e.print;const r=this.Emoji?`${s.Emoji.home} ${e}`:`[${e}]`;console.log(Dye("room",r),...t)}flag(e,...t){e=_.isString(e)?Util.makeFlagUrl(e):e.print;const r=this.Emoji?`${s.Emoji.flag} ${e}`:`[${e}]`;console.log(Dye("room",r),...t)}stringify(e){console.log(JSON.stringify(e,null,2))}table(e){console.log(Util.jsonToTable(e))}stack(e=!1,t=" "){return DEBUG_STACKS||e?new Error(`\nSTACK; param:${DEBUG_STACKS}, force:${e}`).stack:t}trace(e,t,...r){let o,i=r;if(0===r.length&&e){let r=e;do{o=r,r=t[r]}while(t[r]&&r!==e);r&&r!==e&&(i="string"==typeof r?[r]:[o,"=",r])}console.log(Dye(COLOR_ORANGE,`[${e}]`),...i,"<br/>",Util.jsonToTable(t),this.stack())}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.alert=1]="alert",e[e.error=2]="error",e[e.warn=3]="warn",e[e.info=4]="info",e[e.debug=5]="debug"}(t.LogLevel||(t.LogLevel={}))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.numSaved=0,this.toActivate={},this.extend=(()=>{this.activateSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,!0),_.defaults(Memory,{cloaked:{},debugTrace:{error:!0,no:{}},pavementArt:{}})}),this.fresh=(()=>{Memory.CPU_CRITICAL=Memory.CPU_CRITICAL?Game.cpu.bucket<CRITICAL_BUCKET_LEVEL+CRITICAL_BUCKET_OVERFILL:Game.cpu.bucket<CRITICAL_BUCKET_LEVEL,this.processSegments()}),this.cleanup=(()=>{_.size(this.toActivate)>0&&RawMemory.setActiveSegments(Object.keys(this.toActivate)),this.toActivate={},this.numSaved=0}),this.activateSegment=((e,t=!1)=>{if(e.start&&e.end){for(let r=e.start;r>=e.end;r--)this.activateSegment(r,t);return}if(e<0||e>99)return Log.error("[CMemory]","cannot activate invalid segment ",e);const r=_.size(RawMemory.segments);if(this.numSaved>=10)return Log.error("[CMemory]","10 segments saved, cannot activate segment ",e);if(!t){if(r>=10)return Log.error("[CMemory]","10 segments loaded, cannot activate segment ",e);if(r+this.numSaved>=10)return Log.error("[CMemory] RawMemory","combined loaded and saved exceeds limit(10), cannot activate segment ",e)}this.toActivate[e]=!0}),this.deactivateSegment=(e=>{if(e<0||e>99)return Log.error("[CMemory]","cannot deactivate invalid segment ",e);0===_.size(this.toActivate)&&Object.keys(RawMemory.segments).forEach(e=>this.toActivate[e]=!0),delete this.toActivate[e]}),this.cacheValid=(e=>Util.cacheValid[e]===Memory.cacheValid[e]),this.processSegment=((e,t)=>{_.isUndefined(Memory.cacheValid[e])&&(Memory.cacheValid[e]=!1);const r=RawMemory.segments[e];if(!this.cacheValid(e))try{t(r?JSON.parse(r):{}),Util.cacheValid[e]=Memory.cacheValid[e]}catch(t){Log.error("[CMemory] Error loading segment",e," caused by ",t.stack||t.toString()),RawMemory.segments[e]="",delete Util.cacheValid[e],delete Memory.cacheValid[e]}}),this.processSegments=(()=>{_.isUndefined(Util.cacheValid)&&(Util.cacheValid={}),_.isUndefined(Memory.cacheValid)&&(Memory.cacheValid={});for(let e=MEM_SEGMENTS.COSTMATRIX_CACHE.start;e>=MEM_SEGMENTS.COSTMATRIX_CACHE.end;e--)this.processSegment(e,Room.loadCostMatrixCache)}),this.saveSegment=((e,t)=>{const r=_.size(RawMemory.segments),o=Object.keys(t);let i,s=0;for(let a=e.start;a>=e.end;a--)if(o&&s<o.length||i&&i.length>1)if(!_.isUndefined(RawMemory.segments[a])||r+this.numSaved<10){let e,r=!1;for(;s<o.length;){const a=o[s];if(s++,e=`"${a}":${JSON.stringify(t[a])}`,r=(_.get(i,"length",0)+_.get(e,"length",0)+2)/1024>100)break;i=i?i+","+e:"{"+e}if(!i&&e&&e.length>0){const t=_.round((e.length+2)/1024,2);return Log.error("[CMemory]",`Cannot save data at key ${s}, exceeds 100kb limit ${t}kb`)}Log.module("CMemory","Segment: Saving "+_.round(i.length/1024,2)+"kb of data to segment "+a),RawMemory.segments[a]=i+"}",Memory.cacheValid[a]=Game.time,i=r&&e?"{"+e:"{",_.isUndefined(RawMemory.segments[a])&&this.numSaved++}else{if(r>10)return Log.error("[CMemory]","cannot save segment "+a+" too many active segments.");if(r+this.numSaved>10)return Log.error("[CMemory]","cannot save segment "+a+" loaded + saved exceeds limit(10).");Log.error("[CMemory] RawMemory","should not be here.")}else Memory.cacheValid[a]&&(Log.module("CMemory","Segment: clearing unused segment "+a),RawMemory.segments[a]="",delete Memory.cacheValid[a])})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.structureType={1:STRUCTURE_ROAD,2:STRUCTURE_EXTENSION,3:STRUCTURE_TOWER,4:STRUCTURE_SPAWN,5:STRUCTURE_POWER_SPAWN,6:STRUCTURE_STORAGE,7:STRUCTURE_LINK,8:STRUCTURE_TERMINAL,9:STRUCTURE_LAB,10:STRUCTURE_NUKER,11:STRUCTURE_OBSERVER},this.run=(()=>{Game.time%10==0&&_.forEach(Memory.rooms,(e,t)=>{!e.RCL||e.RCL<2||!e.center||(e.RBL||(e.RBL=1),e.RBL!==e.RCL&&(this.x=e.center.x-6,this.y=e.center.y-6,this.room=Game.rooms[t],this.build(this.layout[e.RBL])))})}),this.build=(e=>{if(!e)return;let t=!0;_.forEach(e,(e,r)=>{_.forEach(e,(e,o)=>{0!==e&&this.room.createConstructionSite(this.x+o,this.y+r,this.structureType[e])!==ERR_INVALID_TARGET&&(t=!1)})}),t&&this.room.memory.RBL++}),this.layout={0:[[0,1,1,1,2,1,1,1,2,1,1,1,0],[1,1,2,2,1,2,10,2,1,2,2,1,1],[1,2,2,1,2,1,2,1,2,1,2,2,1],[1,2,1,2,2,2,1,2,2,2,1,2,1],[2,1,2,2,3,1,4,1,3,2,2,1,2],[1,2,1,2,1,1,3,1,1,2,1,2,1],[1,2,2,1,4,3,6,3,4,1,2,2,1],[1,2,1,2,1,1,1,1,1,2,1,2,1],[2,1,2,2,3,1,7,1,8,9,9,1,2],[1,2,1,2,2,2,1,2,9,9,1,9,1],[1,2,2,1,2,1,2,1,9,1,9,9,1],[1,1,2,2,1,2,5,2,1,9,9,11,1],[0,1,1,1,2,1,1,1,2,1,1,1,0]],1:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,1,2,1,0,0,0,0,0,0,0],[0,0,1,2,0,2,1,0,0,0,0,0,0],[0,1,2,0,0,1,0,1,0,0,0,0,0],[0,0,1,2,1,1,0,1,1,0,0,0,0],[0,0,0,1,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],2:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,1,2,1,0,0,0],[0,0,0,0,0,0,0,2,0,2,1,0,0],[0,0,0,0,0,0,0,0,0,0,2,1,0],[0,0,0,0,0,0,0,0,0,2,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],3:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,2,0,0,0,0,0,0],[0,0,0,0,2,0,0,0,2,0,0,0,0],[0,0,0,2,0,0,0,0,0,2,0,0,0],[0,0,0,0,0,0,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],4:[[0,1,1,1,0,1,1,1,0,1,1,1,0],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,2,0,0,0,6,0,0,0,2,1,1],[1,0,1,2,0,0,0,0,0,0,1,0,1],[0,1,2,2,0,0,0,0,0,0,0,1,0],[1,0,1,2,2,2,0,0,0,0,1,0,1],[1,0,0,1,2,1,2,1,0,1,0,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,1],[0,1,1,1,0,1,1,1,0,1,1,1,0]],5:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,3,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,7,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],6:null,7:null}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(2);t.default=new class extends o.Component{constructor(){super(...arguments),this.typeCount={},this.typeWeight={},this.actionCount={},this.actionWeight={},this.died=[],this.predictedRenewal=[],this.spawned=[],this.spawnsToProbe=[],this.stats={creep:{coreParts:{[MOVE]:!0,[HEAL]:!0},boost:{hits:{[RESOURCE_GHODIUM_OXIDE]:143,[RESOURCE_GHODIUM_ALKALIDE]:200,[RESOURCE_CATALYZED_GHODIUM_ALKALIDE]:334}}}},this.fresh=(()=>{this.typeCount={},this.typeWeight={},this.actionCount={},this.actionWeight={},this.died=[],this.predictedRenewal=[],this.spawned=[],this.spawnsToProbe=[],_.isUndefined(Memory.population)&&(Memory.population={})}),this.analyze=(()=>{let e=e=>{let t=Game.creeps[e.creepName];if(t){if(t.data=e,delete t.action,delete t.target,delete t.flag,t.spawning?e.spawningTime++:t.ticksToLive>0&&!t.data.spawned?(t.data.spawned=!0,this.spawned.push(e.creepName),Game.spawns[e.motherSpawn]&&this.spawnsToProbe.push(e.motherSpawn)):t.ticksToLive<=(e.predictedRenewal?e.predictedRenewal:e.spawningTime)&&!t.data.nearDeath&&(t.data.nearDeath=!0,CENSUS_ANNOUNCEMENTS&&console.log(i.Emoji.skull,Dye("black",e.creepName,"Farewell!"),Log.stack()),this.predictedRenewal.push(t.name),!this.spawnsToProbe.includes(e.motherSpawn)&&"unknown"!=e.motherSpawn&&Game.spawns[e.motherSpawn]&&this.spawnsToProbe.push(e.motherSpawn)),e.ttl=t.ticksToLive,e.creepType&&(void 0===t.ticksToLive||Creep.isWorkingAge(e))&&this.countCreep(t.room,e),e.flagName){let r=Game.flags[e.flagName];r?(void 0===r.targetOf?r.targetOf=[e]:r.targetOf.push(e),t.flag=r):delete e.flagName}let r=e.actionName&&Creep.action[e.actionName]?Creep.action[e.actionName]:null,o=r&&e.targetId?Game.getObjectById(e.targetId)||Game.spawns[e.targetId]||Game.flags[e.targetId]:null;o&&o.id===t.id&&(o=Flag.specialFlag()),r&&o?this.registerAction(t,r,o,e):(delete e.actionName,delete e.targetId,t.action=null,t.target=null),void 0===e.hull&&_.assign(e,this.getCombatStats(t.body)),t.data=e}else Log.room(e.homeRoom,i.Emoji.skull,Dye("black",e.creepName,"was dead")),this.died.push(e.creepName)};_.forEach(Memory.population,t=>{e(t)});let t=e=>{let t=Game.creeps[e.creepName];if(t&&t.action&&t.target){let r=t.target.id||t.target.name,o=t.action.validateActionTarget(t,t.target);o?(r!=o.id||o.name)&&this.registerAction(t,t.action,o,e):(delete e.actionName,delete e.targetId,t.action=null,t.target=null)}};_.forEach(Memory.population,e=>{t(e)})}),this.run=(()=>{if(this.spawned.forEach(e=>Creep.spawningCompleted.trigger(Game.creeps[e])),Creep.died.on(e=>{const t=Memory.population[e];t&&t.determinatedSpot&&t.roomName&&Room.costMatrixInvalid.trigger(t.roomName)}),this.died.forEach(e=>Creep.died.trigger(e)),this.predictedRenewal.forEach(e=>Creep.predictedRenewal.trigger(Game.creeps[e])),Game.time%SPAWN_INTERVAL!=0){let e=e=>Game.spawns[e].run();this.spawnsToProbe.forEach(e)}}),this.cleanup=(()=>{this.died.forEach(e=>this.unregisterCreep(e))}),this.getCreep=(e=>Memory.population[e]),this.setCreep=(e=>(Memory.population[e.creepName]=e,Memory.population[e.creepName])),this.registerCreep=((e,t,r,o,i,s,a=null)=>{let n=this.setCreep({creepName:e,creepType:t,weight:r,roomName:o.name,homeRoom:o.name,motherSpawn:i,actionName:null,targetId:null,spawningTime:0,flagName:null,body:_.countBy(s),destiny:a});this.countCreep(o,n)}),this.unregisterCreep=(e=>{delete Memory.population[e],delete Memory.creeps[e]}),this.registerAction=((e,t,r,o)=>{if(LOG_TRACE&&Log.trace("Population",{creepName:this.name,registerAction:t.name,target:r.name||r.id,Population:"registerAction"}),e===r)throw new Error("attempt to register self target");void 0===o&&(o=this.getCreep(e.name)),o.carryCapacityLeft=e.carryCapacity-e.sum;let i=e.room;void 0===i.population&&(i.population={typeCount:{},typeWeight:{},actionCount:{},actionWeight:{}}),e.action&&(void 0===i.population.actionCount[e.action.name]?i.population.actionCount[e.action.name]=0:i.population.actionCount[e.action.name]--,void 0===i.population.actionWeight[e.action.name]?i.population.actionWeight[e.action.name]=0:i.population.actionWeight[e.action.name]-=o.weight,void 0===this.actionCount[e.action.name]?this.actionCount[e.action.name]=0:this.actionCount[e.action.name]--,void 0===this.actionWeight[e.action.name]?this.actionWeight[e.action.name]=0:this.actionWeight[e.action.name]-=o.weight,delete e.data.determinatedSpot,delete e.data.determinatedTarget),o.actionName=t.name,void 0===i.population.actionCount[t.name]?i.population.actionCount[t.name]=1:i.population.actionCount[t.name]++,void 0===i.population.actionWeight[t.name]?i.population.actionWeight[t.name]=o.weight:i.population.actionWeight[t.name]+=o.weight,void 0===this.actionCount[t.name]?this.actionCount[t.name]=1:this.actionCount[t.name]++,void 0===this.actionWeight[t.name]?this.actionWeight[t.name]=o.weight:this.actionWeight[t.name]+=o.weight;let s,a=r.id||r.name;if(o.targetId){let t=o.targetId?Game.getObjectById(o.targetId)||Game.spawns[o.targetId]||Game.flags[o.targetId]:null;if(t&&(s=t.id||t.name,t.targetOf)){let r=t=>t.creepName===e.name,o=t.targetOf.findIndex(r);o>-1&&t.targetOf.splice(o,1)}}o.targetId=a,r&&!Flag.isSpecialFlag(r)&&(void 0===r.targetOf?r.targetOf=[o]:r.targetOf.push(o)),a!=s&&delete o.path,e.action=t,e.target=r,e.data=o}),this.registerCreepFlag=((e,t)=>{if(!(t&&e.data&&e.data.flagName&&e.data.flagName==t.name&&e.flag.name==t.name)){if(e.data&&e.data.flagName){let t=Game.flags[e.data.flagName];if(t&&t.targetOf){let r=t=>t.creepName===e.name,o=t.targetOf.findIndex(r);o>-1&&t.targetOf.splice(o,1)}}t?(void 0===t.targetOf?t.targetOf=[e.data]:t.targetOf.push(e.data),e.flag=t,e.data.flagName=t.name):(delete e.data.flagName,delete e.flag)}}),this.countCreep=((e,t)=>{t.roomName=e.name,void 0===e.population&&(e.population={typeCount:{},typeWeight:{},actionCount:{},actionWeight:{}}),void 0===e.population.typeCount[t.creepType]?e.population.typeCount[t.creepType]=1:e.population.typeCount[t.creepType]++,void 0===e.population.typeWeight[t.creepType]?e.population.typeWeight[t.creepType]=t.weight:e.population.typeWeight[t.creepType]+=t.weight,void 0===this.typeCount[t.creepType]?this.typeCount[t.creepType]=1:this.typeCount[t.creepType]++,void 0===this.typeWeight[t.creepType]?this.typeWeight[t.creepType]=t.weight:this.typeWeight[t.creepType]+=t.weight}),this.sortEntries=(()=>{let e={};_.map(_.sortBy(Memory.population,e=>e.creepName),t=>e[t.creepName]=t),Memory.population=e}),this.getCombatStats=(e=>{let t=0,r=99,o=100*e.length-99;for(;t<e.length&&!this.stats.creep.coreParts[e[t].type];t++)r+=this.stats.creep.boost.hits[e[t].boost]||100,o-=100;return{hull:r,coreHits:o}}),this.findCircular=(()=>{const e={creeps:Game.creeps,structures:Game.structures,memory:Memory},t={};for(let r in e){const o=e[r];for(let e in o){const i=o[e],s=r+"."+e;t[e]=s,this.checkCircular(e,t,i,s,1)}}}),this.checkCircular=((e,t,r,o,i)=>{if(i>10)Log.error("Checking for circulars, very deep path",{rootPath:o,depth:i});else for(let s in r){const a=o+"."+s,n=r[s];if(!_.isObject(n))continue;const l=n.id||n.name;if(l===e)throw new Error("circular structure:"+l+" at:"+a+" and at:"+t[l]);l&&!t[l]&&(t[l]=a,this.checkCircular(e,t,n,a,i+1))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.storedStatisticsTime=Memory.statistics&&Memory.statistics.time?Memory.statistics.time:0,this.run=(()=>{let e;if(_.isUndefined(Memory.statistics)&&(Memory.statistics={reports:[]}),SEND_STATISTIC_REPORTS&&this.storedStatisticsTime>0){if(e="<div><h3><b>Status report </b></h3><h4>at "+Util.toDateTimeString(Util.toLocalDate())+",<br/>comparison to state before: "+this.toTimeSpanString(new Date,new Date(this.storedStatisticsTime))+" ("+(Game.time-Memory.statistics.tick)+" loops)</h4>",Game.cpu.bucket){const t=Game.cpu.bucket-Memory.statistics.bucket;e+="CPU Bucket: "+Game.cpu.bucket+" ("+(t>=0?"+":"")+t+")"}e+="</div>",Memory.statistics.reports.push(e)}let t=t=>{let r="<li>"+t.owner+": "+t.body.replace(/"/g,"");void 0===t.leave?r+=" since "+Util.toTimeString(Util.toLocalDate(new Date(t.time)))+"</li>":r+=" for "+(t.leave-t.enter)+" loops at "+Util.toTimeString(Util.toLocalDate(new Date(t.time)))+"</li>",e.length+r.length>REPORT_MAX_LENGTH?(Memory.statistics.reports.push(e+"</ul></li></ul>"),e='<ul><li style="list-style-type:none"><ul>'+r):e+=r};_.forEach(Game.rooms,r=>{if(r.controller){if(SEND_STATISTIC_REPORTS&&this.storedStatisticsTime>0)if(r.controller.my&&r.memory.statistics){e="<ul><li><b>Room "+r.name+"</b><br/><u>Controller</u><ul>";let o=r.controller.progress<r.memory.statistics.controllerProgress,i=(100*r.controller.progress/r.controller.progressTotal).toFixed(0),s=o?r.memory.statistics.controllerProgressTotal-r.memory.statistics.controllerProgress+r.controller.progress:r.controller.progress-r.memory.statistics.controllerProgress,a=(100*s/r.controller.progressTotal).toFixed(1),n=(s/(Game.time-Memory.statistics.tick)).toFixed(2);if(e+="<li>Level "+r.RCL+", "+i+"% of "+r.controller.progressTotal+"<br/>( +"+s+" | +"+a+"% | +"+n+"/loop )"+(o?" <b><i>Upgraded!</i></b></li></ul>":"</li></ul>"),r.storage&&r.memory.statistics.store){let t=r.memory.statistics.store,o=r.storage.store;e+="<u>Storage</u><ul>";for(let r in t){let i=o[r]?o[r]-t[r]:-1*t[r];e+="<li>"+r+": "+(o[r]||0)+" ("+(i>-1?"+":"")+i+")</li>"}for(let r in o)t[r]||(e+="<li>"+r+": "+o[r]+" (+"+o[r]+")</li>");e+="</ul>"}r.memory.statistics.invaders&&r.memory.statistics.invaders.length>0&&(e+="<u>Invaders</u><ul>",_.forEach(r.memory.statistics.invaders,t),e+="</ul>"),e+="</li></ul>",Memory.statistics.reports.push(e)}else!r.controller.my&&r.controller.reservation&&(e="<ul><li><b>Room "+r.name+"</b><br/><u>Controller</u><ul><li>Reservation: "+r.controller.reservation.ticksToEnd+" for "+r.controller.reservation.username+"</li></ul></li></ul>",Memory.statistics.reports.push(e));let o=e=>void 0===e.leave,i=r.memory.statistics?_.filter(r.memory.statistics.invader,o):[];r.memory.statistics={tick:Game.time,time:Date.now(),store:r.storage?r.storage.store:null,controllerProgress:r.controller.progress,controllerProgressTotal:r.controller.progressTotal,invaders:i}}}),Memory.statistics.tick=Game.time,Memory.statistics.time=Date.now(),Memory.statistics.bucket=Game.cpu.bucket}),this.toTimeSpanString=((e,t)=>{let r=e.getTime()-t.getTime();r<0&&(r*=-1);let o,i=new Date(r),s=Math.floor(r/36e5),a=i.getMinutes(),n=i.getSeconds();return o=s>0?s+"h "+a+"m "+n+"s":a>0?a+"m "+n+"s":n>0?n+"s":"0"})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(2);t.default=new class extends o.Component{constructor(){super(...arguments),this.list=[],this.stale=[],this.fresh=(()=>{i.Install(Flag,{found:new o.EventConstructor,FlagRemoved:new o.EventConstructor}),_.forEach(Game.flags,e=>delete e.targetOf),this.list=[],this.stale=[],delete this._hasInvasionFlag}),this.register=(e=>{try{e.creeps={},e.cloaking>0&&e.cloaking--,this.list.push({name:e.name,color:e.color,secondaryColor:e.secondaryColor,roomName:e.pos.roomName,x:e.pos.x,y:e.pos.y,cloaking:e.cloaking})}catch(e){Log.error(e.stack||e.message)}}),this.analyze=(()=>(_.forEach(Game.flags,this.register),_.forEach(Memory.flags,(e,t)=>{try{Game.flags[t]||this.stale.push(t)}catch(e){Log.error(e.stack||e.message)}}),!!this.specialFlag(!0))),this.run=(()=>{this.list.forEach(e=>{try{if(!e.cloaking||0===e.cloaking){const t=Game.flags[e.name];Flag.found.trigger(t)}}catch(e){Log.error(e.stack||e.message)}}),this.stale.forEach(e=>Flag.FlagRemoved.trigger(e))}),this.cleanup=(()=>{this.stale.forEach(e=>delete Memory.flags[e])}),this.flagFilter=(e=>{if(!e)return;let t;return t=e.filter?_.clone(e.filter):{color:e.color,secondaryColor:e.secondaryColor}}),this.findName=((e,t,r=!0,o,i)=>{let s,a=this.list;if(!e||0===a.length)return null;if(t instanceof Room&&(t=t.getPositionAt(25,25)),_.isFunction(e))s=(o=>{if(e(o)&&0==o.cloaking){if(!r)return!0;if(t&&t.roomName&&o.roomName===t.roomName)return!0}return!1});else if(s=this.flagFilter(e),_.assign(s,{cloaking:"0"}),r&&t&&t.roomName){const e=Game.rooms[t.roomName];e?a=e.flags:_.assign(s,{roomName:t.roomName})}let n=_.filter(a,s);if(0===n.length)return null;if(1===n.length)return n[0].name;if(t&&t.roomName){let e=e=>{let r=0,s=Util.routeRange(t.roomName,e.roomName);return r=0===s?_.max([Math.abs(e.x-t.x),Math.abs(e.y-t.y)]):50*s,o&&(r=o(r,e,i)),e.valid=r<1/0,r},r=_.min(n,e);return r.valid?r.name:null}return n[0].name}),this.find=((e,t,r=!0,o,i)=>{t instanceof Room&&(t=t.getPositionAt(25,25));let s=this.findName(e,t,r,o,i);return null===s?null:Game.flags[s]}),this.removeFromDir=(e=>{let t=this.list.indexOf(t=>t.name===e);t>-1&&(this.list=this.list.splice(t,1))}),this.count=((e,t,r=!0)=>{let o=this.list;if(!e||0===this.list.length)return 0;t instanceof Room&&(t=t.getPositionAt(25,25));let i=this.flagFilter(e);if(r&&t&&t.roomName){const e=Game.flags[t.roomName];e?o=e.flags:_.assign(i,{roomName:t.roomName})}return _.countBy(o,i).true||0}),this.filter=((e,t,r=!0)=>{if(!e||0===this.list.length)return[];let o,i=this.list;if(t instanceof Room&&(t=t.getPositionAt(25,25)),Array.isArray(e))o=(o=>{if(r&&t&&t.roomName&&o.roomName!==t.roomName)return!1;for(let t=0;t<e.length;t++)if(this.compare(e[t],o))return!0;return!1});else if(o=this.flagFilter(e),r&&t&&t.roomName){const e=Game.rooms[t.roomName];e?i=e.flags:_.assign(o,{roomName:t.roomName})}return _.filter(i,o)}),this.rangeMod=((e,t,r)=>{let o,i=r&&r.rangeModPerCrowd?r.rangeModPerCrowd:20,s=r?r.rangeModByType:null,a=Game.flags[t.name];return o=a.targetOf?s?_.countBy(a.targetOf,"creepType")[s]||0:a.targetOf.length:0,e+o*i}),this.exploitMod=((e,t,r)=>{if(e>100)return 1/0;let o=Game.flags[t.name];if(o.room){if(o.room.my)return 1/0;let t=o.targetOf?_.sum(o.targetOf.map(e=>"privateer"!=e.creepType||e.creepName==r?0:e.carryCapacityLeft)):0;return o.room.sourceEnergyAvailable<=t?1/0:e*e/(o.room.sourceEnergyAvailable-t)}return e}),this.hasInvasionFlag=(()=>(_.isUndefined(this._hasInvasionFlag)&&(this._hasInvasionFlag=null!=this.findName(FLAG_COLOR.invade)||null!=this.findName(FLAG_COLOR.destroy)),this._hasInvasionFlag)),this.compare=((e,t)=>e.color===t.color&&e.secondaryColor===t.secondaryColor),this.flagType=(e=>{if(this.isSpecialFlag(e))return"_OCS";for(const t in FLAG_COLOR){const r=FLAG_COLOR[t];if(this.compare(e,r))return t;for(const o in r){const i=r[o];if(this.compare(e,i))return`${t}.${o}`}}return Log.error(`Unknown flag type for flag: ${e?e.name:"undefined flag"}.`),"undefined"}),this.specialFlag=(e=>{const t=Game.flags._OCS;if(e){if(!t)return _(Game.rooms).values().some(e=>(e.getPositionAt(49,49).newFlag({color:COLOR_WHITE,secondaryColor:COLOR_PURPLE},"_OCS"),!0));"W0N0"!==t.pos.roomName&&t.setPosition(new RoomPosition(49,49,"W0N0"))}return t}),this.isSpecialFlag=(e=>"_OCS"===e.name)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(11);t.default=new class extends o.Component{constructor(){super(...arguments),this.cache={},this.runCache={},this.tasks=[],this.extend=(()=>{this.tasks=[Task.attackController,Task.claim,Task.defense,Task.delivery,Task.guard,Task.labTech,Task.mining,Task.pioneer,Task.reputation,Task.reserve,Task.robbing,Task.safeGen,Task.scheduler]}),this.fresh=(()=>{this.tasks.forEach(e=>{e.fresh&&e.fresh()})}),this.register=(()=>{this.tasks.forEach(e=>{e.register&&e.register(),e.run&&!this.runCache[e.name]&&(this.runCache[e.name]={run:e.run}),e.handleFlagFound&&Flag.found.on(t=>e.handleFlagFound(t)),e.handleFlagRemoved&&Flag.FlagRemoved.on(t=>e.handleFlagRemoved(t)),e.handleSpawningStarted&&Creep.spawningStarted.on(t=>e.handleSpawningStarted(t)),e.handleSpawningCompleted&&Creep.spawningCompleted.on(t=>e.handleSpawningCompleted(t)),e.handleCreepDied&&(Creep.predictedRenewal.on(t=>e.handleCreepDied(t.name)),Creep.died.on(t=>e.handleCreepDied(t))),e.handleCreepError&&Creep.error.on(t=>e.handleCreepError(t)),e.handleNewInvader&&Room.newInvader.on(t=>e.handleNewInvader(t)),e.handleKnownInvader&&Room.knownInvader.on(t=>e.handleKnownInvader(t)),e.handleGoneInvader&&Room.goneInvader.on(t=>e.handleGoneInvader(t)),e.handleRoomDied&&Room.collapsed.on(t=>e.handleRoomDied(t))})}),this.run=(()=>{_.forEach(this.runCache,(e,t)=>{try{e.run()}catch(e){Log.error(`Error executing Task "${t}"<br>${e.stack||e.toString()}`)}})}),this.cleanup=((e,t,r)=>{this.removeQueued(this.memory(t,r),e),this.clearMemory(t,r)}),this.memory=((e,t)=>{const r=Util.get(Memory,["tasks",e,t],{});return delete r.queuedValid,delete r.runningValid,delete r.spawningValid,r}),this.removeQueued=((e,t)=>{const r=e=>{if(!_.isUndefined(e))for(const t of e){const e=Game.rooms[t.room];for(const r of["spawnQueueLow","spawnQueueMedium","spawnQueueHigh"]){const o=e[r],i=_.findIndex(o,{name:t.name});if(i>=0){o.splice(i,1);break}}}};if(t)for(const o of t)r(e[o]);else r(e)}),this.clearMemory=((e,t)=>{Memory.tasks[e]&&Memory.tasks[e][t]&&delete Memory.tasks[e][t]}),this.cache=((e,t)=>(this.cache[e]||(this.cache[e]={}),this.cache[e][t]||(this.cache[e][t]={}),this.cache[e][t])),this.clearCache=((e,t)=>{this.cache[e]&&this.cache[e][t]&&delete this.cache[e][t]}),this.spawn=((e,t,r,o)=>{let i=r.explicit?Game.rooms[r.explicit]:Room.findSpawnRoom(r);if(!i)return null;t||(t={}),!t.room&&r.targetRoom&&(t.room=r.targetRoom);let s={parts:Creep.compileBody(i,e),name:`${e.name||e.behaviour}-${t.targetName}`,behaviour:e.behaviour,destiny:t,queueRoom:i.name};return 0===s.parts.length?(Log.error("[Task]",`${t.task} task tried to queue a zero parts body ${e.behaviour} creep. Aborted.`),null):((i["spawnQueue"+e.queue]||i.spawnQueueLow).push(s),o&&o(s),s)}),this.addToQueue=((e,t,r)=>{if(t.link&&(t={targetRoom:t}),!t.targetRoom)return;const o={};return o.targetName=r?r.name||r.id:t.targetRoom,this.spawn(e,o,t)}),this.forceSpawn=((e,t,r)=>{if(t.link&&(t={targetRoom:t}),!t.targetRoom)return;const o=t.explicit?Game.rooms[t.explicit]:Room.findSpawnRoom(t);if(!o)return;const i={};i.targetName=r?r.name||r.id:t.targetRoom;const s=Creep.compileBody(o,e);if(!s.length)return;const a={parts:s,destiny:i,name:`${e.name||e.behaviour}-${i.targetName}`,behaviour:e.behaviour,queueRoom:o.name};return o.spawnQueueHigh.unshift(a),a}),this.validateQueued=((e,t,r,o={})=>{const i=o.subKey?"queued."+o.subKey:"queued",s=o.subKey?"nextQueuedCheck."+o.subKey:"nextQueuedCheck",a=Util.get(e,i,[]);let n=_.get(e,s,0);if(a.length&&(!o.checkValid||Game.time>n)){const t=o.queues||["Low"],r=[],l=e=>{if(!e)return;const o=Game.rooms[e.room];for(const i of t)if(o["spawnQueue"+i].some(t=>t.name===e.name)){r.push(e);break}};a.forEach(l),_.set(e,i,r),n=Game.time+50,Util.set(e,s,n,!1)}else 0===a.length&&(o.subKey&&e.nextQueuedCheck?delete e.nextQueuedCheck[o.subKey]:delete e.nextQueuedCheck);const l=_.get(t.memory,["nextCheck",r],1/0);t&&n-Game.time>0&&n<l&&(Log.flag(t,Dye(COLOR_PURPLE,"Task Queued:",r,`(next-check: ${n-Game.time}s later)`)),_.set(t.memory,["nextCheck",r],n))}),this.validateSpawning=((e,t,r,o={})=>{const i=o.subKey?"spawning."+o.subKey:"spawning",s=o.subKey?"nextSpawnCheck."+o.subKey:"nextSpawnCheck",a=Util.get(e,i,[]);let n=_.get(e,s,0);if(a.length&&(!o.checkValid||Game.time>n)){const t=[];let r;const l=e=>{if(!e)return;const o=Game.spawns[e.spawn];o&&(o.spawning&&o.spawning.name===e.name||o.newSpawn&&o.newSpawn.name===e.name)&&(r=!r||o.spawning.remainingTime<r?o.spawning.remainingTime:r,t.push(e))};a.forEach(l),_.set(e,i,t),r?(n=Game.time+r,Util.set(e,s,n,!1)):o.subKey&&e.nextSpawnCheck?delete e.nextSpawnCheck[o.subKey]:delete e.nextSpawnCheck}const l=_.get(t.memory,["nextCheck",r],1/0);t&&n-Game.time>0&&n<l&&(Log.flag(t,Dye(COLOR_YELLOW,"Task Spawning:",r,`(next-check: ${n-Game.time}s later)`)),_.set(t.memory,["nextCheck",r],n))}),this.validateRunning=((e,t,r,o={})=>{const i=o.subKey?"running."+o.subKey:"running",s=o.subKey?"nextRunningCheck."+o.subKey:"nextRunningCheck",a=Util.get(e,i,[]),n=o.roomName;let l=_.get(e,s,0);if(n&&a.length&&(!o.checkValid||Game.time>l)){const t=o.deadCreep||"",r=[];let m;const c=e=>{if(!e)return;const o=e.name||e,i=Game.creeps[o];if(!i||!i.data)return;let s;if(s=i.data.predictedRenewal?i.data.predictedRenewal:i.data.spawningTime?i.data.spawningTime+50*Util.routeRange(i.data.homeRoom,n):50*(Util.routeRange(i.data.homeRoom,n)+1),i.name!==t&&i.ticksToLive>s){const t=i.ticksToLive-s;m=!m||t<m?t:m,r.push(e)}};a.forEach(c),_.set(e,i,r),m?(l=Game.time+Math.min(TASK_CREEP_CHECK_INTERVAL,m),Util.set(e,s,l,!1)):o.subKey&&e.nextRunningCheck?delete e.nextRunningCheck[o.subKey]:delete e.nextRunningCheck}const m=_.get(t.memory,["nextCheck",r],1/0);t&&l-Game.time>0&&l<m&&(Log.flag(t,Dye(COLOR_GREEN,"Task Running:",r,`(next-check: ${l-Game.time}s later)`)),_.set(t.memory,["nextCheck",r],l))}),this.validateAll=((e,t,r,o={})=>{if(_.isUndefined(o.roomName))return Log.error("Task.validateAll","roomName undefined"+t+o.subKey);this.validateQueued(e,t,r,o),this.validateSpawning(e,t,r,o),this.validateRunning(e,t,r,o)}),this.forceCreepCheck=((e,t)=>{_.set(e.memory,["nextCheck",t],Game.time)}),this.nextCreepCheck=((e,t)=>{const r=_.get(e.memory,["nextCheck",t]);return!(r&&Game.time<r||(_.set(e.memory,["nextCheck",t],Game.time+TASK_CREEP_CHECK_INTERVAL),0))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("guard"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.defense)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.guard,{task:"guard",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:200,rangeRclRatio:1.8,allowTargetRoom:!0},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"guard"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"guard"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"guard"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.guard||(e.memory.tasks.guard={queued:[],spawning:[],running:[]}),e.memory.tasks.guard)),this.minControllerLevel=3,this.creep={guard:{fixedBody:[RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:2,[TOUGH]:1},name:"guard",behaviour:"ranger",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("defense"),this.handleNewInvader=(e=>{if(SPAWN_DEFENSE_ON_ATTACK&&!DEFENSE_BLACKLIST.includes(e.pos.roomName)){if(!e.room.my&&!e.room.reserved){let t=e=>Flag.compare(e,FLAG_COLOR.invade.exploit)||e.color==(FLAG_COLOR.claim.color||FLAG_COLOR.claim.mining);if(!Flag.find(t,e.pos,!0))return}e.room.defenseLevel.sum>e.room.hostileThreatLevel?Log.room(e.room,"Task Defense: room can handle that"):e.room.hostiles.forEach(this.orderDefenses)}}),this.handleGoneInvader=(e=>{if(!Game.getObjectById(e)){let t=this.memory(e);if(t&&t.defender){let r=t=>{let r=Memory.rooms[t.spawnRoom];if(r&&r.spawnQueueHigh){let t=t=>t.destiny&&"defense"===t.destiny.task&&t.destiny.invaderId===e,o=r.spawnQueueHigh.findIndex(t);o>-1&&r.spawnQueueHigh.splice(o,1)}};t.defender.forEach(r)}Task.clearMemory("defense",e)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!(t&&t.destiny&&t.destiny.task&&"defense"==t.destiny.task&&t.destiny.invaderId))return;let r=Game.getObjectById(t.destiny.invaderId);if(!r)return;let o=this.memory(t.destiny.invaderId);if(o.defender){let e=e=>e.order===t.destiny.order,r=o.defender.findIndex(e);r>-1&&o.defender.splice(r,1)}this.orderDefenses(r)}),this.memory=(e=>Task.memory("defense",e)),this.orderDefenses=(e=>{let t=e.id,r=e.threat,o=this.memory(t);if(o.defender){let e=e=>r-=e.threat;o.defender.forEach(e)}else o.defender=[];for(;r>0;){let o=Util.guid();this.creep.defender.queue="High",this.creep.defender.minThreat=1.1*r;let i=Task.spawn(this.creep.defender,{task:"defense",targetName:t,invaderId:t,spottedIn:e.pos.roomName,order:o},{targetRoom:e.pos.roomName,maxRange:4,minEnergyCapacity:800,allowTargetRoom:!0},e=>{this.memory(t).defender.push({spawnRoom:e.queueRoom,order:e.destiny.order}),Log.room(e.queueRoom,Dye(COLOR_ORANGE,`Defender queued for hostile creep ${e.destiny.order} in ${e.destiny.spottedIn}`))});if(!i)return void(LOG_TRACE&&Log.trace("Task",{task:"defense",invaderId:t,targetRoom:e.pos.roomName},"Unable to spawn. Invader will not get handled!"));{let e=Creep.bodyThreat(i.parts);r-=e}}}),this.nextAction=(e=>{if(Creep.action.defending.isValidAction(e)&&Creep.action.defending.isAddableAction(e)&&Creep.action.defending.assign(e))return;let t=Game.getObjectById(e.data.destiny.invaderId);if(t&&e.pos.roomName===t.pos.roomName)return void Creep.action.travelling.assign(e,t);let r=Game.rooms[e.data.destiny.spottedIn];if(!r||r.hostiles.length>0)return Creep.action.travelling.assignRoom(e,e.data.destiny.spottedIn);let o=e.room.adjacentRooms.find(e=>Game.rooms[e]&&Game.rooms[e].hostiles.length>0);if(o)return Creep.action.travelling.assignRoom(e,o);let i=Game.spawns[e.data.motherSpawn];i&&Creep.action.recycling.assign(e,i)}),this.creep={defender:{fixedBody:[RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:2,[TOUGH]:1},name:"defender",behaviour:"ranger"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("mining"),this.default={name:`default-${this.name}`},this.reserve={name:`reserve-${this.name}`,spawnParams:e=>{const t=this._carryPopulation(e.pos.roomName);return t<REMOTE_RESERVE_HAUL_CAPACITY?(LOG_TRACE&&Log.trace("Task",{flagName:e.name,pos:e.pos,population:t,spawnParams:"population",[this.name]:"spawnParams",Task:this.name}),{count:0,priority:"Low"}):Task.reserve.state.default.spawnParams(e)}},this.miner={name:`miner-${this.name}`,setup:e=>this.setupCreep(e,this.creep.miner),shouldSpawn:(e,t)=>e<t},this.hauler={name:`hauler-${this.name}`,ept:e=>{const t=Game.rooms[e];return t?10*t.sources.length:20},homeRoomName:e=>{const t=this.memory(e);return t.storageRoom?t.storageRoom:Room.bestSpawnRoomFor(e).name},spawnRoom:(e,t)=>Room.findSpawnRoom({targetRoom:e,minEnergyCapacity:t||500}),maxWeight:(e,t,r,o,i)=>{t||(t=this.state.hauler.homeRoomName(e)),r||(r=this.memory(e));const s=o?[]:_.map(r.running.remoteHauler,e=>Game.creeps[e]),a=i?[]:_.union(r.queued.remoteHauler,r.spawning.remoteHauler),n=(Game.rooms[e],Util.routeRange(e,t)),l=this.state.hauler.ept(e),m=_.filter(s,e=>!this.needsReplacement(e)),c=_.sum(m,e=>e&&e.data&&e.data.body?e.data.body.carry:5),u=_.sum(a,e=>e&&e.body?e.body.carry:5),d=l*n*2+(r.carryParts||0)-c-u,h=this._haulerCarryToWeight(d);return LOG_TRACE&&Log.trace("Task",{Task:this.name,room:e,homeRoom:t,haulers:s.length+a.length,ept:l,travel:n,existingCarry:c,queuedCarry:u,neededCarry:d,maxWeight:h,[this.name]:"maxWeight"}),h}},this.handleFlagRemoved=(e=>{const t=Memory.flags[e];if(t&&t.task===this.name&&t.roomName){const e=Flag.filter(FLAG_COLOR.claim.mining,new RoomPosition(25,25,t.roomName),!0);if(e&&e.length>0)return}Task.cleanup(["remoteMiner","remoteWorker","remoteHauler"],this.name,t.roomName)}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim.mining)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"roomName",e.pos.roomName),Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;const t=this.memory(e.destiny.room),r=Game.flags[e.destiny.targetName];if(r){const o=_.find(this.creep,{behaviour:e.destiny.type}).queue;Task.validateQueued(t,r,this.name,{subKey:e.destiny.type,queues:[o]}),e.body&&(e.body=_.countBy(e.body)),t.spawning[e.destiny.type].push(e)}}),this.handleSpawningCompleted=(e=>{if(!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);const t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,e.data.destiny.room);const r=this.memory(e.data.destiny.room);r.running[e.data.destiny.type].push(e.name),Task.validateSpawning(r,t,this.name,{roomName:e.data.destiny.room,subKey:e.data.destiny.type})}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;const r=Game.flags[t.destiny.targetName];if(r){const o=this.memory(t.destiny.room);Task.validateRunning(o,r,this.name,{subKey:t.creepType,roomName:t.destiny.room,deadCreep:e})}}),this.needsReplacement=(e=>!e||(e.ticksToLive||CREEP_LIFE_TIME)<(e.data.predictedRenewal||0)),this.checkForRequiredCreeps=(e=>{const t=e.pos.roomName,r=Game.rooms[t],o=this.memory(t);let i;i=r?r.sources.length:Memory.rooms[t]&&Memory.rooms[t].sources?Memory.rooms[t].sources.length:1;const s=r=>{const i=_.find(this.creep,{behaviour:r}).queue;return Task.validateAll(o,e,this.name,{roomName:t,subKey:r,queues:[i],checkValid:!0,task:this.name}),o.queued[r].length+o.spawning[r].length+o.running[r].length},a=s("remoteHauler"),n=s("remoteMiner"),l=s("remoteWorker");if(LOG_TRACE&&Log.trace("Task",{Task:this.name,flagName:e.name,sourceCount:i,haulerCount:a,minerCount:n,workerCount:l,[this.name]:"Flag.found"},"checking flag@",e.pos),this.state.miner.shouldSpawn(n,i)){LOG_TRACE&&Log.trace("Task",{Task:this.name,room:t,minerCount:n,minerTTLs:_.map(_.map(o.running.remoteMiner,e=>Game.creeps[e]),"ticksToLive"),[this.name]:"minerCount"});const r=this.state.miner.setup(t);for(let o=n;o<i;o++)Task.spawn(r,{task:this.name,targetName:e.name,type:r.behaviour},{targetRoom:t,minEnergyCapacity:r.minEnergyCapacity,rangeRclRatio:1},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}const m=Math.ceil(o.running.remoteMiner.length*REMOTE_HAULER.MULTIPLIER);if(a<m&&(!o.capacityLastChecked||Game.time-o.capacityLastChecked>TASK_CREEP_CHECK_INTERVAL))for(let r=a;r<m;r++){let i=r>=1&&REMOTE_HAULER.MIN_WEIGHT;const s=this.state.hauler.spawnRoom(t,i);if(!s)break;const a=REMOTE_HAULER.REHOME?this.state.hauler.homeRoomName(t):s.name;let n=this.state.hauler.maxWeight(t,a,o);if(!n||!REMOTE_HAULER.ALLOW_OVER_CAPACITY&&n<i){o.capacityLastChecked=Game.time;break}_.isNumber(REMOTE_HAULER.ALLOW_OVER_CAPACITY)?(n=Math.max(n,REMOTE_HAULER.ALLOW_OVER_CAPACITY),i=i&&Math.min(REMOTE_HAULER.MIN_WEIGHT,n)):REMOTE_HAULER.ALLOW_OVER_CAPACITY&&(n=Math.max(n,REMOTE_HAULER.MIN_WEIGHT),i=i&&Math.min(REMOTE_HAULER.MIN_WEIGHT,n));const l=_.create(this.creep.hauler);l.maxWeight=n,i&&(l.minWeight=i),Task.spawn(l,{task:this.name,targetName:e.name,type:this.creep.hauler.behaviour,homeRoom:a},{targetRoom:t,explicit:s.name},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name,body:_.countBy(e.parts)})})}if(r&&r.myConstructionSites.length>0&&l<REMOTE_WORKER_MULTIPLIER)for(let r=l;r<REMOTE_WORKER_MULTIPLIER;r++)Task.spawn(this.creep.worker,{task:this.name,targetName:e.name,type:this.creep.worker.behaviour},{targetRoom:t,minEnergyCapacity:600},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}),this.findSpawning=((e,t)=>{const r=[];return _.forEach(Game.spawns,o=>{if(o.spawning&&(_.includes(o.spawning.name,t)||o.newSpawn&&_.includes(o.newSpawn.name,t))){const t=Population.getCreep(o.spawning.name);if(t&&t.destiny.room===e){const e={spawn:o.name,name:o.spawning.name,destiny:t.destiny};r.push(e)}}}),r}),this.findRunning=((e,t)=>{const r=[];return _.forEach(Game.creeps,o=>{!o.spawning&&o.data.creepType===t&&o.data&&o.data.destiny&&o.data.destiny.room===e&&r.push(o.name)}),r}),this.memory=(e=>{const t=Task.memory(this.name,e);return t.hasOwnProperty("queued")||(t.queued={remoteMiner:[],remoteHauler:[],remoteWorker:[]}),t.hasOwnProperty("spawning")||(t.spawning={remoteMiner:this.findSpawning(e,"remoteMiner"),remoteHauler:this.findSpawning(e,"remoteHauler"),remoteWorker:this.findSpawning(e,"remoteWorker")}),t.hasOwnProperty("running")||(t.running={remoteMiner:this.findRunning(e,"remoteMiner"),remoteHauler:this.findRunning(e,"remoteHauler"),remoteWorker:this.findRunning(e,"remoteWorker")}),t.hasOwnProperty("nextSpawnCheck")||(t.nextSpawnCheck={}),t.queued.miner&&(t.queued.remoteMiner=t.queued.miner,delete t.queued.miner),t.queued.hauler&&(t.queued.remoteHauler=t.queued.hauler,delete t.queued.hauler),t.queued.worker&&(t.queued.remoteWorker=t.queued.worker,delete t.queued.worker),t}),this.setupCreep=((e,t)=>{switch(t.behaviour){default:return t;case"remoteMiner":const r=this.memory(e);if(!r.harvestSize)return t;const o=e=>e===WORK,i=_.reject(t.fixedBody,o),s=_.sum(t.fixedBody,o)+r.harvestSize;return _.create(t,{fixedBody:_.times(s,_.constant(WORK)).concat(_.times(Math.ceil(.5*r.harvestSize),_.constant(MOVE))).concat(i),moveBalance:r.harvestSize%2*-.5})}}),this._carryPopulation=((e,t)=>1-this.state.hauler.maxWeight(e,t,void 0,!1,!0)/this.state.hauler.maxWeight(e,t,void 0,!0,!0)),this._haulerCarryToWeight=(e=>{if(!e||e<0)return 0;const t=_.max([0,e-5]);return 500+150*_.ceil(.5*t)}),this.getFlag=(e=>Flag.find(FLAG_COLOR.claim.mining,new RoomPosition(25,25,e))),this.carry=((e,t)=>{const r=this.memory(e);r.carryParts=(r.carryParts||0)+(t||0);const o=Math.round(100*this._carryPopulation(e));return t&&(Task.forceCreepCheck(this.getFlag(e),this.name),delete r.capacityLastChecked),`Task.${this.name}: hauler carry capacity for ${e} ${r.carryParts>=0?"increased":"decreased"} by ${Math.abs(r.carryParts)}. Currently at ${o}% of desired capacity`}),this.harvest=((e,t)=>{const r=this.memory(e);return r.harvestSize=(r.harvestSize||0)+(t||0),`Task.${this.name}: harvesting work capacity for ${e} ${r.harvestSize>=0?"increased":"decreased"} by ${Math.abs(r.harvestSize)} per miner.`}),this.storage=((e,t)=>{Game.rooms[e];const r=this.memory(e);if(t){const o=r.storageRoom;return r.storageRoom=t,`Task.${this.name}: room ${e}, now sending haulers to ${t}, (was ${o})`}if(r.storageRoom){if(!1===t){const t=r.storageRoom;return delete r.storageRoom,`Task.${this.name}: room ${e}, cleared custom storage room (was ${t})`}return`Task.${this.name}: room ${e}, sending haulers to ${r.storageRoom}`}return`Task.${this.name}: room ${e}, no custom storage destination`}),this.state={default:this.default,reserve:this.reserve,miner:this.miner,hauler:this.hauler},this.minControllerLevel=2,this.creep={miner:{fixedBody:{[MOVE]:1,[WORK]:5},multiBody:[MOVE,MOVE,WORK,CARRY],maxMulti:1,minEnergyCapacity:550,behaviour:"remoteMiner",queue:"Medium"},hauler:{fixedBody:{[CARRY]:5,[MOVE]:3,[WORK]:1},multiBody:[CARRY,CARRY,MOVE],behaviour:"remoteHauler",queue:"Low"},worker:{fixedBody:{[CARRY]:3,[MOVE]:4,[WORK]:4},multiBody:{[CARRY]:1,[MOVE]:2,[WORK]:2},maxMulti:3,behaviour:"remoteWorker",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("claim"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.claimer,{task:"claim",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:650},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"claim"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"claim"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"claim"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.claim||(e.memory.tasks.claim={queued:[],spawning:[],running:[]}),e.memory.tasks.claim)),this.nextAction=(e=>{let t=[Creep.action.claiming,Creep.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}}),this.minControllerLevel=3,this.creep={claimer:{fixedBody:[CLAIM,MOVE],multiBody:[],name:"claimer",behaviour:"claimer",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("reserve"),this.VALID_RESERVATION=1e3,this.URGENT_RESERVATION=250,this.default={name:`default-${this.name}`,spawnParams:e=>{const t={count:0,queue:"Low"},r=!!e,o=r&&(Room.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller);if(!r||!o)return LOG_TRACE&&Log.trace("Task",{hasFlag:r,hasController:o,checkForRequiredCreeps:"skipping room, missing flag or controller",[this.name]:"checkForRequiredCreeps",Task:this.name}),t;if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=e.room.controller.reservation&&(e.room.controller.reservation.ticksToEnd>1e3||e.room.controller.reservation.username!==ME),o=!!e.room.controller.owner;if(o||r)return LOG_TRACE&&Log.trace("Task",{validReservation:r,isOwned:o,checkForRequiredCreeps:"skipping room, reserved or owned",[this.name]:"checkForRequiredCreeps",Task:this.name}),t;const i=!e.room.controller.reservation||e.room.controller.reservation.ticksToEnd<250;if(t.count=1,i&&(t.queue="Medium"),LOG_TRACE){const e=i?"urgent":" ";Log.trace("Task",{validReservation:r,isOwned:o,urgent:i,checkForRequiredCreeps:`sending${e}reserver`,[this.name]:"checkForRequiredCreeps",Task:this.name})}}else(_.isUndefined(e.memory.lastVisible)||Game.time-e.memory.lastVisible>(e.memory.ticksToEnd-250||250))&&(t.count=1,t.queue="Medium",LOG_TRACE&&Log.trace("Task",{lastVisible:e.memory.lastVisible,tickToEnd:e.memory.ticksToEnd,checkForRequiredCreeps:"sending urgent reserver, no visibility",[this.name]:"checkForRequiredCreeps",Task:this.name}));return t}},this.handleFlagFound=(e=>{if((e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&(Room.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller)){const t=this.memory(e);if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=_.get(e.memory,["nextCheck",this.name],1/0),o=Game.time+e.memory.ticksToEnd-this.VALID_RESERVATION;o<r&&!t.waitForCreeps&&(0===t.queued.length+t.spawning.length+t.running.length?_.set(e.memory,["nextCheck",this.name],o):t.waitForCreeps=!0)}Task.nextCreepCheck(e,this.name)&&(delete t.waitForCreeps,Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}}),this.handleFlagFound=(e=>{if((e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&(Room.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller)){const t=this.memory(e);if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=_.get(e.memory,["nextCheck",this.name],1/0),o=Game.time+e.memory.ticksToEnd-this.VALID_RESERVATION;o<r&&!t.waitForCreeps&&(0===t.queued.length+t.spawning.length+t.running.length?_.set(e.memory,["nextCheck",this.name],o):t.waitForCreeps=!0)}Task.nextCreepCheck(e,this.name)&&(delete t.waitForCreeps,Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}}),this.checkForRequiredCreeps=(e=>{let t;e.compareTo(FLAG_COLOR.claim.mining)?t=Task.mining.state.reserve.spawnParams(e):e.compareTo(FLAG_COLOR.invade.exploit)?(t=this.state.default.spawnParams(e)).queue="Low":t=this.state.default.spawnParams(e);let r=this.memory(e);if(Task.validateAll(r,e,this.name,{roomName:e.pos.roomName,queues:["Low","Medium"],checkValid:!0}),"Low"!==t.queue&&1==r.queued.length){let e=Game.rooms[r.queued[0].room],t=(t,o)=>{if(t.targetName==r.queued[0].targetName){let t=e.spawnQueueLow.splice(o,1);return e.spawnQueueMedium.push(t),!0}return!1};e.spawnQueueLow.find(t)}r.queued.length+r.spawning.length+r.running.length<t.count&&(this.creep.reserver.queue=t.queue,Task.spawn(this.creep.reserver,{task:this.name,targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:1300,maxRange:this.spawnRoomMaxRange},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})}))}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t);Task.validateQueued(r,t,this.name,{queues:["Low","Medium"]}),r.spawning.push(e)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;let t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);Task.validateSpawning(r,t,this.name),r.running.push(e.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;let r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.nextAction=(e=>{if(e.data.destiny&&e.data.destiny.room!==e.room.name)return Creep.action.travelling.assignRoom(e,e.data.destiny.room);let t=[Creep.action.reserving,Creep.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))break}LOG_TRACE&&Log.trace("Task",{creepName:e.name,nextAction:e.action.name,[this.name]:"nextAction",Task:this.name})}),this.memory=(e=>{const t=Util.get(e.memory,["tasks","reserve"],{queued:[],spawning:[],running:[]});return delete t.valid,t}),this.state={default:this.default},this.spawnRoomMaxRange=6,this.creep={reserver:{fixedBody:{[CLAIM]:2,[MOVE]:2},multiBody:[CLAIM,MOVE],maxMulti:7,name:"reserver",behaviour:"claimer"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("pioneer"),this.handleRoomDied=(e=>{if(e.population&&e.population.typeCount.collapseWorker)return;let t=!0;if(e.energyAvailable>199){e.spawnQueueHigh.splice(0,e.spawnQueueHigh.length);const r=this.creep.worker;t=!Task.spawn(r,{task:"collapseWorker",targetName:e.name,type:r.behaviour},{explicit:e.name})}t&&(Flag.find(FLAG_COLOR.claim.pioneer,e)||e.newFlag(FLAG_COLOR.claim.pioneer))}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim.pioneer)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{if(!e||e.room&&!e.room.my&&!e.room.reserved){if(!PIONEER_UNOWNED)return Log.error("Pioneer room not owned:",e.room,Log.stack());const t=e.room.owner||e.room.reservation;if(t&&!Task.reputation.isAlly(t))return Log.error(`Pioneer target room ${e.room} owned by ${t}`)}let t=this.memory(e);if(Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,subKey:"pioneer",checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1){const t=this.creep.pioneer;Task.spawn(t,{task:"pioneer",targetName:e.name,flagName:e.name,type:t.behaviour},{targetRoom:e.pos.roomName,minEnergyCapacity:400,rangeRclRatio:2},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"pioneer"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e);const o=e.destiny.type,i=o?_.find(this.creep,{behaviour:o}).queue:["Low","High"];Task.validateQueued(r,t,this.name,{queues:[i]})}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"pioneer"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"pioneer"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){let t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.pioneer||(e.memory.tasks.pioneer={queued:[],spawning:[],running:[]}),e.memory.tasks.pioneer)),this.creep={pioneer:{fixedBody:{[CARRY]:2,[MOVE]:2,[WORK]:2},multiBody:[WORK,MOVE,CARRY],name:"pioneer",behaviour:"pioneer",queue:"Low"},worker:{fixedBody:[MOVE,CARRY,WORK],behaviour:"collapseWorker",queue:"High"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("attackController"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.invade.attackController)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{const t=e.pos.roomName;Game.rooms[t];let r=this.memory(e);Task.validateAll(r,e,this.name,{roomName:t,checkValid:!0}),r.queued.length+r.spawning.length+r.running.length<1&&Task.spawn(this.creep.attackController,{task:"attackController",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:3250,maxRange:5},e=>{r.queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"attackController"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"attackController"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"attackController"!=t.destiny.task)return;let r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.attackController||(e.memory.tasks.attackController={queued:[],spawning:[],running:[]}),e.memory.tasks.attackController)),this.nextAction=(e=>{let t=[Creep.action.attackController,Creep.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}}),this.creep={attackController:{fixedBody:[],multiBody:{[CLAIM]:5,[MOVE]:5},minMulti:1,maxMulti:4,name:"Atk-Contr",behaviour:"claimer",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("robbing"),this.default={name:`default-${this.name}`},this.robber={name:`robber-${this.name}`,homeRoom:e=>{const t=this.memory(e);return t.storageRoom?Game.rooms[t.storageRoom]:Room.bestSpawnRoomFor(e.pos.roomName)},spawnRoom:({roomName:e,minWeight:t})=>Room.findSpawnRoom({targetRoom:e,minEnergyCapacity:t||250})},this.checkFlag=(e=>!(e.room&&e.room.my)&&e.compareTo(FLAG_COLOR.invade.robbing)&&Task.nextCreepCheck(e,this.name)),this.handleFlagFound=(e=>{this.checkFlag(e)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0});const r=t.queued.length+t.spawning.length+t.running.length,o=e.pos.roomName;if(r<(t.numRobbers||2)){const t=this.robber.spawnRoom({roomName:o});if(!t)return;const r=ROBBER_REHOME?this.robber.homeRoom(e):t;Task.spawn(this.creep.robbing,{task:this.name,targetName:e.name,homeRoom:r.name},{targetRoom:o,explicit:t.name},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"robbing"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"robbing"!=e.data.destiny.task)return;e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"robbing"!=t.destiny.task)return;let r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.robbing||(e.memory.tasks.robbing={queued:[],spawning:[],running:[],numRobbers:2}),e.memory.tasks.robbing)),this.nextAction=(e=>{let t=e.sum;if(e.pos.roomName==e.data.homeRoom){if(t>0){LOG_TRACE&&Log.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"storing?",robbing:"nextAction",Task:"robbing"});let r=[];if(e.carry.energy==t&&(r=e.room.structures.links.privateers),e.room.storage&&r.push(e.room.storage),e.room.structures.container&&(r=r.concat(e.room.structures.container.privateers)),r.length>0){let t=e.pos.findClosestByRange(r);if(t.structureType==STRUCTURE_STORAGE&&Creep.action.storing.assign(e,t))return;if(Creep.action.charging.assign(e,t))return}if(Creep.action.charging.assign(e))return;if(!e.room.ally&&Creep.action.storing.assign(e))return;if(Creep.action.dropping.assign(e))return;return void Creep.behaviour.worker.nextAction(e)}return Task[e.data.destiny.task].exploitNextRoom(e)?void(LOG_TRACE&&Log.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"travelling",robbing:"nextAction",Task:"robbing"})):(LOG_TRACE&&Log.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"working",robbing:"nextAction",Task:"robbing"}),void Creep.behaviour.worker.nextAction(e))}if(!e.flag||e.flag.pos.roomName!==e.pos.roomName)return LOG_TRACE&&Log.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"travelling2",robbing:"nextAction",Task:"robbing"}),void Task[e.data.destiny.task].exploitNextRoom(e);if(LOG_TRACE&&Log.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"robbing",robbing:"nextAction",Task:"robbing"}),e.sum<.4*e.carryCapacity){let t=[Creep.action.picking,Creep.action.robbing];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}return e.flag&&(e.flag.cloaking=50),void Task[e.data.destiny.task].exploitNextRoom(e)}this.goHome(e)}),this.exploitNextRoom=(e=>{if(e.sum<.4*e.carryCapacity){let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t||(t=this.getFlag(e.data.homeRoom)),t)return this.gotoTargetRoom(e,t)}return this.goHome(e)}),this.goHome=(e=>(Population.registerCreepFlag(e,null),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!1)),this.getFlag=(e=>Flag.find(e=>e.color==FLAG_COLOR.invade.robbing.color&&e.secondaryColor==FLAG_COLOR.invade.robbing.secondaryColor,new RoomPosition(25,25,e),!1)),this.storage=((e,t)=>{const r=this.memory(this.getFlag(e));if(t){const o=r.storageRoom;return r.storageRoom=t,`Task.${this.name}: room ${e}, now sending haulers to ${t}, (was ${o})`}if(r.storageRoom){if(!1===t){const t=r.storageRoom;return delete r.storageRoom,`Task.${this.name}: room ${e}, cleared custom storage room (was ${t})`}return`Task.${this.name}: room ${e}, sending haulers to ${r.storageRoom}`}return`Task.${this.name}: room ${e}, no custom storage destination`}),this.gotoTargetRoom=((e,t)=>{if(Creep.action.travelling.assignRoom(e,t.pos.roomName))return Population.registerCreepFlag(e,t),!0}),this.creep={robbing:{fixedBody:[WORK,CARRY,MOVE,MOVE],multiBody:[CARRY,MOVE],name:"robber",behaviour:"privateer",queue:"Low"}},this.state={default:this.default,robber:this.robber}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1),i={"Source Keeper":!0,Invader:!0},s={MY_SCORE:1e3,WHITELIST_SCORE:200,ALLY:100,NEUTRAL:1,NPC_SCORE:-200};t.default=new class extends o.TaskComponent{constructor(){super("reputation"),this.myName=(()=>ME),this.isNPC=(e=>!0===i[e]),this.npcOwner=(e=>e.owner&&this.isNPC(e.owner.username)),this.isAlly=(e=>this.score(e)>=s.ALLY),this.notAlly=(e=>!this.isAlly(e)),this.allyOwner=(e=>e.owner&&this.isAlly(e.owner.username)),this.isHostile=(e=>this.score(e)<s.NEUTRAL),this.notHostile=(e=>!this.isHostile(e)),this.hostileOwner=(e=>e.owner&&this.isHostile(e.owner.username)),this.whitelist=(()=>this.cache("whitelist")),this.whitelist=(()=>this.cache("whitelist")),this.score=(e=>{const t=this.cache("score");if(void 0===e)return t;const r=e&&e.toLowerCase();return t[r]?t[r]:t[r]=0}),this.setScore=((e,t)=>{const r=e&&e.toLowerCase();this.score()[r]=t,this.playerMemory(r).score=t}),this.fresh=(()=>{this._loadWhitelist(),this._loadScore()}),this.cache=(e=>Task.cache(this.name,e)),this.killScoreCache=(()=>(Task.clearCache(this.name,"score"),this.score())),this.killWhitelistCache=(()=>(Task.clearCache(this.name,"score"),Task.clearCache(this.name,"whitelist"),this.whitelist())),this.memory=(e=>Task.memory(this.name,e)),this.playerMemory=(e=>{const t=this.memory("players"),r=e&&e.toLowerCase();return t[r]?t[r]:t[r]={}}),this._loadScore=(()=>{const e=this.cache("etc"),t=this.memory("players"),r=this.whitelist();let o=this.score();if(_.keys(t).length+_.keys(r).length!==_.keys(o).length+e.whitelistRepUnion){o=this.killScoreCache();for(const e in i)o[e]=s.NPC_SCORE;_.keys(r).forEach(e=>{o[e]=s.WHITELIST_SCORE}),e.whitelistRepUnion=0,_.reduce(t,(t,o,i)=>("number"==typeof o.score&&(r[i]&&e.whitelistRepUnion++,t[i]=o.score),t),o),this.setScore(this.myName(),s.MY_SCORE)}}),this._loadWhitelist=(()=>{let e=this.whitelist();_.keys(e).length!==PLAYER_WHITELIST.length&&(e=this.killWhitelistCache(),_.forEach(PLAYER_WHITELIST,t=>{e[t.toLowerCase()]=!0}))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("delivery"),this.memory=(e=>{let t=Task.memory(this.name,e);return t.hasOwnProperty("queued")||(t.queued=[]),t.hasOwnProperty("spawning")||(t.spawning=[]),t.hasOwnProperty("running")||(t.running=[]),t}),this.memoryKey=(e=>{const t=Game.flags[e.destiny.targetName];return t&&t.pos.roomName}),this.checkFlag=(e=>e.room&&e.room.my&&e.compareTo(FLAG_COLOR.invade.robbing)&&Task.nextCreepCheck(e,this.name)),this.handleFlagFound=(e=>{this.checkFlag(e)&&this.checkForRequiredCreeps(e)}),this.maxCreeps=(e=>e.room&&e.room.storage?Math.floor(2*e.room.storage.charge):1),this.checkForRequiredCreeps=(e=>{const t=this.memory(e.pos.roomName);if(Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length>0)return;const r=this.maxCreeps(e);if(t.running.length<r){const t=Flag.find(FLAG_COLOR.claim.delivery,e.pos);let r=t&&t.pos.roomName;if(!r){const t=Room.findSpawnRoom({targetRoom:e.pos.roomName});if(!t)return;r=t.name}Task.spawn(this.creep.recycler,{task:this.name,targetName:e.name,targetRoom:r},{explicit:e.pos.roomName,targetRoom:r,minEnergyCapacity:100},e=>{this.memory(Game.flags[e.destiny.targetName].pos.roomName).queued.push({room:e.queueRoom,name:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t.pos.roomName);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;e.data.homeRoom=e.data.destiny.homeRoom||e.data.homeRoom,e.data.travelRoom=e.data.destiny.targetRoom||e.data.travelRoom;let t=Game.flags[e.data.destiny.targetName];if(t){let r=this.memory(t.pos.roomName);Task.validateSpawning(r,t,this.name),e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName),r.running.push(e.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;const r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r.pos.roomName);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.minControllerLevel=4,this.creep={recycler:{fixedBody:[CARRY,MOVE],multiBody:[CARRY,MOVE],name:"recycler",behaviour:"recycler",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("labTech"),this.register=(()=>{Flag.found.on(e=>this.handleFlagFound(e)),Creep.spawningStarted.on(e=>this.handleSpawningStarted(e)),Creep.spawningCompleted.on(e=>this.handleSpawningCompleted(e)),Creep.predictedRenewal.on(e=>this.handleCreepDied(e.name)),Creep.died.on(e=>this.handleCreepDied(e))}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.labs.labTech)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{const t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.labTech,{task:"labTech",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:1e3,maxRange:1,allowTargetRoom:!0},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"labTech"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){const r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"labTech"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);const r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"labTech"!=t.destiny.task)return;const r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.labTech||(e.memory.tasks.labTech={queued:[],spawning:[],running:[]}),e.memory.tasks.labTech)),this.creep={labTech:{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],name:"labTech",behaviour:"labTech",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("safeGen"),this.handleFlagFound=(e=>{if(e.compareTo(FLAG_COLOR.command.safeGen)&&Task.nextCreepCheck(e,this.name)){const t=Game.rooms[e.pos.roomName];t&&(t.storage&&t.storage.store[RESOURCE_GHODIUM]>=1e3||t.terminal&&t.terminal.store[RESOURCE_GHODIUM]>=1e3)?(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e)):e.remove()}}),this.checkForRequiredCreeps=(e=>{const t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.safeGen,{task:"safeGen",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:2e3,maxRange:1,allowTargetRoom:!0},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"safeGen"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){const r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"safeGen"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);const r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"safeGen"!=t.destiny.task)return;const r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.safeGen||(e.memory.tasks.safeGen={queued:[],spawning:[],running:[]}),e.memory.tasks.safeGen)),this.minControllerLevel=6,this.creep={safeGen:{multiBody:[CARRY,MOVE],maxMulti:20,maxWeight:2e3,name:"safeGen",behaviour:"safeGen",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("scheduler"),this.processes={example:{conditions:()=>!1,run:()=>{console.log("Hello!")}}},this.run=(()=>{_.forEach(this.processes,(e,t)=>{e.conditions()&&e.run()})}),this.registerProcess=((e,t,r)=>{this.processes[e]?(this.processes[e].conditions=t,this.processes[e].run=r):this.processes[e]={conditions:t,run:r}}),this.unregisterProcess=(e=>{this.processes[e]&&delete this.processes[e]}),this.forceRunProcess=(e=>{let t=this.processes[e];t&&t.conditions()&&t.run()})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("attackController"),this.isValidAction=(e=>!0),this.isValidTarget=((e,t)=>e&&(!e.reservation||!Task.reputation.allyOwner(e.reservation))&&t.flag),this.isAddableAction=(()=>!0),this.isAddableTarget=(e=>e&&(e instanceof Flag||"controller"===e.structureType&&(e.reservation||e.owner))),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.targetName]),t||(t=Flag.find(e=>Flag.compare(e,FLAG_COLOR.invade.attackController),e.pos,!1,Flag.reserveMod,e.name)),t?(Population.registerCreepFlag(e,t),e.flag.room&&e.flag.pos.roomName==e.pos.roomName?e.flag.room.controller:e.flag):null}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),void e.travelTo(e.target);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e})}else e.travelTo(e.target)}),this.work=(e=>{let t;return e.controllerSign(),t=e.target.owner&&!e.target.my||e.target.reservation&&!Task.reputation.allyOwner(e.target.reservation)?e.attackController(e.target):e.claimController(e.target)}),this.setDefault({moveOptions:e=>e})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("avoiding"),this.targetRange=0,this.reachedRange=0,this.lairDangerTime=24,this.lairDangerRange=14,this.isActiveLair=(e=>!_.isUndefined(e.ticksToSpawn)&&e.ticksToSpawn<=this.lairDangerTime),this.isValidAction=(e=>e.data.destiny&&e.data.destiny.room===e.room.name&&(Room.isSKRoom(e.room.name)||e.room.situation.invasion)),this.isAddableAction=(e=>!0),this.isValidTarget=((e,t)=>Task.reputation.npcOwner(e)?_.isUndefined(e.ticksToSpawn)||this.isActiveLair(e):!(!Task.reputation.hostileOwner(e)||!e.hasActiveBodyparts)&&e.hasActiveBodyparts([ATTACK,RANGED_ATTACK])),this.newTarget=(e=>{if(Room.isSKRoom(e.pos.roomName)){const t=_.first(e.room.find(FIND_STRUCTURES,{filter:t=>this.isActiveLair(t)&&e.pos.getRangeTo(t.pos)<=this.lairDangerRange}));if(t)return t}if(e.room.situation.invasion){const t=_.chain(e.room.hostiles).filter(e=>this.isValidTarget(e)).map(t=>{let r=0;const o=e.pos.getRangeTo(t);return{target:t,score:r="Invader"===e.owner.username?o-51:o<10?o-11:0}}).filter("score").sortBy("score").first().get("target").value();if(t)return t}}),this.work=(e=>{if(!e.data.safeSpot||!e.data.safeSpot.roomName){const t=e.data.destiny&&Game.flags[e.data.destiny.targetName];if(t)e.data.safeSpot=t.pos;else{const t=_.chain(e.room.findRoute(e.data.homeRoom)).first().get("exit").value();t&&(e.data.safeSpot=e.pos.findClosestByRange(t),e.data.safeSpot.roomName=e.pos.roomName)}}e.data.safeSpot&&(e.pos.getRangeTo(e.target)<10?e.travelTo(e.data.safeSpot):e.idleMove())}),this.run=(e=>{if(this.isValidAction(e)&&(e.action===this&&this.isValidTarget(e.target,e)||this.isAddableAction(e)&&this.assign(e)))return!!e.leaveBorder()||(this.work(e),!0)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("boosting"),this.maxPerAction=1,this.isValidMineralType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}),this.isValidMineralType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}),this.getBoostPartType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return t}),this.canBoostType=((e,t)=>!_(e.body).filter({type:t}).every(e=>e.boost)),this.isValidAction=(e=>!_.every(e.body,e=>e.boost)),this.isValidTarget=((e,t)=>e instanceof StructureLab&&e.active&&e.energy>=LAB_BOOST_ENERGY&&e.mineralAmount>=LAB_BOOST_MINERAL),this.newTarget=(e=>_(e.room.structures.labs.all).filter(this.isValidTarget).filter(t=>this.isAddableTarget(t,e)).min(t=>e.pos.getRangeTo(t))),this.work=(e=>e.target.boostCreep(e)),this.onAssignment=(e=>{SAY_ASSIGNMENT&&e.say(ACTION_SAY.BOOSTING,SAY_PUBLIC)}),this.setDefault({isValidMineralType:e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}}),this._isAddableTarget=this.isAddableTarget,this.isAddableTarget=((e,t)=>{const r=this.getBoostPartType(e.mineralType);return this._isAddableTarget(e,t)&&t.getStrategyHandler([this.name],"isValidMineralType",e.mineralType)&&t.hasActiveBodyparts(r)&&this.canBoostType(t,r)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("building"),this.maxPerTarget=3,this.maxPerAction=3,this.targetRange=3,this.reachedRange=(e=>e.getStrategyHandler([this.name],"reachedRange",e)),this.isValidAction=(e=>e.carry.energy>0),this.isAddableAction=(e=>!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isValidTarget=(e=>null!=e&&(e.my||Task.reputation.allyOwner(e))&&e.progress&&e.progress<e.progressTotal),this.isAddableTarget=(e=>e&&(e.my||Task.reputation.allyOwner(e))&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>e.room.getBestConstructionSiteFor(e.pos,t=>this.isAddableTarget(t,e))),this.work=(e=>(e.getStrategyHandler([this.name],"getEnergy",e),e.build(e.target))),this.setDefault({reachedRange:1,getEnergy:()=>!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("bulldozing"),this.maxPerAction=2,this.maxPerTarget=1,this.isValidTarget=(e=>!(!e.room.my&&e.room.controller&&e.room.controller.safeMode)&&e instanceof ConstructionSite&&Task.reputation.notAlly(e.owner.username)),this.newTarget=(e=>{const t=_(e.room.constructionSites).filter(this.isValidTarget).max(t=>{let r;return r=t.structureType===STRUCTURE_SPAWN?2e4:1e4,r+=t.progress/t.progressTotal*1e4,r-=e.pos.getRangeTo(t)});if(t instanceof ConstructionSite)return t}),this.work=(e=>e.move(e.pos.getDirectionTo(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("charging"),this.renewTarget=!1,this.maxPerTarget=1,this.isValidAction=(e=>e.carry.energy>0),this.isAddableAction=(e=>!0),this.isValidTarget=(e=>!!e&&(e.structureType==STRUCTURE_LINK?e.energy<.85*e.energyCapacity:e.structureType==STRUCTURE_CONTAINER&&e.sum<(!0===e.source&&1==e.controller?e.storeCapacity*MANAGED_CONTAINER_TRIGGER:e.storeCapacity))),this.newTarget=(e=>{if(e.room.structures.links.storage.length>0){let t=e.room.structures.links.storage.find(e=>e.energy<.85*e.energyCapacity);if(t&&e.room.structures.links.controller.find(e=>e.energy<=.15*e.energyCapacity)&&this.isValidTarget(t,e)&&this.isAddableTarget(t,e))return t}if(e.room.structures.container.out.length>0){let t=null,r=0,o=o=>{if(this.isValidTarget(o,e)&&this.isAddableTarget(o,e)){let e=o.storeCapacity-o.sum;e>r&&(r=e,t=o)}};return _.forEach(e.room.structures.container.out,o),t}return null}),this.work=(e=>{let t;if(!0===e.target.source&&1==e.target.controller){let r=e.target.storeCapacity*MANAGED_CONTAINER_TRIGGER-e.target.sum;if(r<1)t=ERR_FULL;else{let o=_.min([e.carry.energy,r]);t=e.transfer(e.target,RESOURCE_ENERGY,o),e.target._sum+=o}}else t=e.transfer(e.target,RESOURCE_ENERGY);return delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,t}),this._isAddableTarget=this.isAddableTarget,this.isAddableTarget=((e,t)=>this._isAddableTarget(e,t)&&(e instanceof OwnedStructure&&e.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(e.structureType==STRUCTURE_CONTAINER&&e.storeCapacity-e.sum>Math.min(t.carry.energy,500)||e.structureType==STRUCTURE_LINK)&&(e.structureType!=STRUCTURE_CONTAINER||!e.controller||t.carry.energy==t.sum))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("claiming"),this.isValidAction=(e=>!0),this.isValidTarget=(e=>!e.room||!e.owner),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName]),t||(t=Flag.find(FLAG_COLOR.claim,e.pos,!1,Flag.claimMod,e.name)),!t)return null;if(Population.registerCreepFlag(e,t),!e.flag.room||e.flag.pos.roomName!=e.pos.roomName)return e.flag;if(e.flag.room.controller.my){e.flag.setColor(FLAG_COLOR.claim.spawn.color,FLAG_COLOR.claim.spawn.secondaryColor);let t=e=>Game.flags[e.name].remove();return _.forEach(Flag.filter(FLAG_COLOR.invade.exploit,e.flag.pos,!0),t),null}return e.flag.room.controller}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),void e.travelTo(e.target.pos);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e})}e.travelTo(e.target.pos)}),this.work=(e=>(e.controllerSign(),e.claimController(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("defending"),this.isValidAction=(e=>e.room.hostiles.length>0),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.isValidTarget=(e=>e&&null!=e.hits&&e.hits>0&&0==e.my),this.newTarget=(e=>{let t=e.pos.findClosestByRange(e.room.hostiles,{filter:e.getStrategyHandler([this.name],"priorityTargetFilter",e)});return t||(t=e.pos.findClosestByRange(e.room.hostiles,{filter:e.getStrategyHandler([this.name],"targetFilter",e)})),t}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.pos.roomName!==e.room.name)return Creep.action.travelling.assignRoom(e,e.target.pos.roomName);this.run[e.data.creepType](e)}),this.run={ranger(e){let t=e.pos.getRangeTo(e.target);if(!e.flee&&(t>3&&e.travelTo(e.target,{respectRamparts:COMBAT_CREEPS_RESPECT_RAMPARTS}),t<3)){let r=e.target.pos.getDirectionTo(e);r&&(COMBAT_CREEPS_RESPECT_RAMPARTS&&!_.filter(e.pos.lookFor(LOOK_STRUCTURES),{my:!0,structureType:STRUCTURE_RAMPART})&&e.move(r),1===t&&(e.attacking=e.attack(e.target)==OK))}let r=e.pos.findInRange(e.room.hostiles,3);if(r.length>2)return CHATTY&&e.say("MassAttack"),void(e.attackingRanged=e.rangedMassAttack()==OK);t<4?e.attackingRanged=e.rangedAttack(e.target)==OK:r.length>0&&(e.attackingRanged=e.rangedAttack(r[0])==OK)},melee(e){e.flee||e.travelTo(e.target,{respectRamparts:COMBAT_CREEPS_RESPECT_RAMPARTS});let t=e.attack(e.target);if(t==ERR_NOT_IN_RANGE){let t=e.pos.findInRange(e.room.hostiles,1);t.length>0&&(e.attacking=e.attack(t[0])==OK)}else e.attacking=t==OK}},this.setDefault({priorityTargetFilter:e=>e=>e.hasBodyparts(HEAL),targetFilter:e=>e=>!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("dismantling"),this.maxPerAction=3,this.maxPerTarget=3,this.renewTarget=!1,this.isValidAction=(e=>0===e.carryCapacity||e.sum<e.carryCapacity),this.isValidTarget=(e=>null!=e),this.newTarget=(e=>{let t,r=Flag.find(FLAG_COLOR.destroy.dismantle,e.pos,!0);if(r)if(void 0!==r.room){let o=r.room.lookForAt(LOOK_STRUCTURES,r.pos.x,r.pos.y);if(o&&o.length>0)return o[0];{let o=r.name;Room.costMatrixInvalid.trigger(r.room),Flag.removeFromDir(r.name),r.remove();let i=(e,t,r)=>t.name==r?1/0:e;if(o==(r=Flag.find(FLAG_COLOR.destroy.dismantle,e.pos,!0,i,o)).name&&Log.error("Removed flag found again in dismantling.newTarget!"),r)if(void 0!==r.room){let e=r.room.lookForAt(LOOK_STRUCTURES,r.pos.x,r.pos.y);if(e&&e.length>0)return e[0];Room.costMatrixInvalid.trigger(r.room),Flag.removeFromDir(r.name),r.remove()}else t=r}}else t=r;return t}),this.work=(e=>e.dismantle(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("dropping"),this.targetRange=1,this.reachedRange=0,this.isValidAction=(e=>e.sum>0),this.isValidTarget=((e,t)=>!!e&&(!(e instanceof Flag)||e.compareTo(FLAG_COLOR.claim.spawn)||e.compareTo(FLAG_COLOR.command.drop))),this.newTarget=(e=>{let t=e.pos.findClosestByRange(e.room.structures.piles);return t||(t=e.pos.findClosestByRange(e.room.structures.spawns)),t||(t=e.pos.findClosestByRange(e.room.find(FIND_FLAGS,Flag.flagFilter(FLAG_COLOR.claim.spawn)))),t||(t=e.pos.findClosestByRange(_.filter(e.room.constructionSites,{structureType:STRUCTURE_SPAWN}))),t||(t=e.room.controller),t}),this.work=(e=>{let t=OK;if(!(e.target instanceof StructureSpawn||e.target instanceof ConstructionSite||e.target instanceof StructureController||(e=>e&&Flag.compare(e,FLAG_COLOR.claim.spawn))(e.target))&&e.pos.getRangeTo(e.target)>0&&e.data.lastPos&&e.data.path&&!_.eq(e.pos,e.data.lastPos)){let r=e=>e.type==LOOK_TERRAIN&&"wall"==e.terrain||e.type==LOOK_CREEPS||e.type==LOOK_STRUCTURES&&OBSTACLE_OBJECT_TYPES.includes(e.structure.structureType),o=e.room.lookAt(e.target);if(!_.some(o,r))return t}for(let r in e.carry)t=e.drop(r);return t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("feeding"),this.maxPerTarget=1,this.isValidAction=(e=>e.carry.energy>0&&e.room.energyAvailable<e.room.energyCapacityAvailable),this.isValidTarget=(e=>e&&!_.isUndefined(e.energy)&&e.energy<e.energyCapacity),this.isAddableTarget=(e=>e.my&&(!e.targetOf||_.filter(e.targetOf,{actionName:"feeding"}).length<this.maxPerTarget)),this.newTarget=(e=>e.room.energyAvailable===e.room.energyCapacityAvailable?null:e.pos.findClosestByRange(e.room.structures.feedable,{filter:t=>this.isValidTarget(t)&&this.isAddableTarget(t,e)})),this.work=(e=>{let t=e.transfer(e.target,RESOURCE_ENERGY);return t==OK&&e.carry.energy>e.target.energyCapacity-e.target.energy&&(e.target=null,this.assign(e)),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("fortifying"),this.maxPerTarget=2,this.maxPerAction=3,this.targetRange=3,this.isValidAction=(e=>e.carry.energy>0&&(!e.room.storage||!e.room.storage.active||e.room.storage.charge>.6)),this.isValidTarget=(e=>e&&e.active&&e.hits&&e.hits<e.hitsMax),this.newTarget=(e=>_.find(e.room.structures.fortifyable,t=>this.isAddableTarget(t,e))),this.work=(e=>e.repair(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("fueling"),this.maxPerTarget=1,this.maxPerAction=1,this.isValidAction=(e=>e.carry.energy>0&&e.room.towerFreeCapacity>0),this.isValidTarget=(e=>e&&(e.energy||0==e.energy)&&e.active&&e.energy<e.energyCapacity),this.isAddableTarget=(e=>e.my&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>e.room.structures.fuelable.length>0?e.pos.findClosestByRange(e.room.structures.fuelable):null),this.work=(e=>{let t=e.transfer(e.target,RESOURCE_ENERGY);return e.target.energyCapacity-e.target.energy<20&&(e.data.targetId=null),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("guarding"),this.reachedRange=0,this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t||(t=Flag.find(FLAG_COLOR.defense,e.pos,!1,Flag.rangeMod,{rangeModPerCrowd:400})),e.action===this&&e.flag?e.flag:(t&&Population.registerCreepFlag(e,t),t)}),this.work=(e=>e.data.flagName?OK:ERR_INVALID_ARGS)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("harvesting"),this.renewTarget=!1,this.isValidAction=(e=>e.sum<e.carryCapacity&&e.room.sourceEnergyAvailable>0),this.isValidTarget=((e,t)=>null!==e&&null!==e.energy&&e.energy>0&&(void 0===e.targetOf||e.targetOf.length<=e.accessibleFields&&!_.some(e.targetOf,e=>("miner"===e.creepType||"remoteMiner"===e.creepType)&&e.body.work>=5&&(e.ticksToLive||CREEP_LIFE_TIME)>=(e.data&&e.data.predictedRenewal||0)))),this.isAddableTarget=((e,t)=>(!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(void 0===e.targetOf||e.targetOf.length<e.accessibleFields)),this.newTarget=(e=>{const t=_.sortBy(e.room.sources,t=>e.pos.getRangeTo(t));for(const r of t)if(this.isValidTarget(r,e)&&this.isAddableTarget(r,e))return r;return null}),this.work=(e=>e.harvest(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("healing"),this.targetRange=3,this.isAddableAction=(()=>!0),this.isAddableTarget=((e,t)=>{const r=t.getStrategyHandler([this.name],"targetFilter",t);return r&&r(e)}),this.isValidTarget=((e,t)=>{if(null!=e&&null!=e.hits&&e.hits<e.hitsMax&&e.pos.roomName===t.data.healRoom){const r=t.getStrategyHandler([this.name],"targetFilter",t);return r&&r(e)}return!1}),this.newTarget=(e=>{if(e.room.casualties.length>0)for(const t of e.room.casualties)if(t.name!==e.name)return e.data.healRoom=t.pos.roomName,t;return delete e.data.healRoom,null}),this.work=(e=>{if(e.target.hits<e.target.hitsMax)return e.pos.isNearTo(e.target)?e.heal(e.target):e.pos.inRangeTo(e.target,3)?e.rangedHeal(e.target):OK}),this.setDefault({targetFilter:e=>e=>e.my,moveOptions:e=>e})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("idle"),this.targetRange=3,this.isValidAction=(e=>!0),this.isAddableAction=(e=>!0),this.isAddableTarget=(e=>!0),this.newTarget=(e=>Flag.specialFlag()),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC),e.getStrategyHandler([this.name],"idleMove",e)&&e.idleMove(),delete e.data.actionName,delete e.data.targetId}),this.setDefault({idleMove:e=>!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("invading"),this.isValidAction=(e=>Flag.hasInvasionFlag()),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.getFlaggedStructure=((e,t)=>{let r=[];return Flag.filter(e,t,!0).forEach(e=>{let o=Game.flags[e.name];if(o&&o.pos.roomName==t.roomName&&void 0!==o.room){let e=o.room.lookForAt(LOOK_STRUCTURES,o.pos.x,o.pos.y);if(e&&e.length>0){const t=e=>{e.destroyFlag=o,r.push(e)};e.forEach(t)}else o.remove()}}),r&&r.length>0?t.findClosestByRange(r):null}),this.newTarget=(e=>{let t=this.getFlaggedStructure(FLAG_COLOR.destroy,e.pos);if(t)return t.destroyFlag&&Population.registerCreepFlag(e,t.destroyFlag),t;let r=Flag.find(FLAG_COLOR.invade,e.pos,!1);if(r&&(!r.room||r.pos.roomName!=e.pos.roomName))return Population.registerCreepFlag(e,r),r;if(!r)return e.action=null,delete e.data.actionName,void delete e.data.targetId;if(!r.room.controller||!r.room.controller.my){let t=e.pos.findClosestByRange(e.room.hostiles,{filter:e=>_.some(e.body,{type:HEAL})});if(t)return t;if(t=e.pos.findClosestByRange(e.room.hostiles,{filter:e=>_.some(e.body,e=>e.type==ATTACK||e.type==RANGED_ATTACK)}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_TOWER}))return t;if(t=e.pos.findClosestByRange(e.room.hostiles))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_SPAWN}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType!=STRUCTURE_CONTROLLER}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_CONSTRUCTION_SITES))return t}return r.remove(),null}),this.step=(e=>{CHATTY&&e.say(this.name),e.target instanceof Flag&&e.target.pos.roomName==e.pos.roomName&&this.assign(e),this.run[e.data.creepType](e)}),this.run={melee:e=>{if(!e.flee){if(e.target instanceof Flag)return void e.travelTo(e.target);if(e.target instanceof ConstructionSite)return void e.travelTo(e.target,{range:0});e.travelTo(e.target)}e.target.my||(e.attacking=e.attack(e.target)==OK)},ranger:e=>{let t=e.pos.getRangeTo(e.target);if(!e.flee){if(e.target instanceof Flag)return void e.travelTo(e.target);if(e.target instanceof ConstructionSite)return void e.travelTo(e.target,{range:0});t>3&&e.travelTo(e.target),t<3&&e.move(e.target.pos.getDirectionTo(e))}let r=e.pos.findInRange(e.room.hostiles,3);if(r.length>2)return CHATTY&&e.say("MassAttack"),void(e.attackingRanged=e.rangedMassAttack()==OK);t<4?e.attackingRanged=e.rangedAttack(e.target)==OK:r.length>0&&(e.attackingRanged=e.rangedAttack(r[0])==OK)}},this.setDefault({moveOptions:e=>(_.isUndefined(e.allowHostile)&&(e.allowHostile=!0),e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("mining"),this.renewTarget=!0,this.isValidTarget=((e,t)=>e&&(e instanceof Source||e instanceof Mineral&&!e.ticksToRegeneration)),this.isAddableAction=(e=>{const t=e.room;return t.my||t.myReservation||!t.owner&&!t.reservation}),this.isAddableTarget=((e,t)=>!e.targetOf||!_.some(e.targetOf,e=>{const r=e.predictedRenewal?e.predictedRenewal:e.spawningTime;return e.creepType===t.data.creepType&&e.ttl>r})),this.newTarget=(e=>{const t=e.getStrategyHandler([this.name],"newTarget",e);return t&&this.determineSpot(e,t),t}),this.determineSpot=((e,t)=>{const r=[];_.forEach(Memory.population,t=>{if(t.name===e.name)return;const o=t.predictedRenewal?t.predictedRenewal:t.spawningTime;t.roomName===e.pos.roomName&&["miner","upgrader"].includes(t.creepType)&&t.determinatedSpot&&t.ttl>o&&r.push(t.determinatedSpot)});const o=t.container&&t.container.structureType===STRUCTURE_CONTAINER&&t.container.pos.isNearTo(t)&&!_.some(r,{x:t.container.pos.x,y:t.container.pos.y})?t.container.pos:null;let i,s=[];if(o||(i={spots:[{pos:t.pos,range:1}],checkWalkable:!0,where:e=>!_.some(r,{x:e.x,y:e.y}),roomName:e.pos.roomName},t.container&&i.spots.push({pos:t.container.pos,range:1}),!e.remote&&t.link&&i.spots.push({pos:t.link.pos,range:1}),s=Room.fieldsInRange(i)),o||s.length>0){let r=o;if(r||(r=e.pos.findClosestByPath(s,{filter:t=>!_.some(e.room.lookForAt(LOOK_STRUCTURES,t),{structureType:STRUCTURE_ROAD})})),r||(r=e.pos.findClosestByPath(s)||s[0]),r){if(e.data.determinatedSpot={x:r.x,y:r.y},!e.remote){const t=Game.spawns[e.data.motherSpawn];if(t){const o=r.findPathTo(t,{ignoreCreeps:!0});o&&(e.data.predictedRenewal=e.data.spawningTime+o.length)}}MINERS_AUTO_BUILD&&!t.container&&!_.filter(t.pos.findInRange(FIND_CONSTRUCTION_SITES,2),e=>e.structureType===STRUCTURE_CONTAINER).length&&t.room&&t.room.createConstructionSite(r,STRUCTURE_CONTAINER)}}e.data.determinatedSpot||Log.error("Unable to determine working location for miner in room "+e.pos.roomName)}),this.work=(e=>{if(0===e.target.energy||e.target.cooldown>0)this.maintain(e);else{if(!(e.target instanceof Mineral&&e.target.ticksToRegeneration>0)){this.resetChecks(e);const t=e.carryCapacity-(e.data.body&&e.data.body.work?2*e.data.body.work:e.carryCapacity/2);if(e.sum>t)if(e.target.link&&e.target.link.energy<e.target.link.energyCapacity)e.transfer(e.target.link,RESOURCE_ENERGY);else if(e.target.container&&e.target.container.sum<e.target.container.storeCapacity){const t=t=>{e.carry[t]>0&&e.transfer(e.target.container,t)};_.forEach(Object.keys(e.carry),t)}else{CHATTY&&e.say("dropmining",SAY_PUBLIC),OOPS&&e.say(String.fromCharCode(8681),SAY_PUBLIC);const t=t=>{e.carry[t]>0&&e.drop(t)};_.forEach(Object.keys(e.carry),t)}return e.harvest(e.target)}this.resetChecks(e),this.unassign(e)}}),this.resetChecks=(e=>{delete e.data.repairChecked,delete e.data.repairTarget,delete e.data.buildChecked,delete e.data.buildTarget,delete e.data.energyChecked}),this.step=(e=>{if(_.isUndefined(e.data.determinatedSpot))this.determineSpot(e,e.target);else{const t=e.data.destiny?e.data.destiny.room:e.data.homeRoom,r=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,t),o=e.pos.getRangeTo(r);o>1?e.travelTo(r,{range:1}):1===o?r.lookFor(LOOK_CREEPS).length>0||e.move(e.pos.getDirectionTo(r)):this.work(e)}}),this.getEnergy=(e=>{const t=e.pos.findInRange(FIND_DROPPED_RESOURCES,1,{filter:e=>e.resourceType===RESOURCE_ENERGY})[0];if(t)return LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,pickup:t.id}),e.pickup(t),!0;const r=e.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER})[0];if(r&&r.sum>0)return LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,withdrawCon:r.id}),e.withdraw(r,RESOURCE_ENERGY),!0;const o=e.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.my&&e.structureType===STRUCTURE_LINK})[0];return o&&o.energy>0?(LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,withdrawLink:o.id}),e.withdraw(o,RESOURCE_ENERGY),!0):(LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,result:"no energy"}),e.data.energyChecked=Game.time,!1)}),this.maintain=(e=>{const t=e.data.body&&e.data.body.work?5*e.data.body.work:e.carryCapacity/2;if(LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,energy:e.carryenergy,minCarry:t}),e.carry.energy<=t&&(!e.data.energyChecked||Game.time-e.data.energyChecked>MINER_WORK_THRESHOLD)&&this.getEnergy(e),e.carry.energy>0){if(!e.data.repairChecked||Game.time-e.data.repairChecked>MINER_WORK_THRESHOLD){let t=Game.getObjectById(e.data.repairTarget);if(t&&t.hits!==t.hitsMax||(t=e.pos.findInRange(FIND_STRUCTURES,3,{filter:e=>(e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD)&&e.hits<e.hitsMax})[0]),t)return e.data.repairTarget=t.id,LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,repairTarget:t.id,progress:t.hits/t.hitsMax}),e.repair(t);delete e.data.repairTarget,e.data.repairChecked=Game.time}if(!e.data.buildChecked||Game.time-e.data.buildChecked>MINER_WORK_THRESHOLD){let t=Game.getObjectById(e.data.buildTarget);if(t&&t.progress!==t.progressTotal||(t=e.pos.findInRange(e.room.myConstructionSites,3,{filter:e=>(e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD)&&e.progress<e.progressTotal})[0]),t)return e.data.buildTarget=t.id,LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,buildTarget:t.id,progress:t.progress/t.progressTotal}),e.build(t);delete e.data.buildTarget,e.data.buildChecked=Game.time}}return!1}),this.setDefault({newTarget:e=>_(e.room.sources).sortBy(t=>e.pos.getRangeTo(t)).find(t=>this.isValidTarget(t,e)&&this.isAddableTarget(t,e))||null})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("picking"),this.maxPerAction=4,this.maxPerTarget=2,this.isValidAction=(e=>e.sum<e.carryCapacity),this.isValidTarget=(e=>null!=e&&null!=e.amount&&e.amount>0),this.isAddableAction=(e=>e.data.creepType.indexOf("remote")>0||this.maxPerAction===1/0||!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isAddableTarget=((e,t)=>{let r;r=t.data.creepType.indexOf("remote")>0?1/0:this.maxPerTarget;let o=e.targetOf?_.filter(e.targetOf,{actionName:"picking"}):[];return!e.targetOf||!o.length||o.length<r&&e.amount>_.sum(o.map(e=>e.carryCapacityLeft))}),this.newTarget=(e=>{const t=this.getStrategy("energyOnly",e)?_.filter(e.room.droppedResources,{resourceType:RESOURCE_ENERGY}):e.room.droppedResources;let r;return r=e.room.my&&e.room.situation.invasion?t=>this.isAddableTarget(t,e)&&t.pos.findInRange(e.room.sources,1).length>0:t=>this.isAddableTarget(t,e),e.pos.findClosestByPath(t,{filter:r})}),this.work=(e=>{let t=e.pickup(e.target);if(t==OK){if(e.sum<.8*e.carryCapacity){let r=e.pos.findInRange(e.room.droppedResources,1,{filter:t=>t.resourceType!=RESOURCE_ENERGY&&this.isAddableTarget(t,e)});if((!r||r.length<1)&&(r=e.pos.findInRange(e.room.droppedResources,1,{filter:t=>this.isAddableTarget(t,e)})),r&&r.length>0)return this.assign(e,r[0]),t}if(e.sum<e.carryCapacity){let r=e.pos.findInRange(e.room.structures.container.in,2,{filter:t=>Creep.action.uncharging.isValidTarget(t,e)});if(r&&r.length>0)return Creep.action.uncharging.assign(e,r[0]),t}delete e.data.actionName,delete e.data.targetId}return t}),this.setDefault({energyOnly:!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("reallocating"),this.getLabOrder=(e=>{if(!e)return null;let t=null,r=e.room;if(!r.memory||!r.memory.resources)return null;let o=r.memory.resources.lab.find(t=>t.id==e.id);if(o){let e=o.orders;for(let r=0;r<e.length;r++)if(e[r].type!=RESOURCE_ENERGY&&(e[r].orderRemaining>0||e[r].storeAmount>0)){t=e[r];break}}return t}),this.findNeeding=((e,t,r,o)=>{r||(r=1);const i=e.structures.labs.all;if(i.length>0)for(let e=0;e<i.length;e++){const s=Game.getObjectById(i[e].id);let a=0;if(s&&(a=s.getNeeds(t)),a>=r&&(0===s.mineralAmount||s.mineralType==t||t==RESOURCE_ENERGY)&&s.id!=o)return{structure:s,amount:a}}const s=e.structures.powerSpawns.all;if(s.length>0)for(let e=0;e<s.length;e++){const i=Game.getObjectById(s[e].id);let a=0;if(i&&(a=i.getNeeds(t)),a>=r&&(t==RESOURCE_POWER||t==RESOURCE_ENERGY)&&i.id!=o)return{structure:i,amount:a}}const a=e.structures.nukers.all;if(a.length>0)for(let e=0;e<a.length;e++){const i=Game.getObjectById(a[e].id);let s=0;if(i&&(s=i.getNeeds(t)),s>=r&&(t==RESOURCE_GHODIUM||t==RESOURCE_ENERGY)&&i.id!=o)return{structure:i,amount:s}}const n=e.structures.container.all;if(n.length>0)for(let e=0;e<n.length;e++){const i=Game.getObjectById(n[e].id);let s=0;if(i&&(s=i.getNeeds(t)),s>=r&&i.id!=o)return{structure:i,amount:s}}const l=e.terminal;if(l&&l.active){let e=l.getNeeds(t);if(e>=r&&l.id!=o)return{structure:l,amount:e}}let m=e.storage;if(m&&m.active){let e=m.getNeeds(t);if(e>=r&&m.id!=o)return{structure:m,amount:e}}return m&&m.active&&(t==RESOURCE_ENERGY||t==RESOURCE_POWER)&&m.storeCapacity-m.sum>r?{structure:m,amount:0}:l&&l.active&&t!=RESOURCE_ENERGY&&t!=RESOURCE_POWER&&l.storeCapacity-l.sum>r?{structure:l,amount:0}:null}),this.newTargetLab=(e=>{let t=e.room,r=t.memory;if(r&&r.labs&&r.labs.length>0)for(let o=0;o<r.labs.length;o++){let i=r.labs[o],s=Game.getObjectById(i.id);if(!s)continue;let a=0;if(s.mineralAmount>0){if((a=s.getNeeds(s.mineralType))<0){let r;if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:s.mineralType,needs:a}),r=this.findNeeding(t,s.mineralType))return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:s.mineralType,targetNeeds:r.amount}),s}if(a>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:s.mineralType,needs:a}),t.storage&&t.storage.active&&t.storage.store[s.mineralType])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:s.mineralType,targetNeeds:t.storage.store[s.mineralType]}),e.data.reallocating=s.mineralType,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(s.mineralType)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:s.mineralType,targetNeeds:t.terminal.store[s.mineralType]}),e.data.reallocating=s.mineralType,t.terminal;let r=t.findContainerWith(s.mineralType);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:s.mineralType,targetNeeds:r.amount}),e.data.reallocating=s.mineralType,r.structure;!ROOM_TRADING||MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS||s.mineralType==RESOURCE_ENERGY||s.mineralType==t.mineralType||_.some(t.memory.resources.orders,{type:s.mineralType})||t.placeRoomOrder(s.id,s.mineralType,a)}}else{let r=this.getLabOrder(s),o=null;if(r){o=r.type;let i=r.orderRemaining+r.storeAmount;if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:o,needs:i}),t.storage&&t.storage.active&&t.storage.store[o])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:o,targetNeeds:t.storage.store[o]}),e.data.reallocating=o,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(o)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:o,targetNeeds:t.terminal.store[o]}),e.data.reallocating=o,t.terminal;let a=t.findContainerWith(o);if(a)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:a.structure.id,resourceType:o,targetNeeds:a.amount}),e.data.reallocating=o,a.structure;!ROOM_TRADING||MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS||o==RESOURCE_ENERGY||o==t.mineralType||_.some(t.memory.resources.orders,{type:s.mineralType})||t.placeRoomOrder(s.id,o,r.orderRemaining)}}if((a=s.getNeeds(RESOURCE_ENERGY))<0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:RESOURCE_ENERGY,needs:a});let r=this.findNeeding(t,RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),s}if(a>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:RESOURCE_ENERGY,needs:a}),t.storage&&t.storage.active&&t.storage.charge>.5)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}}return null}),this.newTargetPowerSpawn=(e=>{const t=e.room,r=t.structures.powerSpawns.all;if(r.length>0)for(let o=0;o<r.length;o++){const i=Game.getObjectById(r[o].id);if(!i)continue;let s=0;if((s=i.getNeeds(RESOURCE_ENERGY))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_ENERGY,needs:s}),t.storage&&t.storage.active&&t.storage.charge>.5)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}if((s=i.getNeeds(RESOURCE_POWER))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_POWER,needs:s}),t.storage&&t.storage.active&&t.storage.store[RESOURCE_POWER])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_POWER,targetNeeds:t.storage.store[RESOURCE_POWER]}),e.data.reallocating=RESOURCE_POWER,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_POWER)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_POWER,targetNeeds:t.terminal.store[RESOURCE_POWER]}),e.data.reallocating=RESOURCE_POWER,t.terminal;let r=t.findContainerWith(RESOURCE_POWER);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_POWER,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_POWER,r.structure}}return null}),this.newTargetNuker=(e=>{const t=e.room,r=t.structures.nukers.all;if(r.length>0)for(var o=0;o<r.length;o++){const s=Game.getObjectById(r[o].id);if(s){var i=0;if((i=s.getNeeds(RESOURCE_ENERGY))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:RESOURCE_ENERGY,needs:i}),t.storage&&t.storage.active&&t.storage.charge>.5)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}if((i=s.getNeeds(RESOURCE_GHODIUM))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:s.id,resourceType:RESOURCE_GHODIUM,needs:i}),t.storage&&t.storage.active&&t.storage.store[RESOURCE_GHODIUM])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_GHODIUM,targetNeeds:t.storage.store[RESOURCE_GHODIUM]}),e.data.reallocating=RESOURCE_GHODIUM,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_GHODIUM)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_GHODIUM,targetNeeds:t.terminal.store[RESOURCE_GHODIUM]}),e.data.reallocating=RESOURCE_GHODIUM,t.terminal;let r=t.findContainerWith(RESOURCE_GHODIUM);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_GHODIUM,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_GHODIUM,r.structure}}}return null}),this.newTargetContainer=(e=>{const t=e.room,r=t.structures.container.all;if(r.length>0)for(let o=0;o<r.length;o++){const i=Game.getObjectById(r[o].id);if(i){for(let r in i.store){let o=i.getNeeds(r);if(r&&o<0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:r,needs:o});let s=this.findNeeding(t,r);if(s)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:s.structure.id,resourceType:r,targetNeeds:s.amount}),e.data.reallocating=r,i}}if(t.memory.resources){let r=t.memory.resources.container.find(e=>e.id==i.id);if(r){let o=r.orders;for(let r=0;r<o.length;r++){let s=o[r].type,a=i.getNeeds(s);if(a>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:resource,needs:a}),t.storage&&t.storage.active&&t.storage.store[s]&&!(s==RESOURCE_ENERGY&&t.storage.charge<.5))return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:resource,targetNeeds:t.storage.store[resource]}),e.data.reallocating=resource,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(s)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:resource,targetNeeds:t.terminal.store[resource]}),e.data.reallocating=resource,t.terminal}}}}}}return null}),this.newTargetTerminal=(e=>{let t=e.room,r=e.room.terminal;if(r&&r.active){for(let o in r.store){let i=-r.getNeeds(o);if(i>0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:o,needs:-i});let s=this.findNeeding(t,o,1,r.id);if(s&&s.structure.id!=r.id)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:s.structure.id,resourceType:o,targetNeeds:s.amount}),e.data.reallocating=o,r}}if(t.memory.resources&&t.memory.resources.terminal[0]){let o=t.memory.resources.terminal[0].orders.slice();o.push(RESOURCE_ENERGY);let i=null,s=0;for(let a=0;a<o.length;a++)if(i=o[a].type,(s=r.getNeeds(i))>0&&(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:i,needs:s}),t.storage&&t.storage.active&&t.storage.store[i]&&!(i==RESOURCE_ENERGY&&t.storage.charge<.5)))return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:i,targetNeeds:t.storage.store[i]}),e.data.reallocating=i,t.storage}}return null}),this.newTargetStorage=(e=>{let t=e.room,r=e.room.storage;if(r&&r.active)for(let o in r.store){let i=-r.getNeeds(o);if(o&&i>0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:o,needs:-i});let s=this.findNeeding(t,o,1,r.id);if(s)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:s.structure.id,resourceType:o,targetNeeds:s.amount}),e.data.reallocating=o,r}}return null}),this.isValidAction=(e=>!0),this.isValidTarget=(e=>!0),this.isAddableAction=(e=>{let t=e.room.population;return 0==e.sum&&(!t||!t.actionCount[this.name]||t.actionCount[this.name]<this.maxPerAction)}),this.isAddableTarget=(e=>!0),this.newTarget=(e=>{let t=e.room;LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,subAction:"newTarget"});let r=null;if(0==e.sum)return t.memory&&(null===(r=this.newTargetLab(e))&&(r=this.newTargetPowerSpawn(e)),null===r&&(r=this.newTargetNuker(e)),null===r&&(r=this.newTargetContainer(e)),null===r&&(r=this.newTargetTerminal(e)),null===r&&(r=this.newTargetStorage(e))),r;{let r=Object.keys(e.carry)[0],o=this.findNeeding(t,r);return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,subAction:"assignDropOff",targetStructureId:o.structure.id,resourceType:r,targetNeeds:o.amount}),o?o.structure:null}}),this.cancelAction=(e=>{delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,delete e.data.path}),this.unloadStructure=((e,t,r,o)=>{let i=Math.min(o,e.carryCapacity-e.sum),s=e.withdraw(t,r,i);return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"unloadStructure",structureId:t.id,resourceType:r,amount:i,result:s}),s}),this.loadStructure=((e,t,r,o)=>{let i=null,s=e.room,a=Math.min(o,e.carry[r]||0);if(a>0&&(i=e.transfer(t,r,a)),i==OK){let e=null;if(s.memory.resources&&(e=s.memory.resources[t.structureType].find(e=>e.id==t.id)),e&&e.orders){let t=e.orders.find(e=>e.type==r);t&&t.orderRemaining>0&&(t.orderRemaining-=a)}}return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"loadStructure",structureId:t.id,resourceType:r,amount:a,result:i}),i}),this.assignDropOff=((e,t)=>{let r=this.findNeeding(e.room,t,1,e.target.id);r&&(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"assignDropOff",targetStructureId:r.structure.id,resourceType:t,amount:r.amount}),this.assign(e,r.structure))}),this.unloadLab=(e=>{let t=e.target,r=null,o=null,i=0;return(i=-t.getNeeds(RESOURCE_ENERGY))>0&&(o=RESOURCE_ENERGY),o||(i=-t.getNeeds(t.mineralType))>0&&(o=t.mineralType),o&&(r=this.unloadStructure(e,t,o,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadLab",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:i,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadContainer=(e=>{let t=e.target,r=null,o=null,i=0,s=Object.keys(t.store);e.data.reallocating&&(s.unshift(e.data.reallocating),delete e.data.reallocating);for(let e=0;e<s.length;e++){let r=s[e];if(r&&t.store[r]>0&&(t.structureType==STRUCTURE_LAB||t.getNeeds(r)<0)){let e=this.findNeeding(room,r,1,t.id);if(e&&(i=e.amount),i>0){o=r;break}if(storage&&storage.active&&e&&e.structure.structureType==STRUCTURE_STORAGE&&r==RESOURCE_ENERGY){i=storage.storeCapacity-storage.sum,o=r;break}}}return o&&(r=this.unloadStructure(e,t,o,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadContainer",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:i,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadTerminal=(e=>{let t=e.target,r=e.room,o=r.storage,i=null,s=null,a=0,n=Object.keys(t.store);e.data.reallocating&&(n.unshift(e.data.reallocating),delete e.data.reallocating);for(let e=0;e<n.length;e++){let i=n[e];if(i&&t.store[i]>0&&(t.structureType==STRUCTURE_LAB||t.getNeeds(i)<0)){let e=this.findNeeding(r,i,1,t.id);if(e&&(a=e.amount),a>0){s=i;break}if(o&&o.active&&e&&e.structure.structureType==STRUCTURE_STORAGE&&i==RESOURCE_ENERGY){a=o.storeCapacity-o.sum,s=i;break}}}return s&&(a=Math.min(a,t.store[s]||0,e.carryCapacity-e.sum),i=this.unloadStructure(e,t,s,a)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadTerminal",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:s,needs:a,workResult:i}),i==OK?this.assignDropOff(e,s):this.cancelAction(e),i}),this.unloadStorage=(e=>{let t=e.target,r=e.room,o=r.terminal,i=null,s=null,a=0,n=Object.keys(t.store);e.data.reallocating&&(n.unshift(e.data.reallocating),delete e.data.reallocating);for(let i=0;i<n.length;i++){let l=n[i];if(l&&t.store[l]>0){if(l==RESOURCE_ENERGY&&t.charge<.5)continue;let i=this.findNeeding(r,l,1,t.id);if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",subAction:"findNeeding",roomName:r.name,creepName:e.name,structureId:i&&i.structure.id,resourceType:l,amount:i&&i.amount}),i&&i.structure.id==t.id&&(i=null),i&&(a=i.amount),a>0){s=l;break}if(o&&o.active&&i&&i.structure.structureType==STRUCTURE_TERMINAL&&l!=RESOURCE_ENERGY&&l!=RESOURCE_POWER){a=o.storeCapacity-o.sum,s=l;break}}}return s&&(a=Math.min(a,t.store[s]||0,e.carryCapacity-e.sum),i=this.unloadStructure(e,t,s,a)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadStorage",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:s,needs:a,workResult:i}),i==OK?this.assignDropOff(e,s):this.cancelAction(e),i}),this.loadLab=(e=>{let t=e.target,r=e.room,o=null,i=null,s=0;if((s=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0)i=RESOURCE_ENERGY;else{let r=this.getLabOrder(t);r&&(i=r.type),(s=t.getNeeds(i))>0&&(e.carry[i]||0)>0||(i=null)}return i&&(o=this.loadStructure(e,t,i,s)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadLab",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:s,workResult:o}),(e.carry[i]||0)>1?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadPowerSpawn=(e=>{let t=e.target,r=e.room,o=null,i=null,s=0;return r.memory.resources&&void 0===r.memory.resources.powerSpawn&&(r.memory.resources.powerSpawn=[]),(s=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0?i=RESOURCE_ENERGY:(s=t.getNeeds(RESOURCE_POWER))>0&&(e.carry[RESOURCE_POWER]||0)>0&&(i=RESOURCE_POWER),i&&(o=this.loadStructure(e,t,i,s)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadPowerSpawn",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:s,workResult:o}),(e.carry[i]||0)>s?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadNuker=(e=>{let t=e.target,r=e.room;var o=null,i=null,s=0;return r.memory.resources&&void 0===r.memory.resources.nuker&&(r.memory.resources.nuker=[]),(s=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0?i=RESOURCE_ENERGY:(s=t.getNeeds(RESOURCE_GHODIUM))>0&&(e.carry[RESOURCE_GHODIUM]||0)>0&&(i=RESOURCE_GHODIUM),i&&(o=this.loadStructure(e,t,i,s)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadNuker",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:s,workResult:o}),(e.carry[i]||0)>s?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadContainer=(e=>{let t=e.target,r=e.room,o=null,i=null,s=0;for(let r in e.carry)if((!r||0!=e.carry[r])&&(s=t.getNeeds(r))>0){i=r;break}return i&&(o=this.loadStructure(e,t,i,s)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadContainer",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:s,workResult:o}),(e.carry[i]||0)>s?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadTerminal=(e=>{let t=e.target,r=e.room,o=null,i=null,s=0;for(let r in e.carry)if(!r||0!=e.carry[r]){if((s=t.getNeeds(r))>0){i=r;break}if(r!=RESOURCE_ENERGY&&r!=RESOURCE_POWER){i=r,s=t.storeCapacity-t.sum;break}}return i&&(o=this.loadStructure(e,t,i,s)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadTerminal",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:s,workResult:o}),(e.carry[i]||0)>s?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadStorage=(e=>{let t=e.target,r=e.room,o=null,i=null,s=0;for(let r in e.carry)if((!r||0!=e.carry[r])&&(s=t.getNeeds(r))>0){i=r;break}return i&&(o=this.loadStructure(e,t,i,s)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadStorage",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:s,workResult:o}),(e.carry[i]||0)>s?this.assignDropOff(e,i):this.cancelAction(e),o}),this.work=(e=>{let t=null,r=e.room,o=e.target;if(r.storage,r.terminal,0==e.sum)switch(o.structureType){case STRUCTURE_LAB:t=this.unloadLab(e);break;case STRUCTURE_POWER_SPAWN:this.cancelAction(e);break;case STRUCTURE_CONTAINER:t=this.unloadContainer(e);break;case STRUCTURE_TERMINAL:t=this.unloadTerminal(e);break;case STRUCTURE_STORAGE:t=this.unloadStorage(e);break;default:this.cancelAction(e)}else switch(o.structureType){case STRUCTURE_LAB:t=this.loadLab(e);break;case STRUCTURE_POWER_SPAWN:t=this.loadPowerSpawn(e);break;case STRUCTURE_NUKER:t=this.loadNuker(e);break;case STRUCTURE_CONTAINER:t=this.loadContainer(e);break;case STRUCTURE_TERMINAL:t=this.loadTerminal(e);break;case STRUCTURE_STORAGE:t=this.loadStorage(e);break;default:this.cancelAction(e)}return t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("recycling"),this.isValidAction=(()=>!0),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t=null;return e.room.my&&e.room.structures.spawns.length>0&&(t=e.pos.findClosestByRange(e.room.structures.spawns)),null==t&&(t=Game.spawns[e.data.motherSpawn]),null==t&&(t=e.pos.findClosestSpawn()),t}),this.work=(e=>{e.target.recycleCreep(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("repairing"),this.targetRange=3,this.maxPerTarget=1,this.reachedRange=(e=>e.getStrategyHandler([this.name],"reachedRange",e)),this.isValidAction=(e=>e.carry.energy>0),this.isValidTarget=(e=>null!=e&&e.hits&&e.hits<e.hitsMax),this.isAddableTarget=((e,t)=>(e instanceof OwnedStructure&&e.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>_.find(e.room.structures.urgentRepairable,t=>this.isAddableTarget(t,e))),this.work=(e=>(e.getStrategyHandler([this.name],"getEnergy",e),e.repair(e.target))),this.setDefault({eachedRange:1,getEnergy:e=>!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("reserving"),this.isValidAction=(e=>!0),this.isValidTarget=(e=>e&&(!e.reservation||e.reservation.ticksToEnd<4999)),this.isAddableAction=(()=>!0),this.isAddableTarget=((e,t)=>e&&(e instanceof Flag||"controller"===e.structureType&&!e.owner)),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName]),t||(t=Flag.find(e=>Flag.compare(e,FLAG_COLOR.claim.reserve)||Flag.compare(e,FLAG_COLOR.invade.exploit),e.pos,!1,Flag.reserveMod,e.name)),t?(Population.registerCreepFlag(e,t),e.flag.room&&e.flag.pos.roomName==e.pos.roomName?e.flag.room.controller:e.flag):null}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),e.travelTo(e.target.pos);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);return r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e}),r}return e.travelTo(e.target.pos)}),this.work=(e=>{let t;return e.controllerSign(),t=e.target.owner&&!e.target.my?e.attackController(e.target):e.reserveController(e.target)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("robbing"),this.maxPerTarget=2,this.maxPerAction=10,this.scoreMultiplier=1/Math.log(1.2),this.minimumTTL=500,this.isValidAction=(e=>e.sum<.95*e.carryCapacity&&!e.room.my),this.isValidTarget=(e=>!_.some(e.pos.lookFor(LOOK_STRUCTURES),{structureType:STRUCTURE_RAMPART,isPublic:!1,my:!1})&&e.structureType!==STRUCTURE_NUKER&&e.structureType!==STRUCTURE_POWER_SPAWN&&(e.store||e.energy||e.mineralAmount)),this.newTarget=(e=>{const t=e.room.structures.all;if(t.length){const r=_.chain(t).filter(e=>this.isValidTarget(e)).map(this.targetScore(e)).filter("score").sortBy("score").reverse().value();return _.get(r,[0,"target"],null)}return!1}),this.work=(e=>{const t=e.getStrategyHandler([this.name],"resourceValue",e),r=_.chain(Util.resources()).filter(t).sortBy(t).values().value();return this.targetCall(e,r,t=>(r,o,i)=>{const s=o?e.withdraw(t,r,o):0;return s?{amount:i,score:s}:{amount:o,score:s}})(e.target)}),this.targetScore=(e=>{const t=e.getStrategyHandler([this.name],"resourceValue",e),r=_.chain(Util.resources()).filter(t).sortBy(t).values().value();return this.targetCall(e,r,r=>e.getStrategyHandler([this.name],"resourceScore",e,r,t))}),this.targetCall=((e,t,r)=>o=>{const i=r(o);let s=0;return{target:o,score:s=o.store?this.storeCall(e,o,o.store,Util.valueOrZero,i,t):o.structureType===STRUCTURE_LAB?this.storeCall(e,o,{[RESOURCE_ENERGY]:o.energy,[o.mineralType]:o.mineralAmount},Util.valueOrZero,i):this.storeCall(e,o,{[RESOURCE_ENERGY]:o.energy},Util.valueOrZero,i)}}),this.storeCall=((e,t,r,o,i,s)=>{let a=e.carryCapacity-e.sum,n=0;s||(s=_.keys(r));for(let e=s.length-1;e>=0&&0!==a;e--){const t=s[e],l=Math.min(o(r[t]),a),{amount:m,score:c}=i(t,l<1?0:l,a);a-=m,n+=c}return n}),this.setDefault({moveOptions:e=>e,resourceValue:e=>{let t=e.ticksToLive<this.minimumTTL;if(!t&&e.data.homeRoom){const r=Game.rooms[e.data.homeRoom];t=r&&!r.storage}return t?e=>e===RESOURCE_ENERGY?1:0:e=>e===RESOURCE_ENERGY?.2:e===RESOURCE_POWER?500:e.length},resourceScore:(e,t,r)=>{const o=e.pos.getRangeTo(t),i=this.scoreMultiplier;return(e,t,s)=>0===t?{amount:0,score:0}:{amount:t,score:r(e)*t*(50-Math.log1p(o)*i)}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("safeGen"),this.maxPerAction=1,this.isValidAction=(e=>e.carryCapacity-_.sum(e.carry)>=1e3||e.carry[RESOURCE_GHODIUM]&&e.carry[RESOURCE_GHODIUM]>=1e3),this.newTarget=(e=>{let t=null;return!e.carry[RESOURCE_GHODIUM]||e.carry[RESOURCE_GHODIUM]<1e3?e.room.storage&&e.room.storage.store[RESOURCE_GHODIUM]&&e.room.storage.store[RESOURCE_GHODIUM]>=1e3?t=e.room.storage:e.room.terminal&&e.room.terminal.store[RESOURCE_GHODIUM]&&e.room.terminal.store[RESOURCE_GHODIUM]>=1e3&&(t=e.room.terminal):t=e.room.controller,t}),this.unloadStructure=(e=>{let t=0;return t=e.carry[RESOURCE_GHODIUM]?1e3-e.carry[RESOURCE_GHODIUM]:1e3,e.withdraw(e.target,RESOURCE_GHODIUM,t)}),this.generateSafeMode=(e=>e.generateSafeMode(e.target)),this.work=(e=>{let t=null;switch(e.target.structureType){case STRUCTURE_STORAGE:case STRUCTURE_TERMINAL:t=this.unloadStructure(e);break;case STRUCTURE_CONTROLLER:t=this.generateSafeMode(e);break;default:"safeGen"==e.data.creepType&&Game.flags[e.data.destiny.targetName]&&Game.flags[e.data.destiny.targetName].remove(),this.cancelAction(e)}return t}),this.cancelAction=(e=>{delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,delete e.data.path})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("storing"),this.isValidAction=(e=>e.room.storage&&e.room.storage.isActive()&&e.sum>0),this.isValidTarget=(e=>e&&e.store&&e.active&&e.sum<e.storeCapacity),this.isAddableTarget=((e,t)=>e.my&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)&&e.sum+t.carry[RESOURCE_ENERGY]<e.storeCapacity),this.isValidMineralToTerminal=(e=>e.storage.store[e.mineralType]&&e.storage.store[e.mineralType]>1.05*MAX_STORAGE_MINERAL&&e.terminal.sum-e.terminal.store.energy+Math.max(e.terminal.store.energy,TERMINAL_ENERGY)<e.terminal.storeCapacity),this.newTarget=(e=>{let t=e.room.mineralType;return e.room.terminal&&e.room.terminal.active&&((e=>e.carry[t]&&e.carry[t]>0&&this.isValidMineralToTerminal(e.room))(e)||(e=>e.carry.energy>0&&e.room.storage.charge>.5&&e.room.terminal.store.energy<.95*TERMINAL_ENERGY&&e.room.terminal.sum<e.room.terminal.storeCapacity)(e))&&this.isAddableTarget(e.room.terminal,e)?e.room.terminal:this.isValidTarget(e.room.storage)&&this.isAddableTarget(e.room.storage,e)?e.room.storage:null}),this.work=(e=>{let t;for(let r in e.carry)if(e.carry[r]>0&&(t=e.transfer(e.target,r))!=OK)break;return delete e.data.actionName,delete e.data.targetId,t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("travelling"),this.isValidTarget=(e=>null!==e),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>e.getStrategyHandler([this.name],"newTarget",e)),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC);let t=_.get(e,["data","travelRange"],this.targetRange),r=e.target;if(Flag.isSpecialFlag(e.target))if(e.data.travelRoom){const o=Game.rooms[e.data.travelRoom];o&&o.name===e.pos.roomName?(e.leaveBorder(),r=null):(t=_.get(e,["data","travelRange"],TRAVELLING_BORDER_RANGE||22),r=new RoomPosition(25,25,e.data.travelRoom))}else Log.error(e.name+"Creep.action.travelling called with specialFlag target and travelRoom undefined."),r=null;if(r){if(e.pos.getRangeTo(r)<=t)return this.unregister(e);if(0===t&&e.pos.isNearTo(r)&&r.pos.lookFor(LOOK_CREEPS).length>0)return Log.module(e.name,"travelling.step: destination blocked, stopping."),this.unregister(e);e.travelTo(r,{range:t,ignoreCreeps:e.data.ignoreCreeps||!0})}else this.unregister(e)}),this.assignRoom=((e,t)=>{if(t)return _.isUndefined(e.data.travelRange)&&(e.data.travelRange=TRAVELLING_BORDER_RANGE||22),e.data.travelRoom=t,LOG_TRACE&&Log.trace("Action",{creepName:e.name,assign:this.name,roomName:t,Action:"assign"}),this.assign(e,Flag.specialFlag());Log.error(e.name+"Creep.action.travelling.assignRoom called with no room.")}),this.unregister=(e=>{delete e.action,delete e.target,delete e.data.actionName,delete e.data.ignoreCreeps,delete e.data.targetId,delete e.data.travelRoom,delete e.data.travelRange}),this.setDefault({newTarget:e=>e.data.travelPos||e.data.travelRoom?Flag.specialFlag():null})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("uncharging"),this.renewTarget=!1,this.maxPerTarget=1,this.isAddableAction=(e=>!0),this.isValidAction=(e=>e.getStrategyHandler([this.name],"isValidAction",e)),this.isValidTarget=((e,t)=>{if(!e)return!1;if("link"==e.structureType)return e.energy>0;if("container"==e.structureType){let r=0;return r=!0===e.source&&1==e.controller?e.storeCapacity*MANAGED_CONTAINER_TRIGGER:t.data.creepType.indexOf("remote")>=0?250:500,e.sum>r}return!1}),this.newTarget=(e=>{if(e.room.structures.links.storage.length>0){let t=e.room.structures.links.storage.find(e=>e.energy>0);if(t&&(!e.room.structures.links.controller.find(e=>e.energy<.15*e.energyCapacity)||t.energy<=.85*t.energyCapacity))return t}if(e.room.structures.container.in.length>0){let t;t=e.data.creepType.indexOf("remote")>=0?250:500;let r=null,o=0,i=i=>{if(this.isValidTarget(i,e)){let s=i.sum;if(i.targetOf&&(s-=_.sum(i.targetOf.map(e=>"uncharging"==e.actionName?e.carryCapacityLeft:0))),s<Math.min(e.carryCapacity-e.sum,t))return;s>o&&(o=s,r=i)}};return _.forEach(e.room.structures.container.in,i),r}}),this.work=(e=>{let t=OK;if(!0===e.target.source&&1==e.target.controller){let r=e.target.sum-e.target.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);if(r<1)t=ERR_NOT_ENOUGH_RESOURCES;else{let o=e.carryCapacity-e.sum,i=_.min([e.target.store.energy,r,o]);e.target._sum-=i,t=e.withdraw(e.target,RESOURCE_ENERGY,i)}}else if(null!=e.target.store){let r=r=>{e.target.store[r]>0&&(t=e.withdraw(e.target,r))};_.forEach(Object.keys(e.target.store),r)}else t=e.withdraw(e.target,RESOURCE_ENERGY);return delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,t}),this.setDefault({isValidAction:e=>e.sum<e.carryCapacity||!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("upgrading"),this.targetRange=3,this.reachedRange=3,this.isAddableAction=(e=>!e.room.storage||e.room.storage.charge>1||!e.room.storage.my&&e.room.storage.store.energy>0),this.isAddableTarget=((e,t)=>!!(8!==e.level||t.data&&"upgrader"===t.data.creepType)),this.isValidAction=(e=>e.carry.energy>0),this.isValidTarget=(e=>e&&"controller"===e.structureType&&e.my),this.newTarget=(e=>{const t=e.room.controller&&e.room.controller.my?e.room.controller:null;return this.isValidTarget(t)&&this.isAddableTarget(t,e)&&t}),this.work=((e,t)=>(t&&t<2&&e.controllerSign(),e.upgradeController(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("withdrawing"),this.isValidAction=(e=>e.getStrategyHandler([this.name],"isValidAction",e)),this.isValidTarget=(e=>!(e instanceof StructureTerminal&&e.charge<=0)&&e&&!!e.store&&e.store[RESOURCE_ENERGY]),this.newTarget=(e=>{const t=e.room.terminal,r=e.room.storage,o=[];return t&&this.isValidTarget(t)?o.push(t):r&&this.isValidTarget(r)&&o.push(r),!!o.length&&_.max(o,"charge")}),this.work=(e=>e.withdraw(e.target,RESOURCE_ENERGY)),this.assignDebounce=((e,t,r)=>{const o=r||this.newTarget(e);if(o){if(!(o instanceof StructureStorage&&"storing"===e.data.lastAction&&e.data.lastTarget===e.room.storage.id))return this.assign(e,o);{const r={carry:{},owner:e.owner,pos:e.pos,room:e.room,sum:e.carryCapacity},i=e.room.storage.store[RESOURCE_ENERGY],s=i>e.carryCapacity?e.carryCapacity:i;r.carry[RESOURCE_ENERGY]=s;let a=null;const n=_.find(t,e=>!("storing"===e.name||!e.isValidAction(r)||!e.isAddableAction(r)||!(a=e.newTarget(r))));if(n&&this.assign(e,o))return e.data.nextAction=n.name,e.data.nextTarget=a.id,!0}}return!1}),this.setDefault({isValidAction:e=>!!((e.room.storage&&e.room.storage.store[RESOURCE_ENERGY]||e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY])&&"privateer"!==e.data.creepType&&e.sum<e.carryCapacity&&(!e.room.conserveForDefense||e.room.relativeEnergyAvailable<.8))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("claimer"),this.actions=(e=>[Creep.action.claiming,Creep.action.reserving,Creep.action.bulldozing]),this._run=this.run,this.run=(e=>{if(this._run(e),e.hits<e.hitsMax&&(!e.action||"travelling"!==e.action.name)&&e.data){if(!e.data.nearestHome||!Game.rooms[e.data.nearestHome]){const t=Room.bestSpawnRoomFor(e.pos.roomName);t&&(e.data.nearestHome=t.name)}e.data.nearestHome&&Creep.action.travelling.assignRoom(e,e.data.nearestHome)}LOG_TRACE&&Log.trace("Behaviour",{creepName:e.name,run:e.action&&e.action.name||"none",[this.name]:"run",Behaviour:this.name})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("collapseWorker"),this.inflowActions=(e=>{let t=[Creep.action.picking,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.harvesting,Creep.action.dismantling,Creep.action.reallocating];return e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t}),this.outflowActions=(e=>{const t=e.room.situation.invasion&&e.room.controller&&e.room.RCL>2;if(t)return[Creep.action.feeding,Creep.action.fueling,Creep.action.repairing];{let r=[Creep.action.feeding,Creep.action.fueling,Creep.action.charging,Creep.action.repairing,Creep.action.building,Creep.action.fortifying,Creep.action.upgrading];return t||(r.push(Creep.action.storing),r.push(Creep.action.dropping)),e.room.controller&&e.room.controller.ticksToDowngrade<500&&r.unshift(Creep.action.upgrading),r}}),this.needEnergy=(e=>Creep.behaviour.worker.needEnergy(e)),this.nextAction=(e=>e.pos.roomName!==e.data.homeRoom?(LOG_TRACE&&Log.trace("Behaviour",{actionName:"travelling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!0):!e.room.collapsed&&(Util.set(e,["data","recycleTick"],Game.time+50),Game.time>=e.data.recycleTick)?(LOG_TRACE&&Log.trace("Behaviour",{actionName:"recycling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),this.assignAction(e,"recycling")):Creep.behaviour.worker.nextAction(e)),this.mergeState({default:{canWithdrawEnergy:(e,t)=>e=>e>0}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("hauler"),this.inflowActions=(e=>[Creep.action.uncharging,Creep.action.picking,Creep.action.withdrawing,Creep.action.reallocating]),this.outflowActions=(e=>{let t=[Creep.action.feeding,Creep.action.charging,Creep.action.fueling,Creep.action.storing];return(e.sum>e.carry.energy||!e.room.situation.invasion&&SPAWN_DEFENSE_ON_ATTACK&&e.room.conserveForDefense&&e.room.relativeEnergyAvailable>.8)&&t.unshift(Creep.action.storing),e.room.structures.urgentRepairable.length>0&&t.unshift(Creep.action.fueling),t}),this.nextAction=(e=>e.pos.roomName!=e.data.homeRoom&&Game.rooms[e.data.homeRoom]&&Game.rooms[e.data.homeRoom].controller?Creep.action.travelling.assignRoom(e,e.data.homeRoom):this.nextEnergyAction(e)),this.setState({picking:{name:`picking-${this.name}`,energyOnly:!1}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("healer"),this.actions=(e=>[Creep.action.healing,Creep.action.guarding]),this._invalidAction=this.invalidAction,this.invalidAction=(e=>this._invalidAction(e)||"guarding"===e.action.name)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("labTech"),this.inflowActions=(e=>[Creep.action.reallocating,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.picking]),this.outflowActions=(e=>{let t=[Creep.action.storing,Creep.action.charging,Creep.action.fueling,Creep.action.feeding];return(e.sum>e.carry.energy||!e.room.situation.invasion&&SPAWN_DEFENSE_ON_ATTACK&&e.room.conserveForDefense&&e.room.relativeEnergyAvailable>.8)&&t.unshift(Creep.action.storing),e.room.structures.urgentRepairable.length>0&&t.unshift(Creep.action.fueling),t}),this.nextAction=(e=>Creep.behaviour.hauler.nextAction(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("melee"),this.heal=(e=>{!e.attacking&&void 0!==e.data.body.heal&&e.hits<e.hitsMax&&e.heal(e)}),this.actions=(e=>[Creep.action.defending,Creep.action.invading,Creep.action.guarding]),this._invalidAction=this.invalidAction,this._run=this.run,this.setState({healing:{moveOptions:e=>(e.respectRamparts=!0,e)}}),this.invalidAction=(e=>this._invalidAction(e)||"guarding"===e.action.name&&(!e.flag||e.flag.pos.roomName===e.pos.roomName||e.leaveBorder())),this.run=(e=>{e.flee=e.flee||!e.hasActiveBodyparts([ATTACK,RANGED_ATTACK]),e.attacking=!1,e.attackingRanged=!1,this._run(e),this.heal(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("miner"),this.actions=(e=>[Creep.action.mining,Creep.action.recycling])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("mineralMiner"),this.actions=(e=>Creep.behaviour.miner.actions(e)),this.getEnergy=(e=>Creep.behaviour.miner.getEnergy(e)),this.maintain=(e=>Creep.behaviour.miner.maintain(e)),this.setState({mining:{newTarget:e=>_.find(e.room.minerals,t=>!_.find(Memory.population,r=>r.creepName!==e.name&&r.determinatedTarget===t.id))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteMiner"),this.actions=(e=>Creep.behaviour.miner.actions(e)),this.getEnergy=(e=>Creep.behaviour.miner.getEnergy(e)),this.maintain=(e=>Creep.behaviour.miner.maintain(e)),this._run=this.run,this.run=(e=>{if(!Creep.action.avoiding.run(e)){const t=e.data.destiny&&Game.flags[e.data.destiny.targetName];t?e.room.name!==e.data.destiny.room&&Creep.action.travelling.assignRoom(e,t.pos.roomName):e.action&&"recycling"===e.action.name||this.assignAction(e,"recycling"),this._run(e)}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteHauler"),this.nextAction=(e=>{if(!e.data.destiny||!Game.flags[e.data.destiny.targetName])return Creep.action.recycling.assign(e);if(e.pos.roomName==e.data.homeRoom){if(e.sum>0){let t=[];if(e.carry.energy==e.sum&&(t=e.room.structures.links.privateers),e.room.storage&&t.push(e.room.storage),e.room.structures.container&&(t=t.concat(e.room.structures.container.privateers)),t.length>0){let r=e.pos.findClosestByRange(t);if(r.structureType==STRUCTURE_STORAGE&&this.assignAction(e,"storing",r))return;if(this.assignAction(e,"charging",r))return;if(this.assignAction(e,"storing"))return}if(this.assignAction(e,"charging"))return;if(this.assignAction(e,"feeding"))return;if(this.assignAction(e,"dropping"))return;{const t=t=>{e.carry[t]>0&&e.drop(t)};return _.forEach(Object.keys(e.carry),t),this.assignAction(e,"idle")}}if(this.gotoTargetRoom(e))return}else{if(e.data.destiny.room==e.pos.roomName){if(e.sum/e.carryCapacity>REMOTE_HAULER.MIN_LOAD)return void this.goHome(e);if(this.assignAction(e,"uncharging"))return;if(this.assignAction(e,"picking"))return;if(0===e.sum){let t=e.pos.findClosestByRange(e.room.sources);if(e.room&&t&&e.pos.getRangeTo(t)>3)return e.data.travelRange=3,this.assignAction(e,"travelling",t)}return this.assignAction(e,"idle")}{let t=!1;if(t=e.sum/e.carryCapacity>REMOTE_HAULER.MIN_LOAD?this.goHome(e):this.gotoTargetRoom(e))return}}let t=Game.spawns[e.data.motherSpawn];t&&this.assignAction(e,Creep.action.recycling,t)}),this.gotoTargetRoom=(e=>{const t=e.data.destiny?Game.flags[e.data.destiny.targetName]:null;if(t)return Creep.action.travelling.assignRoom(e,t.pos.roomName)}),this.goHome=(e=>Creep.action.travelling.assignRoom(e,e.data.homeRoom)),this.setState({picking:{name:`picking-${this.name}`,energyOnly:!1}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteWorker"),this.inflowActions=(e=>[Creep.action.picking,Creep.action.uncharging,Creep.action.withdrawing,Creep.action.harvesting]),this.outflowActions=(e=>[Creep.action.repairing,Creep.action.building,Creep.action.recycling]),this.needEnergy=(e=>e.sum<.8*e.carryCapacity),this.nextAction=(e=>e.data.destiny&&Game.flags[e.data.destiny.targetName]||e.action&&"recycling"===e.action.name?e.data.destiny.room===e.pos.roomName?this.nextEnergyAction(e):this.gotoTargetRoom(e):this.assignAction(e,"recycling")),this.gotoTargetRoom=(e=>{const t=e.data.destiny?Game.flags[e.data.destiny.targetName]:null;if(t)return Creep.action.travelling.assignRoom(e,t.pos.roomName)}),this._run=this.run,this.run=(e=>{Creep.action.avoiding.run(e)||this._run(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("pioneer"),this.inflowActions=(e=>Creep.behaviour.worker.inflowActions(e)),this.outflowActions=(e=>{let t;return t=e.room.controller&&e.room.RCL<2?[Creep.action.feeding,Creep.action.upgrading,Creep.action.building,Creep.action.repairing,Creep.action.fueling,Creep.action.fortifying,Creep.action.charging,Creep.action.storing,Creep.action.picking]:[Creep.action.feeding,Creep.action.building,Creep.action.repairing,Creep.action.fueling,Creep.action.fortifying,Creep.action.charging,Creep.action.upgrading,Creep.action.storing,Creep.action.picking],e.room.controller&&e.room.controller.ticksToDowngrade<2e3&&t.unshift(Creep.action.upgrading),e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t}),this.nextAction=(e=>{let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t){if((!t.room||t.pos.roomName!=e.pos.roomName)&&Creep.action.travelling.assignRoom(e,t.pos.roomName))return Population.registerCreepFlag(e,t),!0;if(t.room&&t.room.my){let r=Flag.find(FLAG_COLOR.claim.spawn,e.pos,!0);if(r)if(r.room.structures.spawns&&r.room.structures.spawns.length>0){r.remove();let e=e=>Game.flags[e.name].remove();_.forEach(Flag.filter(FLAG_COLOR.invade.exploit,r.pos,!0),e)}else t.room.myConstructionSites.some(e=>e.structureType===STRUCTURE_SPAWN)||t.room.createConstructionSite(r,STRUCTURE_SPAWN)}}return this.nextEnergyAction(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("privateer"),this.nextAction=(e=>{let t=e.sum;if(e.pos.roomName==e.data.homeRoom){if(t>0){let r=[];if(e.carry.energy==t&&(r=e.room.structures.links.privateers),e.room.storage&&r.push(e.room.storage),e.room.structures.container&&(r=r.concat(e.room.structures.container.privateers)),r.length>0){let t=e.pos.findClosestByRange(r);if(t.structureType===STRUCTURE_STORAGE&&this.assignAction(e,"storing",t))return;if(this.assignAction(e,"charging",t))return}if(this.assignAction(e,"charging"))return;if(!e.room.ally&&this.assignAction(e,"storing"))return;return void Creep.behaviour.worker.nextAction(e)}this.exploitNextRoom(e)||Creep.behaviour.worker.nextAction(e)}else if(e.flag&&e.flag.pos.roomName==e.pos.roomName){if(e.room.situation.invasion&&!e.flag.compareTo(FLAG_COLOR.invade.robbing))return e.flag.cloaking=50,void this.exploitNextRoom(e);if(e.sum<.4*e.carryCapacity)if(0===e.room.sourceEnergyAvailable)e.flag.cloaking=_.max([e.room.ticksToNextRegeneration-20,0]),this.exploitNextRoom(e);else{let t=[Creep.action.dismantling,Creep.action.picking,Creep.action.robbing,Creep.action.harvesting];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}e.flag.cloaking=50,this.exploitNextRoom(e)}else{const t=[Creep.action.building];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}Population.registerCreepFlag(e,null),Creep.action.travelling.assignRoom(e,e.data.homeRoom)}}else this.exploitNextRoom(e)}),this.exploitNextRoom=(e=>{if(e.sum<.4*e.carryCapacity){const t=e=>Flag.compare(e,FLAG_COLOR.invade.exploit)||Flag.compare(e,FLAG_COLOR.invade.robbing),r=Flag.find(t,new RoomPosition(25,25,e.data.homeRoom),!1,Flag.exploitMod,e.name);if(r&&Creep.action.travelling.assignRoom(e,r.pos.roomName))return Population.registerCreepFlag(e,r),!0}return Population.registerCreepFlag(e,null),e.room.name!==e.data.homeRoom&&Creep.action.travelling.assignRoom(e,e.data.homeRoom),!1}),this._invalidAction=this.invalidAction,this._run=this.run,this.setState({withdrawing:{name:`withdrawing-${this.name}`,isValidAction:e=>!1}}),this.invalidAction=(e=>this._invalidAction(e)||!e.flag),this.run=(e=>{if(this._run(e),e.hits<e.hitsMax&&(!e.action||"travelling"!==e.action.name)&&e.data){if(!e.data.nearestHome||!Game.rooms[e.data.nearestHome]){const t=Room.bestSpawnRoomFor(e.pos.roomName);t&&(e.data.nearestHome=t.name)}e.data.nearestHome&&Creep.action.travelling.assignRoom(e,e.data.nearestHome)}LOG_TRACE&&Log.trace("Behaviour",{creepName:e.name,run:e.action&&e.action.name||"none",[this.name]:"run",Behaviour:this.name})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("recycler"),this.actions=(e=>[Creep.action.picking,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.travelling,Creep.action.storing,Creep.action.feeding,Creep.action.dropping,Creep.action.recycling,Creep.action.idle]),this._invalidAction=this.invalidAction,this.setState({recycling:{name:`recycling-${this.name}`,isValidAction:e=>!e.sum},uncharging:{name:`uncharging-${this.name}`,isValidAction:e=>e.data.travelRoom&&e.sum<e.carryCapacity||!1},withdrawing:{name:`withdrawing-${this.name}`,isValidAction:e=>e.data.travelRoom&&e.room.storage&&e.room.storage.store.energy>0&&e.sum<e.carryCapacity||!1},travelling:{name:`travelling-${this.name}`,newTarget:e=>{if(!e.data.travelRoom)if(e.data.travelPos)e.data.travelRoom=e.data.travelPos.roomName;else{if(e.room.structures.spawns.length)return null;e.data.travelRoom=e.data.homeRoom}const t=Game.rooms[e.data.travelRoom];let r=t&&(t.storage||t.structures.spawns[0]);return r||e}}}),this.invalidAction=(e=>!(!this._invalidAction(e)&&e.action.isMember(this.actions())||(delete e.data.targetId,delete e.data.path,0)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("ranger"),this.heal=(e=>{!e.attacking&&void 0!==e.data.body.heal&&e.hits<e.hitsMax&&e.heal(e)}),this.actions=(e=>[Creep.action.defending,Creep.action.invading,Creep.action.guarding]),this._run=this.run,this.setState({healing:{moveOptions:e=>(e.respectRamparts=!0,e)}}),this.run=(e=>{e.flee=e.flee||!e.hasActiveBodyparts([ATTACK,RANGED_ATTACK]),e.attacking=!1,e.attackingRanged=!1,this._run(e),this.heal(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("upgrader"),this.invalidCreep=(e=>["miner","upgrader"].includes(e.data.creepType)&&e.data.determinatedSpot&&(e.data.ttl>e.data.spawningTime||e.data.ttl>e.data.predictedRenewal)),this.approach=(e=>{let t=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,e.pos.roomName),r=e.pos.getRangeTo(t);if(r>0){e.data.movingToTarget=!0;const o=t.lookFor(LOOK_CREEPS),i=o.length?1:0;1===r&&o.length&&_.some(o,this.invalidCreep)&&delete e.data.determinatedSpot,e.travelTo(t,{range:i})}else e.data.movingToTarget&&(e.room.invalidateCostMatrix(),delete e.data.movingToTarget);return r}),this.run=(e=>{if(e.room.controller.upgradeBlocked)e.data.creepType="recycler";else{if(e.action&&"upgrading"===e.action.name||Population.registerAction(e,Creep.action.upgrading,e.room.controller),!e.data.determinatedSpot){let t=(t=!1)=>{let r=r=>{let o={spots:[{pos:e.room.controller.pos,range:3},{pos:r.pos,range:1}],checkWalkable:!0,where:r=>!_.some(r.lookFor(LOOK_CREEPS),this.invalidCreep)&&(t||0===r.findInRange(e.room.sources,1).length),roomName:e.pos.roomName};return Room.fieldsInRange(o)},o=e.room.structures.links.controller?_.flatten(_.map(e.room.structures.links.controller,r)):[],i=e.room.structures.container.controller?_.flatten(_.map(e.room.structures.container.controller,r)):[],s=e.room.storage?r(e.room.storage):[],a=e.room.terminal?r(e.room.terminal):[];if(o.length){let e=[];return 0===e.length&&i.length&&(e=_.filter(o,e=>_.some(i,t=>t.isEqualTo(e)))),0===e.length&&s.length&&(e=_.filter(o,e=>_.some(s,t=>t.isEqualTo(e)))),0===e.length&&a.length&&(e=_.filter(o,e=>_.some(a,t=>t.isEqualTo(e)))),e.length?e:o}return i.length?i:s.length?s:a},r=t();if(r.length>0&&(r=t(!0)),r.length>0){let t=e.pos.findClosestByPath(r,{filter:t=>!_.some(e.room.lookForAt(LOOK_STRUCTURES,t),{structureType:STRUCTURE_ROAD})});if(t||(t=e.pos.findClosestByPath(r)||r[0]),t){e.data.determinatedSpot={x:t.x,y:t.y};let r=Game.spawns[e.data.motherSpawn];if(r){let o=t.findPathTo(r,{ignoreCreeps:!0});const i=e.data.body?Math.ceil(e.data.body.work/(2*e.data.body.move)):1;o&&(e.data.predictedRenewal=e.data.spawningTime+o.length*i)}}}e.data.determinatedSpot?SAY_ASSIGNMENT&&e.say(String.fromCharCode(9962),SAY_PUBLIC):Log.error("Unable to determine working location for upgrader in room "+e.pos.roomName)}if(e.data.determinatedSpot&&(CHATTY&&e.say("upgrading",SAY_PUBLIC),this.approach(e),e.room.controller&&e.pos.getRangeTo(e.room.controller)<=3)){let t=e.data.body&&e.data.body.work?e.data.body.work:e.carryCapacity/2;if(e.carry.energy<=t){let t=_.find(e.room.structures.links.controller,t=>t.energy>0&&e.pos.isNearTo(t));t||(t=_.find(e.room.structures.container.controller,t=>t.store[RESOURCE_ENERGY]>0&&e.pos.isNearTo(t))),t||(t=e.room.storage&&e.room.storage.charge>0&&e.pos.isNearTo(e.room.storage)),t||(t=e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY]>.5*TERMINAL_ENERGY&&e.pos.isNearTo(e.room.terminal)),t&&e.withdraw(t,RESOURCE_ENERGY)}e.controllerSign(),e.upgradeController(e.room.controller)}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("worker"),this.inflowActions=(e=>{let t=[Creep.action.bulldozing,Creep.action.picking,Creep.action.dismantling,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.harvesting,Creep.action.reallocating];return e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t}),this.outflowActions=(e=>{if(e.room.situation.invasion&&e.room.controller&&e.room.RCL>2)return[Creep.action.fueling,Creep.action.feeding,Creep.action.repairing];{let t=[Creep.action.repairing,Creep.action.feeding,Creep.action.building,Creep.action.fueling,Creep.action.fortifying,Creep.action.charging,Creep.action.upgrading,Creep.action.storing];const r=e=>{const t=e.population&&e.population.typeCount;return!t.hauler||t.hauler<1||!t.miner||t.miner<1};return e.room.relativeEnergyAvailable<1&&r(e.room)&&t.unshift(Creep.action.feeding),e.room.controller&&e.room.controller.ticksToDowngrade<2e3&&t.unshift(Creep.action.upgrading),e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t.unshift(Creep.action.bulldozing),t}}),this.nextAction=(e=>"worker"==e.data.creepType&&e.pos.roomName!=e.data.homeRoom&&Game.rooms[e.data.homeRoom]&&Game.rooms[e.data.homeRoom].controller?(LOG_TRACE&&Log.trace("Behaviour",{actionName:"travelling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!0):this.nextEnergyAction(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("safeGen"),this.actions=(e=>[Creep.action.safeGen,Creep.action.recycling])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("hauler"),this.maxMulti=(e=>{let t=7;e.minerals.length>0&&(t+=2);let r=_.sum(e.structures.container.in,"sum");return r+=_.sum(e.droppedResources,"amount"),t+=Math.floor(r/1e3),t+=Creep.setup.upgrader._maxMulti(e),Math.min(t,16)}),this.maxCount=(e=>{if(!e.population)return 0;let t=0,r=e.population.typeCount.miner||0,o=e.population.typeCount.worker||0,i=e.population.typeCount.mineralMiner||0,s=e.structures.container.in.length+e.structures.links.storage.length;if(r>0||s>0&&o>Creep.setup.worker._maxCount(e)){e.storage&&e.storage.id===e.controller.memory.storage||(t+=Math.round(Creep.setup.upgrader._maxCount(e)/2)),(e.structures.links.all.length<3||e.storage&&e.storage.active&&e.storage.charge>1&&e.structures.container.controller&&0==_.sum(e.structures.container.controller,"store.energy"))&&t++,i>0&&t++;let r=0,o=t=>e.sources.some(e=>e.pos.x===t.x&&e.pos.y===t.y),s=e=>{e.resourceType===RESOURCE_ENERGY&&e.pos.adjacent.some(o)&&(r+=e.amount)};e.droppedResources.forEach(s),0===t&&(t=1)}return t}),this.maxWeight=(e=>2e3*this._maxCount(e)),this.minControllerLevel=2}get default(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],minAbsEnergyAvailable:200,minEnergyAvailable:.4,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e),maxWeight:e=>this.maxWeight(e)}}get high(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],minAbsEnergyAvailable:200,minEnergyAvailable:.1,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e),maxWeight:e=>this.maxWeight(e)}}get RCL(){return{1:this.none,2:this.none,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.high}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("healer"),this.minControllerLevel=7,this.globalMeasurement=!0}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.none,7:{fixedBody:[],multiBody:[MOVE,HEAL],minAbsEnergyAvailable:300,minEnergyAvailable:.8,maxMulti:4,maxCount:0,maxWeight:0},8:{fixedBody:[],multiBody:[MOVE,HEAL],minAbsEnergyAvailable:300,minEnergyAvailable:.8,maxMulti:4,maxCount:0,maxWeight:0}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("miner"),this.minControllerLevel=1}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:4},multiBody:[WORK,MOVE],minAbsEnergyAvailable:500,minEnergyAvailable:.3,maxMulti:2,maxCount:e=>e.sources.length}}get low(){return{fixedBody:[WORK,WORK,MOVE],multiBody:[WORK],minAbsEnergyAvailable:250,minEnergyAvailable:.9,maxMulti:3,maxCount:e=>e.sources.length}}get high(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:4},multiBody:[WORK,MOVE],minAbsEnergyAvailable:500,minEnergyAvailable:.1,maxMulti:2,maxCount:e=>e.sources.length}}get RCL(){return{1:this.low,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.high}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("mineralMiner"),this.maxCount=(e=>{if(e.memory.noMineralMiners)return 0;let t=0;if(0===(e.population.typeCount.hauler||0))return 0;if(e.storage&&e.storage.sum<.9*e.storage.storeCapacity){let r=e=>{e.mineralAmount>0&&t++};e.minerals.forEach(r)}return t}),this.minControllerLevel=6}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:3},multiBody:{[MOVE]:1,[WORK]:3},minAbsEnergyAvailable:750,minEnergyAvailable:.3,maxMulti:11,minMulti:1,maxCount:e=>this.maxCount(e)}}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("privateer"),this.minControllerLevel=3,this.globalMeasurement=!0,this.measureByHome=!0}get default(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[WORK,CARRY,MOVE],minAbsEnergyAvailable:400,minEnergyAvailable:.8,maxMulti:15,minMulti:e=>e.RCL,maxWeight:e=>e.privateerMaxWeight}}get RCL(){return{1:this.none,2:this.none,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("upgrader"),this.maxMulti=(e=>{let t=0;const r=e.storage&&e.storage.active?e.storage.charge:0;if((!e.storage||e.storage.active&&r>0)&&t++,(!e.storage||e.storage.active&&r>.5)&&t++,e.storage&&e.storage.active&&r>=1){let r=e.storage.store.energy-MAX_STORAGE_ENERGY[e.RCL];t+=Math.ceil(r/2e4)}return Math.min(11,t)}),this.maxCount=(e=>{const t=_.get(e,["memory","addUpgrader"],0);if(e.situation.invasion||e.conserveForDefense||e.structures.container.controller.length+e.structures.links.controller.length===0||e.controller.upgradeBlocked||e.myConstructionSites.length>0&&!e.storage)return 0;if(8==e.RCL)return 1;let r=0;if(e.structures.container.controller.forEach(e=>r+=e.store.energy),e.structures.links.controller.forEach(e=>r+=e.energy),0===r)return 0;if(e.storage&&e.storage.active)return t+Math.max(1,Math.floor((e.storage.store.energy-MAX_STORAGE_ENERGY[e.RCL])/35e4));if(e.droppedResources){let t=0,r=t=>e.sources.some(e=>e.pos.x===t.x&&e.pos.y===t.y),o=e=>{e.resourceType===RESOURCE_ENERGY&&e.pos.adjacent.some(r)&&(t+=e.amount)};e.droppedResources.forEach(o)}return t+2}),this.minControllerLevel=2}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:2},multiBody:{[MOVE]:1,[WORK]:3},minAbsEnergyAvailable:400,minEnergyAvailable:.5,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e)}}get low(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:2},multiBody:{[MOVE]:1,[WORK]:2},minAbsEnergyAvailable:300,minEnergyAvailable:1,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e)}}get level8(){return{fixedBody:{[CARRY]:1,[MOVE]:3},multiBody:[WORK],minAbsEnergyAvailable:1700,minEnergyAvailable:.5,maxMulti:CONTROLLER_MAX_UPGRADE_PER_TICK/UPGRADE_CONTROLLER_POWER,maxCount:e=>this.maxCount(e)}}get RCL(){return{1:this.none,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.level8}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("worker"),this.maxWorker=(e=>{let t=0;return(e.structures.fortifyable.length>0||e.isCriticallyFortifyable)&&(t++,e.storage&&e.storage.store.energy>4e5&&(t+=2)),e.RCL<4?e.situation.invasion?1:(2===e.RCL?3*e.sources.length:2*e.sources.length)-(e.population&&e.population.typeCount.pioneer||0):(this.hasMinerOrHauler(e)||t++,e.myConstructionSites.length>0&&(!e.storage||!e.storage.active||e.storage.store&&e.storage.charge>0)&&t<=1&&t++,t)}),this.hasMinerOrHauler=(e=>!!e.population&&(e.population.typeCount.hauler>0||e.population.typeCount.miner>0)),this.byPopulation=((e,t,r,o)=>{let i=t;return e.population&&(i+=e.population.typeCount[this.type]*r),!o||i<=o?i:o}),this.minEnergyAvailable=(e=>{switch(e.RCL){case 1:return this.byPopulation(e,0,1,1);case 2:return this.byPopulation(e,0,.8,1);case 3:return this.byPopulation(e,0,.6,1);case 4:return this.hasMinerOrHauler(e)?.5:0;case 7:return this.hasMinerOrHauler(e)?.2:1;default:return this.hasMinerOrHauler(e)?.1:1}}),this.maxMulti=((e,t,r,o)=>_.min([Math.floor((e.energyCapacityAvailable-t)/r),Math.floor(50/o)]))}get default(){return{fixedBody:[],multiBody:{[CARRY]:1,[WORK]:1,[MOVE]:1},minMulti:1,maxMulti:e=>this.maxMulti(e,0,200,_.size(this.default.multiBody)),maxWeight:9600,maxCount:e=>this.maxWorker(e),minEnergyAvailable:e=>this.minEnergyAvailable(e)}}get low(){return{fixedBody:[],multiBody:{[CARRY]:1,[WORK]:1,[MOVE]:2},minMulti:1,maxMulti:8,maxWeight:e=>2===e.RCL?14400:4e3,maxCount:e=>this.maxWorker(e),minEnergyAvailable:e=>this.minEnergyAvailable(e)}}get RCL(){return{1:this.low,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(2),s=r(8);t.default=new class extends o.Component{constructor(){super(...arguments),this.extend=(()=>{s.Strategy.decorateAgent(Creep.prototype,{default:e=>e.action&&e.action.name,selector:e=>Creep.action[e]},{default:e=>e.data.creepType,selector:e=>Creep.behaviour[e]&&Creep.behaviour[e]},{default:e=>e.data.destiny&&e.data.destiny.task,selector:e=>Task[e]&&Task[e]})}),this.fresh=(()=>{i.Install(Creep,{spawningStarted:new o.EventConstructor,spawningCompleted:new o.EventConstructor,predictedRenewal:new o.EventConstructor,died:new o.EventConstructor,error:new o.EventConstructor})}),this.register=(()=>{for(const e in Creep.action)Creep.action[e].register&&Creep.action[e].register(this);for(const e in Creep.behaviour)Creep.behaviour[e].register&&Creep.behaviour[e].register(this);for(const e in Creep.setup)Creep.setup[e].register&&Creep.setup[e].register(this)}),this.run=(()=>{Memory.CPU_CRITICAL&&Log.module("Creep",`${Game.time}: CPU Bucket level is critical (${Game.cpu.bucket}). Skipping non critical creep roles.`),_.forEach(Game.creeps,e=>{CPU_CHECK_CONFIG.CREEP&&CPU.check("Creep",e.name);try{e.run()}catch(t){Log.error(`[Creep] ${e.name} ${t.stack||t.toString()}`,Log.stack())}CPU_CHECK_CONFIG.CREEP&&CPU.end("Creep",e.name)})}),this.isWorkingAge=(e=>{const t=Game.creeps[e.creepName];return!t||(e.predictedRenewal||e.spawningTime||CREEP_LIFE_TIME)<=(t.ticksToLive||CREEP_LIFE_TIME)}),this.bodyCosts=(e=>{let t=0;return e&&e.forEach(function(e){t+=BODYPART_COST[e]}),t}),this.multi=((e,t={})=>{const r=t.minMulti||0,o=this.bodyCosts(t.fixedBody),i=this.bodyCosts(t.multiBody);if(0===i)return 0;let s=1/0;if(t.minThreat){const e=this.bodyThreat(t.fixedBody),r=this.bodyThreat(t.multiBody);s=0;let o=e;for(;o<t.minThreat;)s+=1,o+=r}let a=0;if(t.minWeight){let e=o;for(;e<t.minWeight;)a+=1,e+=i}const n=Math.floor((50-t.fixedBody.length)/t.multiBody.length),l=t.currentEnergy?e.energyAvailable:e.energyCapacityAvailable,m=Math.floor((l-o)/i),c=t.maxWeight?Math.floor((t.maxWeight-o)/i):1/0,u=t.maxMulti||1/0,d=_.min([m,s,c,u]),h=_.max([r,a,d]);return _.min([n,h])}),this.partsComparator=((e,t)=>{let r=[TOUGH,CLAIM,WORK,CARRY,ATTACK,RANGED_ATTACK,HEAL,MOVE];return r.indexOf(e)-r.indexOf(t)}),this.formatParts=(e=>{if(e&&!Array.isArray(e)&&"object"==typeof e){const t=[];for(const r of BODYPARTS_ALL)r in e&&t.push(..._.times(e[r],e=>r));e=t}return e}),this.formatBody=((e,t)=>({fixedBody:e=this.formatParts(e),multiBody:t=this.formatParts(t)})),this.compileBody=((e,t,r=!0)=>{const{fixedBody:o,multiBody:i}=this.formatBody(t.fixedBody||[],t.multiBody||[]);_.assign(t,{fixedBody:o,multiBody:i}),void 0!==t.sort&&(r=t.sort);let s=[];const a=this.multi(e,t);for(let e=0;e<a;e++)s=s.concat(t.multiBody);if(s=s.concat(t.fixedBody),r){const e="function"==typeof r?r:this.partsComparator;s.sort(e)}if(s.includes(HEAL)){let e=s.indexOf(HEAL);s.splice(e,1),s.push(HEAL)}return s}),this.bodyThreat=(e=>{let t=0;return e&&e.forEach(e=>{t+=CREEP_PART_THREAT[e.type?e.type:e][e.boost?"boosted":"common"]}),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(2);t.default=new class extends o.Component{constructor(){super(...arguments),this.pathfinderCache={},this.pathfinderCacheDirty=!1,this.pathfinderCacheLoaded=!1,this.COSTMATRIX_CACHE_VERSION=COMPRESS_COST_MATRICES?4:5,this.extend=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].extend&&Room.manager[e].extend()}),this.fresh=(()=>{i.Install(Room,{newInvader:new o.EventConstructor,knownInvader:new o.EventConstructor,goneInvader:new o.EventConstructor,collapsed:new o.EventConstructor,costMatrixInvalid:new o.EventConstructor,RCLChange:new o.EventConstructor});for(const e of Object.keys(Room.manager))Room.manager[e].fresh&&Room.manager[e].fresh();_.forEach(Game.rooms,e=>{for(const t of Object.keys(Room.manager))Room.manager[t].freshRoom&&Room.manager[t].freshRoom(e)})}),this.register=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].register&&Room.manager[e].register();Room.costMatrixInvalid.on(e=>this.rebuildCostMatrix(e.name||e)),Room.RCLChange.on(e=>e.structures.all.filter(e=>![STRUCTURE_ROAD,STRUCTURE_WALL,STRUCTURE_RAMPART].includes(e.structureType)).forEach(t=>{t.isActive()||_.set(e.memory,["structures",t.id,"active"],!1)}))}),this.analyze=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].analyze&&Room.manager[e].analyze();const e=e=>{try{const t=e.name,r=_.includes(CPU_CHECK_CONFIG.ROOM,t);for(const o of Object.keys(Room.manager))r&&CPU.check("analyze",t,o),Room.manager[o].analyzeRoom&&Room.manager[o].analyzeRoom(e,this.needMemoryResync(e)),r&&CPU.end("analyze",t,o);r&&CPU.check("analyze",t,"countMySites"),this.totalSitesChanged()&&e.countMySites(),r&&CPU.end("analyze",t,"countMySites"),r&&CPU.check("analyze",t,"countMyStructures"),this.totalStructuresChanged()&&e.countMyStructures(),r&&CPU.end("analyze",t,"countMyStructures"),e.checkRCL()}catch(t){Game.notify(t+"<br/>"+t.stack),Log.error(`Error in room.js (Room.prototype.loop) for "${e.name}":`,"<br/>",t.stack||t.toString(),"<br/>",t.stack)}};_.forEach(Game.rooms,t=>{t.skip||e(t)})}),this.run=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].run&&Room.manager[e].run();_.forEach(Memory.rooms,(e,t)=>{((e,t)=>{try{const r=_.includes(CPU_CHECK_CONFIG.ROOM,t);for(const o of Object.keys(Room.manager))r&&CPU.check("run",t,o),Room.manager[o].runRoom&&Room.manager[o].runRoom(e,t),r&&CPU.end("run",t,o);r&&CPU.check("run",t,"collapsed");const o=Game.rooms[t];o&&o.collapsed&&Room.collapsed.trigger(o),r&&CPU.end("run",t,"collapsed")}catch(e){Log.error(e.stack||e.message)}})(e,t),Game.time%MEMORY_RESYNC_INTERVAL!=0||Game.rooms[t]||"boolean"==typeof Memory.rooms[t].hostile||delete Memory.rooms[t]})}),this.cleanup=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].cleanup&&Room.manager[e].cleanup();if(_.isUndefined(Memory.pathfinder)||(CMemory.saveSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,Memory.pathfinder),delete Memory.pathfinder),this.pathfinderCacheDirty&&this.pathfinderCacheLoaded){let e={};for(const t in this.pathfinderCache){const r=this.pathfinderCache[t];r.version===this.COSTMATRIX_CACHE_VERSION&&(e[t]={serializedMatrix:r.serializedMatrix||(COMPRESS_COST_MATRICES?CompressedMatrix.serialize(r.costMatrix):r.costMatrix.serialize()),updated:r.updated,version:r.version},r.stale&&(e[t].stale=!0))}CMemory.saveSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,e),this.pathfinderCacheDirty=!1}}),this.totalSitesChanged=(()=>{let e;if(Game.time!==Memory.rooms.myTotalSitesChangeTime){const t=_.size(Game.constructionSites),r=Memory.rooms.myTotalSites||0;e=r&&r!==t,Memory.rooms.myTotalSitesChange=e,Memory.rooms.myTotalSitesChangeTime=Game.time,t>0?Memory.rooms.myTotalSites=t:delete Memory.rooms.myTotalSites}else e=Memory.rooms.myTotalSitesChange;return e}),this.totalStructuresChanged=(()=>{let e;if(Game.time!==Memory.rooms.myTotalStructuresChangeTime){const t=Object.keys(Game.structures).length,r=Memory.rooms.myTotalStructures||0;e=r&&r!==t,Memory.rooms.myTotalStructuresChange=e,Memory.rooms.myTotalStructuresChangeTime=Game.time,t>0?Memory.rooms.myTotalStructures=t:delete Memory.rooms.myTotalStructures}else e=Memory.rooms.myTotalStructuresChange;return e}),this.needMemoryResync=(e=>_.isUndefined(e.memory.initialized)?(e.memory.initialized=Game.time,!0):Game.time%MEMORY_RESYNC_INTERVAL==0||"sim"==e.name),this.routeCallback=((e,t,r)=>((_.isUndefined(e)||_.isUndefined(t))&&Log.error("Room.routeCallback","both origin and destination must be defined - origin:"+e+" destination:"+t),o=>{if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;if(o!==t&&ROUTE_ROOM_COST[Game.shard.name]&&ROUTE_ROOM_COST[Game.shard.name][o])return ROUTE_ROOM_COST[Game.shard.name][o];let i=!1;if(r.preferHighway){const e=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o);i=e[1]%10==0||e[2]%10==0}let s=!1;const a=_.get(Memory.rooms[o],"hostile",!1);if(r.checkOwner){const e=Game.rooms[o];s=!a||e&&e.controller&&(e.controller.my||void 0===e.controller.owner)}return!r.allowSK&&this.isSKRoom(o)?10:!r.allowHostile&&a&&o!==t&&o!==e?Number.POSITIVE_INFINITY:s||o==e||o==t?1:i?3:Game.map.isRoomAvailable(o)?r.checkOwner||r.preferHighway?11:1:Number.POSITIVE_INFINITY})),this.getCostMatrix=(e=>{let t=Game.rooms[e];if(t)return t.costMatrix}),this.isMine=(e=>{let t=Game.rooms[e];return t&&t.my}),this.calcCardinalDirection=(e=>{const t=/^([WE])[0-9]+([NS])[0-9]+$/.exec(e);return[t[1],t[2]]}),this.calcGlobalCoordinates=((e,t)=>{if(!t)return null;const r=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(e);return t(+r[1],+r[2])}),this.calcCoordinates=((e,t)=>t?this.calcGlobalCoordinates(e,(e,r)=>t(e%10,r%10)):null),this.isCenterRoom=(e=>Room.calcCoordinates(e,(e,t)=>5===e&&5===t)),this.isCenterNineRoom=(e=>Room.calcCoordinates(e,(e,t)=>e>3&&e<7&&t>3&&t<7)),this.isControllerRoom=(e=>Room.calcCoordinates(e,(e,t)=>0!==e&&0!==t&&(e<4||e>6||t<4||t>6))),this.isSKRoom=(e=>Room.calcCoordinates(e,(e,t)=>e>3&&e<7&&t>3&&t<7&&(5!==e||5!==t))),this.isHighwayRoom=(e=>Room.calcCoordinates(e,(e,t)=>0===e||0===t)),this.adjacentRooms=(e=>{let t=e.split(/([NESW])/),r=["N","E","S","W"],o=e=>r[(r.indexOf(e)+2)%4],i=[];for(let e=parseInt(t[2])-1;e<parseInt(t[2])+2;e++)for(let r=parseInt(t[4])-1;r<parseInt(t[4])+2;r++)i.push((e<0?o(t[1])+"0":t[1]+e)+(r<0?o(t[3])+"0":t[3]+r));return i}),this.adjacentAccessibleRooms=((e,t=!0)=>{let r=[],o=Game.map.describeExits(e);return _.forEach(o,(e,o)=>{if(t){let t=Game.map.describeExits(e),i=(o+1)%8+1,s=(o+5)%8+1;t&&t[i]&&!r.includes(t[i])&&r.push(t[i]),t&&t[s]&&!r.includes(t[s])&&r.push(t[s])}r.push(e)}),r}),this.roomDistance=((e,t,r,o)=>{if(r)return Game.map.getRoomLinearDistance(e,t,o);if(e==t)return 0;let i=e.split(/([NESW])/),s=t.split(/([NESW])/);return(i[1]==s[1]?Math.abs(i[2]-s[2]):i[2]+s[2]+1)+(i[3]==s[3]?Math.abs(i[4]-s[4]):i[4]+s[4]+1)}),this.rebuildCostMatrix=(e=>{Log.room(e,"Invalidating costmatrix to force a rebuild when we have vision."),_.set(Room,["pathfinderCache",e,"stale"],!0),_.set(Room,["pathfinderCache",e,"updated"],Game.time),this.pathfinderCacheDirty=!0}),this.loadCostMatrixCache=(e=>{let t=0;for(const r in e)(!this.pathfinderCache[r]||this.pathfinderCache[r].updated<e[r].updated)&&(t++,this.pathfinderCache[r]=e[r]);t>0&&Log.module("CMemory","loading pathfinder cache.. updated "+t+" stale entries."),this.pathfinderCacheLoaded=!0}),this.getCachedStructureMatrix=(e=>{if((e=>{if(_.isUndefined(this.pathfinderCache))return this.pathfinderCache={},this.pathfinderCache[e]={},!1;if(_.isUndefined(this.pathfinderCache[e]))return this.pathfinderCache[e]={},!1;const t=this.pathfinderCache[e],r=Game.time-t.updated;return!(t.version!==this.COSTMATRIX_CACHE_VERSION||!t.serializedMatrix&&!t.costMatrix||t.stale||!(r<COST_MATRIX_VALIDITY)||(LOG_TRACE&&Log.trace("PathFinder",{roomName:e,ttl:r,PathFinder:"CostMatrix"},"cached costmatrix"),0))})(e)){const t=this.pathfinderCache[e];if(t.costMatrix)return t.costMatrix;if(t.serializedMatrix){const e=COMPRESS_COST_MATRICES?CompressedMatrix.deserialize(t.serializedMatrix):PathFinder.CostMatrix.deserialize(t.serializedMatrix);return t.costMatrix=e,e}Log.error("Room.getCachedStructureMatrix",`Cached costmatrix for ${e} is invalid ${t}`),delete this.pathfinderCache[e]}}),this.getStructureMatrix=((e,t)=>{const r=Game.rooms[e];let o;return(o=this.isSKRoom(e)&&t.avoidSKCreeps?_.get(r,"avoidSKMatrix"):_.get(r,"structureMatrix"))||(o=_.get(this.getCachedStructureMatrix(e),"costMatrix")),o}),this.validFields=((e,t,r,o,i,s=!1,a=null)=>{const n=Game.rooms[e],l=s?n.lookAtArea(o,t,i,r):null;let m=[];for(let c=t;c<=r;c++)for(let t=o;t<=i;t++)if(c>1&&c<48&&t>1&&t<48&&(!s||n.isWalkable(c,t,l))){let r=new RoomPosition(c,t,e);a&&!a(r)||m.push(r)}return m}),this.fieldsInRange=(e=>{let t=e.spots.map(e=>e.pos.x+e.range),r=e.spots.map(e=>e.pos.y+e.range),o=e.spots.map(e=>e.pos.x-e.range),i=e.spots.map(e=>e.pos.y-e.range),s=Math.max(...o),a=Math.min(...t),n=Math.max(...i),l=Math.min(...r);return this.validFields(e.roomName,s,a,n,l,e.checkWalkable,e.where)}),this.shouldRepair=((e,t)=>t.hits<t.hitsMax&&(!e.my||t.hits<MAX_REPAIR_LIMIT[e.RCL]||t.hits<LIMIT_URGENT_REPAIRING+(2*DECAY_AMOUNT[t.structureType]||0))&&(!DECAYABLES.includes(t.structureType)||t.hitsMax-t.hits>GAP_REPAIR_DECAYABLE)&&(void 0===Memory.pavementArt[e.name]||Memory.pavementArt[e.name].indexOf("x"+t.pos.x+"y"+t.pos.y+"x")<0)&&!Flag.list.some(e=>e.roomName==t.pos.roomName&&e.color==COLOR_ORANGE&&e.x==t.pos.x&&e.y==t.pos.y))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("construction"),this.register=(()=>{Flag.found.on(e=>Room.roomLayout(e))}),this.analyzeRoom=((e,t)=>{t&&e.processConstructionFlags(),e.roadConstruction()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({constructionSites:{get(){return _.isUndefined(this._constructionSites)&&(this._constructionSites=this.find(FIND_CONSTRUCTION_SITES)),this._constructionSites}},myConstructionSites:{get(){return _.isUndefined(this._myConstructionSites)&&(this._myConstructionSites=this.find(FIND_MY_CONSTRUCTION_SITES)),this._myConstructionSites}},roadConstructionTrace:{get(){return _.isUndefined(this.memory.roadConstructionTrace)&&(this.memory.roadConstructionTrace={}),this.memory.roadConstructionTrace},set(e){this.memory.roadConstructionTrace=e}},getBestConstructionSiteFor:{value(e,t=null){let r;if(0==(r=t?this.constructionSites.filter(t):this.constructionSites).length)return null;let o=Util.fieldOrFunction(CONSTRUCTION_PRIORITY,this);return _.min(r,t=>{let r=o.indexOf(t.structureType);return e.getRangeTo(t)+(r<0?1e5:100*r)})}},roadConstruction:{value(e=ROAD_CONSTRUCTION_MIN_DEVIATION){const t=ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]&&-1!=ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name].indexOf(this.name);if(!ROAD_CONSTRUCTION_ENABLE&&!t||Game.time%ROAD_CONSTRUCTION_INTERVAL!=0)return;if(!t&&_.isNumber(ROAD_CONSTRUCTION_ENABLE)&&(!this.my||ROAD_CONSTRUCTION_ENABLE>this.controller.level))return;let r=Object.keys(this.roadConstructionTrace).map(e=>({n:this.roadConstructionTrace[e],x:e.charCodeAt(0)-32,y:e.charCodeAt(1)-32})),o=Math.max(ROAD_CONSTRUCTION_ABS_MIN,r.reduce((e,t)=>e+t.n,0)/r.length*e);r=r.filter(e=>{if(e.n>=o){let t=this.lookForAt(LOOK_STRUCTURES,e.x,e.y);return(0===t.length||t[0].structureType===STRUCTURE_RAMPART)&&0===this.lookForAt(LOOK_CONSTRUCTION_SITES,e.x,e.y).length}return!1}),_.forEach(r,e=>{Log.module(this.name,`Constructing new road at ${e.x}'${e.y} (${e.n} Log.traces)`),this.createConstructionSite(e.x,e.y,STRUCTURE_ROAD)}),this.roadConstructionTrace={}}},processConstructionFlags:{value(){if(!this.my||!Util.fieldOrFunction(SEMI_AUTOMATIC_CONSTRUCTION,this))return;let e=_.size(Game.constructionSites);if(e>=100)return;const t=this.controller.level,r=[new RoomPosition(25,25,this.name),!0],o=(t,r)=>{if(e>=100)return;if(!t)return;const o=new RoomPosition(t.x,t.y,t.roomName);if(!o)return;const i=o.lookFor(LOOK_CONSTRUCTION_SITES);if(i&&i.length)return;const s=o.lookFor(LOOK_STRUCTURES).filter(e=>!(e instanceof StructureRoad||e instanceof StructureRampart));if(s&&s.length)return;const a=o.createConstructionSite(r);Util.fieldOrFunction(REMOVE_CONSTRUCTION_FLAG,this,r)&&a===OK&&(t.name&&(t=Game.flags[t.name])instanceof Flag&&t.remove(),e++)};let i=CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][t]-(this.structures.extensions.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_EXTENSION).length);if(i>0&&Flag.filter(FLAG_COLOR.construct,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_EXTENSION)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_SPAWN][t]-(this.structures.spawns.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_SPAWN).length))>0&&Flag.filter(FLAG_COLOR.construct.spawn,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_SPAWN)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_TOWER][t]-(this.structures.towers.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_TOWER).length))>0&&Flag.filter(FLAG_COLOR.construct.tower,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_TOWER)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_LINK][t]-(this.structures.links.all.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_LINK).length))>0&&Flag.filter(FLAG_COLOR.construct.link,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_LINK)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_LAB][t]-(this.structures.labs.all.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_LAB).length))>0&&Flag.filter(FLAG_COLOR.construct.lab,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_LAB)}),!this.storage&&CONTROLLER_STRUCTURES[STRUCTURE_STORAGE][t]>0&&Flag.filter(FLAG_COLOR.construct.storage,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_STORAGE)}),!this.terminal&&CONTROLLER_STRUCTURES[STRUCTURE_TERMINAL][t]>0&&Flag.filter(FLAG_COLOR.construct.terminal,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_TERMINAL)}),!this.structures.observer&&CONTROLLER_STRUCTURES[STRUCTURE_OBSERVER][t]>0&&Flag.filter(FLAG_COLOR.construct.observer,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_OBSERVER)}),!this.structures.nuker&&CONTROLLER_STRUCTURES[STRUCTURE_NUKER][t]>0&&Flag.filter(FLAG_COLOR.construct.nuker,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_NUKER)}),!this.structures.powerSpawn&&CONTROLLER_STRUCTURES[STRUCTURE_POWER_SPAWN][t]>0&&Flag.filter(FLAG_COLOR.construct.powerSpawn,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_POWER_SPAWN)}),CONTROLLER_STRUCTURES[STRUCTURE_EXTRACTOR][t]>0){const[e]=this.find(FIND_MINERALS),t=e.pos.lookFor(LOOK_STRUCTURES);if(t.length&&t[0]instanceof StructureExtractor)return;o(e.pos,STRUCTURE_EXTRACTOR)}}}})}),this.roomExtend=(()=>{this.assignRoom({roomLayoutArray:[[null,null,null,null,null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_NUKER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_ROAD,STRUCTURE_POWER_SPAWN,STRUCTURE_LINK,STRUCTURE_TERMINAL,STRUCTURE_ROAD,STRUCTURE_OBSERVER,STRUCTURE_EXTENSION,STRUCTURE_TOWER,STRUCTURE_ROAD],[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_STORAGE,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,null,null,null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION]],roomLayout:e=>{if(!Flag.compare(e,FLAG_COLOR.command.roomLayout))return;const t=(e=Game.flags[e.name]).room;if(!t)return;const r=Room.roomLayoutArray,o={[STRUCTURE_SPAWN]:FLAG_COLOR.construct.spawn,[STRUCTURE_TOWER]:FLAG_COLOR.construct.tower,[STRUCTURE_EXTENSION]:FLAG_COLOR.construct,[STRUCTURE_LINK]:FLAG_COLOR.construct.link,[STRUCTURE_STORAGE]:FLAG_COLOR.construct.storage,[STRUCTURE_TERMINAL]:FLAG_COLOR.construct.terminal,[STRUCTURE_NUKER]:FLAG_COLOR.construct.nuker,[STRUCTURE_POWER_SPAWN]:FLAG_COLOR.construct.powerSpawn,[STRUCTURE_OBSERVER]:FLAG_COLOR.construct.observer},[i,s]=[e.pos.x,e.pos.y],a=[],n=[],l=()=>(e.pos.newFlag(FLAG_COLOR.command.invalidPosition,"NO_ROOM"),e.remove(),!1);for(let e=0;e<r.length;e++)for(let m=0;m<r[e].length;m++){const c=Math.floor(i+(e-r.length/2)+1),u=Math.floor(s+(m-r.length/2)+1);if(c>=50||c<0||u>=50||u<0)return l();const d=t.getPositionAt(c,u),h=r[e]&&r[e][m];if(h){if("wall"===Game.map.getTerrainAt(d))return l();if(h===STRUCTURE_ROAD)n.push(d);else{const e=o[h];a.push({flagColour:e,pos:d})}}}a.forEach(e=>{e.pos.newFlag(e.flagColour)}),_.forEach(n,e=>{if(_.size(Game.constructionSites)>=100)return!1;e.createConstructionSite(STRUCTURE_ROAD)}),e.remove()}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("container"),this.analyzeRoom=((e,t)=>{t&&e.saveContainers()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveContainers:{value(){let e=this.structures.all.filter(e=>e.structureType==STRUCTURE_CONTAINER);if(e.length>0){this.memory.container=[];let t=e=>{let t=this.find(FIND_MINERALS),r=e.pos.findInRange(this.sources,2),o=e.pos.findInRange(t,2),i=!!(this.my&&e.pos.getRangeTo(this.controller)<=4);this.memory.container.push({id:e.id,source:r.length>0,controller:i,mineral:o.length>0});let s=t=>t.memory.container=e.id;r.forEach(s),o.forEach(s)};e.forEach(t)}else delete this.memory.container;if(this.terminal){let e=[],t=t=>{e=_(e).concat(Room.validFields(this.name,t.pos.x-1,t.pos.x+1,t.pos.y-1,t.pos.y+1,!0))};_.forEach(this.sources,t);let r=this.terminal.pos.findClosestByRange(e,1),o=[];r&&(1==this.sources.length?o=this.sources:o.push(r.isNearTo(this.sources[0])?this.sources[0]:this.sources[1]));let i=this.terminal.pos.findInRange(this.minerals,2),s=e=>e.memory.terminal=this.terminal.id;o.forEach(s),i.forEach(s),this.terminal.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.terminal.id)}if(this.storage){let e=this.storage.pos.findInRange(this.sources,2),t=this.storage.pos.findInRange(this.minerals,2),r=e=>e.memory.storage=this.storage.id;e.forEach(r),t.forEach(r),this.storage.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.storage.id)}}},findContainerWith:{value(e,t){t||(t=1);let r=this.memory;if(r&&r.container&&r.container.length>0)for(let o=0;o<r.container.length;o++){let i=r.container[o],s=Game.getObjectById(i.id);if(s){let r=-s.getNeeds(e);if((!this.structures.container.out.includes(s)||e!==RESOURCE_ENERGY)&&r>0&&r>=t)return{structure:s,amount:r}}}return null}}})}),this.roomExtend=(()=>{this.assignRoom({Containers:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._container)){this._container=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._container.push(t))};_.forEach(this.room.memory.container,e)}return this._container}},controller:{get(){if(_.isUndefined(this._controller))if(this.room.my&&this.room.controller.memory.storage)this._controller=[Game.getObjectById(this.room.controller.memory.storage)],this._controller[0]||delete this.room.controller.memory.storage;else{let e=e=>1==e.controller;this._controller=_.filter(this.all,e)}return this._controller}},in:{get(){if(_.isUndefined(this._in)){let e=e=>0==e.controller;this._in=_.filter(this.all,e);let t=e=>e.sum>=e.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);this._in=this._in.concat(this.managed.filter(t))}return this._in}},out:{get(){if(_.isUndefined(this._out)){let e=e=>1==e.controller;this._out=_.filter(this.all,e);let t=e=>e.sum<=e.storeCapacity*MANAGED_CONTAINER_TRIGGER;this._out=this._out.concat(this.managed.filter(t))}return this._out}},privateers:{get(){if(_.isUndefined(this._privateers)){let e=e=>!1===e.source&&!e.mineral&&e.sum<e.storeCapacity;this._privateers=_.filter(this.all,e)}return this._privateers}},managed:{get(){if(_.isUndefined(this._managed)){let e=e=>!0===e.source&&1==e.controller;this._managed=_.filter(this.all,e)}return this._managed}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("defense"),this.analyzeRoom=(e=>{(e.hostiles.length||e.memory.hostileIds&&e.memory.hostileIds.length)&&e.processInvaders()}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r?(r.goneInvader.forEach(this._triggerGoneInvaders),r.hostileIds.forEach(this._triggerKnownInvaders),r.newInvader.forEach(this._triggerNewInvaders)):e.hostileIds&&_.forEach(e.hostileIds,this._triggerKnownInvaders)}),this.freshRoom=(e=>{e.newInvader=[],e.goneInvader=[]}),this._triggerNewInvaders=(e=>{const t=JSON.stringify(_.countBy(e.body,"type"));(NOTIFICATE_INVADER||NOTIFICATE_INTRUDER&&e.room.my||NOTIFICATE_HOSTILES)&&Log.room(e.pos.roomName,Dye(COLOR_RED,`Hostile intruder (${t}) from "${e.owner.username}".`)),(NOTIFICATE_INVADER||NOTIFICATE_INTRUDER&&"Source Keeper"!==e.owner.username&&e.room.my||NOTIFICATE_HOSTILES&&"Source Keeper"!==e.owner.username)&&Game.notify(`Hostile intruder ${e.id} (${t}) from "${e.owner.username}" in room ${e.pos.roomName} at ${Util.toDateTimeString(Util.toLocalDate(new Date))}`),Room.newInvader.trigger(e)}),this._triggerKnownInvaders=(e=>Room.knownInvader.trigger(e)),this._triggerGoneInvaders=(e=>Room.goneInvader.trigger(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("extension"),this.analyzeRoom=((e,t)=>{t&&e.saveExtensions()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveExtensions:{value(){const e=this.find(FIND_MY_STRUCTURES,{filter:e=>e instanceof StructureExtension}).map(e=>e.id);e.length>0?this.memory.extensions=e:delete this.memory.extensions}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("lab"),this.analyzeRoom=((e,t)=>{t&&e.saveLabs(),e.structures.labs.all.length>0&&e.processLabs()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveLabs:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});if(e.length>0){this.memory.labs=[];let t=this.storage?this.storage.pos.findInRange(e,2).map(e=>e.id):[];this.memory.labs=[];let r=e=>{this.memory.labs.find(t=>t.id==e.id)||this.memory.labs.push({id:e.id,storage:t.includes(e.id)})};e.forEach(r)}else delete this.memory.labs}},processLabs:{value(){if(Game.time%LAB_COOLDOWN!=5)return;let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});if(!this.memory.resources)return;let t=e.filter(e=>{let t=this.memory.resources.lab.find(t=>t.id==e.id);return!!t&&t.slave_a&&t.slave_b});for(let e=0;e<t.length;e++){let r=t[e];if(r.cooldown>0)continue;let o=this.memory.resources.lab.find(e=>e.id==r.id);if(!o)continue;let i=o.reactionType;if(r.mineralAmount>0&&r.mineralType!=i)continue;let s=Game.getObjectById(o.slave_a),a=Game.getObjectById(o.slave_b);s&&s.mineralType==LAB_REACTIONS[i][0]&&a&&a.mineralType==LAB_REACTIONS[i][1]&&r.runReaction(s,a)==OK&&(o.reactionAmount-=LAB_REACTION_AMOUNT,LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"processLabs",labId:r.id,resourceType:i,amountRemaining:o.reactionAmount}),o.reactionAmount<=0&&this.cancelReactionOrder(r.id))}let r=this.memory.resources.reactions;if(r)switch(r.reactorType){case REACTOR_TYPE_FLOWER:this.processReactorFlower()}}},processReactorFlower:{value(){let e=this.memory.resources.reactions;if(!e||e.reactorType!==REACTOR_TYPE_FLOWER)return;for(let t=0;t<e.orders.length&&e.orders[t].amount<LAB_REACTION_AMOUNT;t++)e.orders.splice(t--,1);if(0===e.orders.length){let t=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});for(let e=0;e<t.length;e++){let r=t[e],o=this.memory.resources.lab.find(e=>e.id===r.id);!o||o.reactionState!==LAB_IDLE&&o.reactionState!==LAB_SEED||this.cancelReactionOrder(r.id)}return void(e.reactorMode=REACTOR_MODE_IDLE)}let t=e.orders[0];switch(e.reactorMode=t.mode,e.reactorMode){case REACTOR_MODE_BURST:this.processReactorFlowerBurst()}}},processReactorFlowerBurst:{value(){let e=this.memory.resources.reactions;if(!e||e.reactorType!==REACTOR_TYPE_FLOWER||e.reactorMode!==REACTOR_MODE_BURST)return;let t=e.orders[0];if(t.mode!==REACTOR_MODE_BURST)return;let r=LAB_REACTIONS[t.type][0],o=LAB_REACTIONS[t.type][1],i=Game.getObjectById(e.seed_a),s=Game.getObjectById(e.seed_b),a=_.filter(Game.rooms,{my:!0}),n=!1,l=!1,m=e=>{let t=0;for(let r of a){if(r.name===this.name)continue;let o=r.resourcesAll[e]||0;o>=MIN_OFFER_AMOUNT&&(t+=o)}return t},c=m(r),u=m(o);if(!i||!s)return;let d=this.memory.resources.lab.find(t=>t.id===e.seed_a),h=this.memory.resources.lab.find(t=>t.id===e.seed_b);if(!d||!_.some(d.orders,"type",r)){this.placeOrder(e.seed_a,r,t.amount),l=!0;const o=(this.resourcesStorage[r]||0)+(this.resourcesTerminal[r]||0)+(this.resourcesLabs[r]||0);let i=(this.resourcesOffers[r]||0)+t.amount-o,s=Util.roundUpTo(i,MIN_OFFER_AMOUNT);i<TRADE_THRESHOLD&&i>0?c>=TRADE_THRESHOLD?i=TRADE_THRESHOLD:c>=s&&(i=s):i>0&&s<=c&&(i=s),i>0&&i<=c&&(this.placeRoomOrder(e.seed_a,r,i),n=!0),(d=this.memory.resources.lab.find(t=>t.id===e.seed_a)).reactionType=r}if(!h||!_.some(h.orders,"type",o)){this.placeOrder(e.seed_b,o,t.amount),l=!0;const r=(this.resourcesStorage[o]||0)+(this.resourcesTerminal[o]||0)+(this.resourcesLabs[o]||0);let i=(this.resourcesOffers[o]||0)+t.amount-r,s=Util.roundUpTo(i,MIN_OFFER_AMOUNT);i<TRADE_THRESHOLD&&i>0?u>=TRADE_THRESHOLD?i=TRADE_THRESHOLD:u>=s&&(i=s):i>0&&s<=u&&(i=s),i>0&&i<=u&&(this.placeRoomOrder(e.seed_b,o,i),n=!0),(h=this.memory.resources.lab.find(t=>t.id===e.seed_b)).reactionType=o}if(!d||!h)return;let g=d.orders.find(e=>e.type===r),p=h.orders.find(e=>e.type===o);if(!g||g.amount<t.amount){let o=t.amount-(g?g.orderAmount:0);this.placeOrder(e.seed_a,r,o),l=!0;const i=(this.resourcesStorage[r]||0)+(this.resourcesTerminal[r]||0)+(this.resourcesLabs[r]||0);let s=(this.resourcesOffers[r]||0)+t.amount-i,a=Util.roundUpTo(s,MIN_OFFER_AMOUNT);s<TRADE_THRESHOLD&&s>0?c>=TRADE_THRESHOLD?s=TRADE_THRESHOLD:c>=a&&(s=a):s>0&&a<=c&&(s=a),s>0&&s<=c&&(this.placeRoomOrder(e.seed_a,r,s),n=!0),s>0&&(this.placeRoomOrder(e.seed_a,r,s),n=!0)}if(!p||p.amount<t.amount){let r=t.amount-(p?p.orderAmount:0);this.placeOrder(e.seed_b,o,r),l=!0;const i=(this.resourcesStorage[o]||0)+(this.resourcesTerminal[o]||0)+(this.resourcesLabs[o]||0);let s=(this.resourcesOffers[o]||0)+t.amount-i,a=Util.roundUpTo(s,MIN_OFFER_AMOUNT);s<TRADE_THRESHOLD&&s>0?u>=TRADE_THRESHOLD?s=TRADE_THRESHOLD:u>=a&&(s=a):s>0&&a<=u&&(s=a),s>0&&s<=u&&(this.placeRoomOrder(e.seed_b,o,s),n=!0),s>0&&(this.placeRoomOrder(e.seed_b,o,s),n=!0)}let f=this.memory.resources.boostTiming;n?(f.roomState="ordersPlaced",this.GCOrders()):l&&(f.roomState="ordersPlaced");let R=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB}).filter(e=>{let t=this.memory.resources.lab.find(t=>t.id===e.id),r=this.memory.resources.reactions;return!t||t.reactionState===LAB_IDLE&&(t.id!==r.seed_a||t.id!==r.seed_b)});for(let e=0;e<R.length;e++){let r=R[e],o=this.memory.resources.lab.find(e=>e.id===r.id);o||(this.prepareReactionOrder(r.id,t.type,t.amount),o=this.memory.resources.lab.find(e=>e.id===r.id)),o&&(o.reactionType=t.type)}if(i.mineralType!==r||s.mineralType!==o)return;let y=Math.floor(Math.min(i.mineralAmount,s.mineralAmount,t.amount)/LAB_REACTION_AMOUNT);if(0===y)return;let C=0;for(let e=0;e<R.length;e++){let r=R[e];if(!(r.cooldown>0)&&(0===r.mineralAmount||r.mineralType===t.type&&r.mineralAmount<=r.mineralCapacity-LAB_REACTION_AMOUNT&&C<y)){C++;let e=r.runReaction(i,s);e===OK?(t.amount-=LAB_REACTION_AMOUNT,LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"processLabs",reactorType:REACTOR_TYPE_FLOWER,labId:r.id,resourceType:t.type,amountRemaining:t.amount})):Log.module(this.name,`${this.name} runReactions not OK. returnValue: ${Util.translateErrorCode(e)}`)}}}},cancelReactionOrder:{value(e,t){let r=this.memory.resources.lab.find(t=>t.id==e);if(!t||_.matches(t)(e)){if(r){r.slave_a&&this.cancelReactionOrder(r.slave_a,{master:e}),r.slave_b&&this.cancelReactionOrder(r.slave_b,{master:e}),[LAB_MASTER,LAB_SLAVE_1,LAB_SLAVE_2,LAB_SLAVE_3].includes(r.reactionState)&&(r.reactionState=LAB_IDLE),delete r.reactionType,delete r.reactionAmount,delete r.master,delete r.slave_a,delete r.slave_b,void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]),this.memory.resources.orders;for(let e=0;e<r.orders.length;e++){let t=r.orders[e];t.type!=RESOURCE_ENERGY&&(t.orderAmount=0,t.orderRemaining=0,t.storeAmount=0)}}return OK}}},prepareReactionOrder:{value(e,t,r){if(r<=0)return OK;let o=Game.getObjectById(e);if(!this.my||!o||!o.structureType==STRUCTURE_LAB)return ERR_INVALID_TARGET;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]});let i=this.memory.resources.lab.find(t=>t.id==e);return i||(this.memory.resources.lab.push({id:e,orders:[],reactionState:LAB_IDLE}),i=this.memory.resources.lab.find(t=>t.id==e)),this.cancelReactionOrder(e),OK}},placeBasicReactionOrder:{value(e,t,r,o=1){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let i=Game.getObjectById(e),s=LAB_REACTIONS[t][0],a=LAB_REACTIONS[t][1],n=null,l=null,m=i.pos.findInRange(FIND_MY_STRUCTURES,2,{filter:e=>e.structureType==STRUCTURE_LAB&&e.id!=i.id});for(let e=0;e<m.length;e++){let t=m[e],r=this.memory.resources.lab.find(e=>e.id==t.id);if(null==n&&r&&r.reactionType==s?n=t:null==l&&r&&r.reactionType==a&&(l=t),n&&l)break}if(!n||!l){m.sort((e,t)=>i.pos.getRangeTo(e)-i.pos.getRangeTo(t));for(let e=0;e<m.length;e++){let t=m[e],r=this.memory.resources.lab.find(e=>e.id==t.id);r&&r.reactionState&&r.reactionState!=LAB_IDLE||(null==n?n=t:null==l&&(l=t))}}if(null==n||null==l)return ERR_NOT_FOUND;let c=this.prepareReactionOrder(e,t,r);if(c!=OK)return c;if((c=this.prepareReactionOrder(n.id,t,r))!=OK)return c;if((c=this.prepareReactionOrder(l.id,t,r))!=OK)return c;let u=this.memory.resources.lab.find(t=>t.id==e),d=LAB_MASTER;u&&(u.reactionState==LAB_SLAVE_1&&(d=LAB_SLAVE_1),u.reactionState==LAB_SLAVE_2&&(d=LAB_SLAVE_2),u.reactionState=d,u.reactionType=t,u.reactionAmount=r,u.slave_a=n.id,u.slave_b=l.id),u=this.memory.resources.lab.find(e=>e.id==n.id);let h=LAB_SLAVE_1,g=1;if(d==LAB_SLAVE_1?(h=LAB_SLAVE_2,g=2):d==LAB_SLAVE_2&&(h=LAB_SLAVE_3,g=3),u){u.reactionState=h,u.reactionType=s,u.master=i.id,this.placeOrder(n.id,s,r);let e=0;if(this.memory.container)for(let t=0;t<this.memory.container.length;t++){let r=this.memory.container[t],o=Game.getObjectById(r.id);o&&o.store[s]&&(e+=o.store[s])}if(this.storage&&(e+=this.storage.store[s]||0),this.terminal&&(e+=this.terminal.store[s]||0),o>g&&g<3&&e<r&&this.placeReactionOrder(n.id,s,r-e)==OK){let t=u.orders.find(e=>e.type==s);t&&(t.orderRemaining=e)}}if(u=this.memory.resources.lab.find(e=>e.id==l.id)){u.reactionState=h,u.reactionType=a,u.master=i.id,this.placeOrder(l.id,a,r);let e=0;if(this.memory.container)for(let t=0;t<this.memory.container.length;t++){let r=this.memory.container[t],o=Game.getObjectById(r.id);o&&(e+=o.store[a]||0)}if(this.storage&&(e+=this.storage.store[a]||0),this.terminal&&(e+=this.terminal.store[a]||0),o>g&&g<3&&e<r&&this.placeReactionOrder(n.id,s,r-e)==OK){let t=u.orders.find(e=>e.type==a);t&&(t.orderRemaining=e)}}return OK}},placeFlowerReactionOrder:{value(e,t,r,o=REACTOR_MODE_BURST){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let i=this.memory.resources;if(i.reactions){let s=i.reactions.orders.find(r=>r.id==e&&r.type==t);s?(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeReactionOrder",subAction:"update",orderId:e,resourceType:t,amount:r}),s.mode=o,s.amount=r):(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeReactionOrder",subAction:"new",orderId:e,resourceType:t,amount:r}),i.reactions.orders.push({id:e,type:t,mode:o,amount:r})),i.reactions.reactorMode=o}return OK}},placeReactionOrder:{value(e,t,r,o=REACTOR_MODE_BURST){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let i=Game.getObjectById(e);if(i&&i.structureType===STRUCTURE_LAB)return this.placeBasicReactionOrder(e,t,r,1);let s=this.memory.resources;if(!s.reactions)return LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"no_reactor"}),ERR_INVALID_TARGET;switch(s.reactions.reactorType,s.reactions.reactorType){case REACTOR_TYPE_FLOWER:this.placeFlowerReactionOrder(e,t,r,o)}return OK}},registerReactorFlower:{value(e,t){void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let r=Game.getObjectById(e),o=Game.getObjectById(t);if(!r||!o||r.structureType!==STRUCTURE_LAB||o.structureType!==STRUCTURE_LAB)return ERR_INVALID_TARGET;let i=this.memory.resources;void 0===i.reactions&&(i.reactions={orders:[]}),i.reactions.reactorType=REACTOR_TYPE_FLOWER,i.reactions.reactorMode=REACTOR_MODE_IDLE,i.reactions.seed_a=e,i.reactions.seed_b=t;const s=i.lab.find(t=>t.id===e);s&&(s.reactionState=LAB_SEED);const a=i.lab.find(e=>e.id===t);return a&&(a.reactionState=LAB_SEED),OK}}})}),this.roomExtend=(()=>{this.assignRoom({Labs:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.labs,e)}return this._all}},storage:{get(){if(_.isUndefined(this._storage)){let e=e=>!0===e.storage;this._storage=this.all.filter(e)}return this._storage}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("link"),this.analyzeRoom=((e,t)=>{t&&e.saveLinks(),e.structures.links.all.length>0&&e.linkDispatcher()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveLinks:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LINK});if(e.length>0){this.memory.links=[];let t=this.storage?this.storage.pos.findInRange(e,2).map(e=>e.id):[];this.memory.links=[];let r=e=>{if(!this.memory.links.find(t=>t.id==e.id)){let r=e.pos.getRangeTo(this.controller)<=4,o=!1;if(!r){let t=e.pos.findInRange(this.sources,2),r=t=>t.memory.link=e.id;t.forEach(r),o=t.length>0}this.memory.links.push({id:e.id,storage:t.includes(e.id),controller:r,source:o})}};e.forEach(r)}else delete this.memory.links}},linkDispatcher:{value(){let e=e=>0==e.cooldown&&e.energy>=e.energyCapacity*(e.source?.85:.5),t=e=>e.energy<.15*e.energyCapacity,r=this.structures.links.in.filter(e),o=this.structures.links.controller.filter(t);if(r.length>0){let e=this.structures.links.storage.filter(t),i=t=>{o.length>0?(t.transferEnergy(o[0]),o.shift()):e.length>0&&(t.transferEnergy(e[0]),e.shift())};r.forEach(i)}if(o.length>0){let t=e=>{o.length>0&&(e.transferEnergy(o[0]),o.shift())};this.structures.links.storage.filter(e).forEach(t)}}}})}),this.roomExtend=(()=>{this.assignRoom({Links:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.links,e)}return this._all}},controller:{get(){if(_.isUndefined(this._controller)){let e=e=>!0===e.controller;this._controller=this.all.filter(e)}return this._controller}},storage:{get(){if(_.isUndefined(this._storage)){let e=e=>1==e.storage;this._storage=this.all.filter(e)}return this._storage}},in:{get(){if(_.isUndefined(this._in)){let e=e=>0==e.storage&&0==e.controller;this._in=_.filter(this.all,e)}return this._in}},privateers:{get(){if(_.isUndefined(this._privateers)){let e=e=>0==e.storage&&0==e.controller&&0==e.source&&e.energy<.85*e.energyCapacity;this._privateers=_.filter(this.all,e)}return this._privateers}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("nuker"),this.analyzeRoom=((e,t)=>{t&&e.saveNuker()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveNuker:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_NUKER});if(e.length>0){this.memory.nukers=[];let t=e=>{this.memory.nukers.find(t=>t.id==e.id)||this.memory.nukers.push({id:e.id})};e.forEach(t)}else delete this.memory.nukers}}})}),this.roomExtend=(()=>{this.assignRoom({Nuker:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.nukers,e)}return this._all}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("observer"),this.analyzeRoom=((e,t)=>{t&&(e.saveObserver(),e.structures.observer&&e.initObserverRooms())}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r&&r.structures.observer&&r.controlObserver()}),this.fresh=(()=>{Memory.observerSchedule=[]}),this.prototypeExtend=(()=>{this.assignRoomPrototype({controlObserver:{value(){const e=this.structures.observer;if(!e)return;let t;if(this.memory.observer.rooms||this.initObserverRooms(),observerRequests.length>0)for(const e of observerRequests)if(Game.map.getRoomLinearDistance(this.name,e.roomName)<=10&&!Memory.observerSchedule.includes(e.roomName)){const r=e.room||Game.rooms[e.roomName];if(r&&r.creeps&&r.creeps.length&&r.creeps.length>0)continue;Memory.observerSchedule.push(e.roomName),t=e.roomName;break}let r=0;const o=this.memory.observer.rooms;if(!t){let e=Number.isInteger(this.memory.observer.lastLookedIndex)?this.memory.observer.lastLookedIndex:o.length;do{if(t=e>=o.length?o[0]:o[e+1],e=o.indexOf(t),++r>=o.length)break}while(Memory.observerSchedule.includes(t)||t in Game.rooms);this.memory.observer.lastLookedIndex=e,Memory.observerSchedule.push(t)}e.observeRoom(t)===ERR_INVALID_ARGS&&r<o.length&&(Memory.observerSchedule.splice(Memory.observerSchedule.indexOf(t),1),this.controlObserver())}},initObserverRooms:{value(){const e=OBSERVER_OBSERVE_RANGE>10?10:OBSERVER_OBSERVE_RANGE,[t,r]=Room.calcGlobalCoordinates(this.name,(e,t)=>[e,t]),[o,i]=Room.calcCardinalDirection(this.name);this.memory.observer.rooms=[];for(let s=t-e;s<t+e;s++)for(let t=r-e;t<r+e;t++){let e=o,r=i,a=s;s<0&&(e="W"===e?"E":"W",a=Math.abs(s)-1),e+=a,a=t,t<0&&(r="N"===r?"S":"N",a=Math.abs(t)-1);const n=e+(r+=a);OBSERVER_OBSERVE_HIGHWAYS_ONLY&&!Room.isHighwayRoom(n)||n in Game.rooms&&Game.rooms[n].my||Game.map.isRoomAvailable(n)&&this.memory.observer.rooms.push(n)}}},saveObserver:{value(){this.memory.observer={},[this.memory.observer.id]=this.find(FIND_MY_STRUCTURES,{filter:e=>e instanceof StructureObserver}).map(e=>e.id),_.isUndefined(this.memory.observer.id)&&delete this.memory.observer}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("orders"),this.analyzeRoom=((e,t)=>{if(Game.time%PROCESS_ORDERS_INTERVAL==0||"sim"===e.name){e.updateResourceOrders();let t=Util.orderingRoom();1===t.length&&e.name!==t[0].name&&(e.updateRoomOrders(),e.terminalBroker())}}),this.prototypeExtend=(()=>{this.assignRoomPrototype({updateResourceOrders:{value(){let e=this.memory.resources;if(this.my&&e)for(let t in e)for(let r=0;r<e[t].length;r++){let o=e[t][r];if((t!=STRUCTURE_LAB||o.reactionState==LAB_IDLE)&&o.orders)for(let e=0;e<o.orders.length;e++){let r=o.orders[e];if(r.orderRemaining<=0){let e=0,i=this.RCL;t==STRUCTURE_STORAGE?e=r.type==RESOURCE_ENERGY?MIN_STORAGE_ENERGY[i]:MAX_STORAGE_MINERAL:t==STRUCTURE_TERMINAL&&(e=r.type==RESOURCE_ENERGY?TERMINAL_ENERGY:0),e+=r.storeAmount;let s=0,a=Game.getObjectById(o.id);if(a)switch(t){case STRUCTURE_LAB:r.type==a.mineralType?s=a.mineralAmount:r.type==RESOURCE_ENERGY&&(s=a.energy);break;case STRUCTURE_POWER_SPAWN:r.type==RESOURCE_POWER?s=a.power:r.type==RESOURCE_ENERGY&&(s=a.energy);break;case STRUCTURE_NUKER:r.type==RESOURCE_GHODIUM?s=a.ghodium:r.type==RESOURCE_ENERGY&&(s=a.energy);break;default:s=a.store[r.type]||0}s<=e&&(r.orderAmount=0,r.orderRemaining=0)}}}}},updateRoomOrders:{value(){if(!this.memory.resources||!this.memory.resources.orders)return;let e=_.filter(Game.rooms,e=>e.my&&e.storage&&e.terminal&&e.name!==this.name),t=this.memory.resources.orders;for(let r=0;r<t.length;r++){let o=t[r],i=o.amount;for(let e=0;e<o.offers.length;e++){let t=o.offers[e];if(Memory.rooms[t.room]&&Memory.rooms[t.room].resources&&Memory.rooms[t.room].resources.offers){let e=Memory.rooms[t.room].resources.offers,r=e.indexOf(e=>e.room===this.name&&e.id===o.id&&e.type===o.type);-1!==r&&e.splice(r,1)}}if(o.offers=[],i<=0)delete t[r],t.splice(r--,1);else{e.sort((e,t)=>Game.map.getRoomLinearDistance(this.name,e.name,!0)-Game.map.getRoomLinearDistance(this.name,t.name,!0));for(let t=0;t<e.length;t++){let r=e[t];void 0===r.memory.resources&&(r.memory.resources={lab:[],container:[],terminal:[],storage:[],powerSpawn:[],nuker:[]}),r.memory.resources.offers||(r.memory.resources.offers=[]);let s=r.memory.resources.offers,a=r.resourcesAll[o.type]||0;if(Log.room(r.name,`available: ${a} ${o.type}`),a<MIN_OFFER_AMOUNT)continue;if(!_.isUndefined(COMPOUNDS_TO_ALLOCATE[o.type])){let e=COMPOUNDS_TO_ALLOCATE[o.type].amount+COMPOUNDS_TO_ALLOCATE[o.type].threshold;if(a<e+MIN_OFFER_AMOUNT)continue;a-=e}i<MIN_OFFER_AMOUNT&&i>0&&(i=MIN_OFFER_AMOUNT),a=Math.min(a,i);let n=o.offers.find(e=>e.room===r.name),l=s.find(e=>e.room===this.name&&e.id===o.id&&e.type===o.type);if(n?(LOG_TRACE&&Log.trace("Room",{roomName:this.name,remoteRoom:r.name,actionName:"updateRoomOrders",subAction:"update",orderId:o.id,resourceType:o.type,amount:a}),i-=a-n.amount,n.amount=a):(LOG_TRACE&&Log.trace("Room",{roomName:this.name,remoteRoom:r.name,actionName:"updateRoomOrders",subAction:"new",orderId:o.id,resourceType:o.type,amount:a}),Log.room(this.name,`Room offer from ${r.name} with id ${o.id} placed for ${a} ${o.type}.`),i-=a,o.offers.push({room:r.name,amount:a})),l?l.amount=a:s.push({room:this.name,id:o.id,type:o.type,amount:a}),i<=0)break}}}}},fillARoomOrder:{value(){if(!(this.terminal&&this.memory&&this.memory.resources&&this.memory.resources.offers))return!1;const e=this.memory.resources.offers;let t=!1;for(let r=0;r<e.length;r++){let o=e[r],i=Game.rooms[o.room];if(!(i&&i.memory&&i.memory.resources&&i.memory.resources.orders))continue;let s=i.memory.resources.orders.find(e=>e.id==o.id&&e.type==o.type);if(!s)continue;let a=s.offers.findIndex(e=>e.room==this.name);if(-1==a){Log.room(this.name,"Orphaned offer found and deleted"),e.splice(r--,1);continue}let n=this.terminal.store[o.type]||0,l=0,m=null;this.memory.resources.terminal[0]&&(m=this.memory.resources.terminal[0].orders.find(e=>e.type==o.type)),m&&(l=m.orderRemaining);let c=Math.max(o.amount,MIN_OFFER_AMOUNT);if(c>n+l){let e=c-(n+l);LOG_TRACE&&Log.trace("Room",{actionName:"fillARoomOrder",subAction:"terminalOrder",roomName:this.name,targetRoomName:i.name,resourceType:o.type,amount:e}),this.placeOrder(this.terminal.id,o.type,e)}if(!i.terminal)continue;let u=i.terminal.storeCapacity-i.terminal.sum;c=Math.min(c,u,n);let d=Game.market.calcTransactionCost(c,this.name,i.name);if(o.type==RESOURCE_ENERGY&&(d+=c-=d),!(d>(this.terminal.store.energy||0)||c<MIN_OFFER_AMOUNT)){if((t=this.terminal.send(o.type,c,i.name,s.id))==OK)return LOG_TRACE&&Log.trace("Room",{actionName:"fillARoomOrder",roomName:this.name,targetRoomName:i.name,resourceType:o.type,amount:c}),Log.room(this.name,`Send ${o.type} ${c} to ${Util.makeRoomUrl(i.name)}.`),o.amount-=c,o.amount>0?s.offers[a].amount=o.amount:(delete s.offers[a],s.offers.splice(a,1),delete e[r],e.splice(r--,1)),s.amount-=c,!0;Log.error(`Send Error: ${Util.translateErrorCode(t)} | ${this.name} send ${o.type} ${c} to ${Util.makeRoomUrl(i.name)}.`)}}return t}},prepareResourceOrder:{value(e,t,r){let o=Game.getObjectById(e);if(!this.my||!o||!o.room.name==this.name||o.structureType!=STRUCTURE_LAB&&o.structureType!=STRUCTURE_NUKER&&o.structureType!=STRUCTURE_POWER_SPAWN&&o.structureType!=STRUCTURE_CONTAINER&&o.structureType!=STRUCTURE_STORAGE&&o.structureType!=STRUCTURE_TERMINAL)return ERR_INVALID_TARGET;if(!RESOURCES_ALL.includes(t))return ERR_INVALID_ARGS;if(void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.nuker&&(this.memory.resources.nuker=[]),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),this.memory.resources[o.structureType].find(t=>t.id==e)||this.memory.resources[o.structureType].push(o.structureType==STRUCTURE_LAB?{id:e,orders:[],reactionState:LAB_IDLE}:{id:e,orders:[]}),o.structureType==STRUCTURE_LAB&&t!=RESOURCE_ENERGY&&r>0){let r=this.memory.resources[STRUCTURE_LAB].find(t=>t.id==e).orders;for(let e=0;e<r.length;e++)r[e].type!=t&&r[e].type!=RESOURCE_ENERGY&&(r[e].orderAmount=0,r[e].orderRemaining=0,r[e].storeAmount=0)}return OK}},cancelOrder:{value(e,t=null){let r=Game.getObjectById(e);if(this.prepareResourceOrder(e,RESOURCE_ENERGY,0)!=OK)return ret;let o=this.memory.resources[r.structureType].find(t=>t.id==e);if(o)if(t){let e=o.orders.find(e=>e.type==t);e&&(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelOrder",orderId:orderId,resourceType:t}),o.orders.splice(o.orders.indexOf(e),1))}else LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelOrder",orderId:orderId,resourceType:"all"}),o.orders=[];return OK}},registerBoostLab:{value(e){if(Game.getObjectById(e)){_.isUndefined(this.memory.resources)&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]});let t=this.memory.resources.lab.findIndex(t=>t.id==e);if(t>-1)delete this.memory.resources.lab[t].reactionType,this.memory.resources.lab[t].reactionState="Storage";else{let t={id:e,orders:[],reactionState:"Storage"};this.memory.resources.lab.push(t)}}}},unRegisterBoostLab:{value(e){const t=Game.getObjectById(e),r=this.memory.resources;if(t&&r){let t=this.memory.resources.lab.findIndex(t=>t.id===e);t>-1&&(r.reactions.orders.length>0&&(this.memory.resources.lab[t].reactionType=this.memory.resources.reactions.orders[0].type),this.memory.resources.lab[t].reactionState="idle",this.memory.resources.lab[t].orders=_.filter(this.memory.resources.lab[t].orders,"type","energy"))}}},placeOrder:{value(e,t,r){const o=Game.getObjectById(e);let i=this.prepareResourceOrder(e,t,r);if(i!=OK)return i;let s=this.memory.resources[o.structureType].find(t=>t.id==e);if(s){let e=s.orders.find(e=>e.type==t);if(e)e.orderAmount+=r,e.orderRemaining+=r;else{let e=0;e=o.structureType===STRUCTURE_LAB?o.mineralType==t?o.mineralAmount:0:o.store[t]||0,s.orders.push({type:t,orderAmount:r,orderRemaining:r-e,storeAmount:0}),o.structureType===STRUCTURE_LAB&&"Storage"!=s.reactionState&&(s.reactionType=t)}}return OK}},setStore:{value(e,t,r){let o=Game.getObjectById(e),i=this.prepareResourceOrder(e,t,r);if(i!=OK)return i;let s=this.memory.resources[o.structureType].find(t=>t.id==e);if(s){let e=s.orders.find(e=>e.type==t);e?e.storeAmount=r:s.orders.push({type:t,orderAmount:0,orderRemaining:0,storeAmount:r})}return OK}},cancelRoomOrder:{value(e=null,t=null){void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.nuker&&(this.memory.resources.nuker=[]),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]);let r=this.memory.resources.orders;if(e&&t){let o=r.find(r=>r.id==e&&r.type==t);o&&(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelRoomOrder",orderId:e,resourceType:t}),r.splice(r.indexOf(o),1))}else if(e){LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelRoomOrder",orderId:e,resourceType:"all"});for(let t=0;t<r.length;t++)r[t].id===e&&r.splice(t--,1)}else this.memory.resources.orders=[];return OK}},placeRoomOrder:{value(e,t,r){if(r<=0)return OK;void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.nuker&&(this.memory.resources.nuker=[]),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]);let o=this.memory.resources.orders,i=o.find(r=>r.id==e&&r.type==t);return i?(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"update",orderId:e,resourceType:t,amount:r}),i.amount=r):(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"new",orderId:e,resourceType:t,amount:r}),Log.room(this.name,`New room order with id ${e} placed for ${r} ${t}.`),o.push({id:e,type:t,amount:r,offers:[]})),OK}},terminalBroker:{value(){if(Log.module("TerminalBroker","Checking..."),!this.my||!this.terminal||!this.storage)return;if(this.terminal.cooldown&&this.terminal.cooldown>0)return;let e=!1;for(const t in this.terminal.store){if(t===RESOURCE_ENERGY||t===RESOURCE_POWER)continue;if((MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS)&&t!==this.memory.mineralType)continue;let r=this.terminal.sum/this.terminal.storeCapacity>.8;if(this.terminal.store[t]>=MIN_MINERAL_SELL_AMOUNT){let o;AUTOMATED_RATIO_COUNT?0===(o=Util.countPrices("buy",t,this.name))?Log.warn(this.print,`there is no buy order for ${t}`):Log.info(`average buyRatio: ${this.name} ${t} ${o}`):o=MIN_SELL_RATIO[t];let i=Game.market.getAllOrders(e=>!(!e.roomName||e.resourceType!=t||"buy"!=e.type||e.amount<MIN_MINERAL_SELL_AMOUNT)&&(e.range=Game.map.getRoomLinearDistance(e.roomName,this.name,!0),e.transactionAmount=Math.min(e.amount,this.terminal.store[t]),e.transactionCost=Game.market.calcTransactionCost(e.transactionAmount,this.name,e.roomName),e.transactionCost>this.terminal.store.energy&&e.transactionAmount>MIN_MINERAL_SELL_AMOUNT&&(e.transactionAmount=MIN_MINERAL_SELL_AMOUNT,e.transactionCost=Game.market.calcTransactionCost(e.transactionAmount,this.name,e.roomName)),e.credits=e.transactionAmount*e.price,e.ratio=(e.credits-e.transactionCost*ENERGY_VALUE_CREDITS)/e.transactionAmount,r||e.ratio>=o&&e.transactionCost<=this.terminal.store.energy));if(i.length>0){let r=_.max(i,"ratio");Log.info("selected order: "),Log.stringify(r);let o=Game.market.deal(r.id,r.transactionAmount,this.name);SELL_NOTIFICATION&&Log.room(this.name,`Selling ${r.transactionAmount} ${t} for ${Util.roundUp(r.credits)} (${r.price} ¢/${t}, ${r.transactionCost} e): ${Util.translateErrorCode(o)}`),SELL_NOTIFICATION&&Game.notify(`<h2>Room ${this.name} rund an order!</h2><br/>Result: ${Util.translateErrorCode(o)}<br/>Details:<br/>${JSON.stringify(r).replace(",",",<br/>")}`),e=o==OK;break}}}if(8==this.controller.level&&!e&&Util.chargeScale(this.storage.store.energy-ENERGY_BALANCE_TRANSFER_AMOUNT,MIN_STORAGE_ENERGY[this.controller.level],MAX_STORAGE_ENERGY[this.controller.level])>1&&(this.terminal.store[this.mineralType]||0)<15e4&&this.terminal.store.energy>1.1*ENERGY_BALANCE_TRANSFER_AMOUNT){let t=e=>e.my&&e.storage&&e.terminal&&e.terminal.sum<e.terminal.storeCapacity-ENERGY_BALANCE_TRANSFER_AMOUNT&&e.storage.sum<e.storage.storeCapacity*TARGET_STORAGE_SUM_RATIO&&!e._isReceivingEnergy&&e.storage.store[RESOURCE_ENERGY]<MAX_STORAGE_ENERGY[e.RCL],r=_.min(_.filter(Game.rooms,t),"storage.store.energy");if(r instanceof Room&&Game.market.calcTransactionCost(ENERGY_BALANCE_TRANSFER_AMOUNT,this.name,r.name)<this.terminal.store.energy-ENERGY_BALANCE_TRANSFER_AMOUNT){r._isReceivingEnergy=!0;let t=this.terminal.send("energy",ENERGY_BALANCE_TRANSFER_AMOUNT,r.name,"have fun");Log.room(this.name,`Transferring ${Util.formatNumber(ENERGY_BALANCE_TRANSFER_AMOUNT)} energy to ${r.name}: ${Util.translateErrorCode(t)}`),e=t==OK}}!0!==e&&_.isUndefined(Memory.boostTiming)&&(Log.module("TerminalBroker","FillARoomOrder..."),this.fillARoomOrder())}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("power"),this.analyzeRoom=((e,t)=>{t&&e.savePowerSpawn(),e.structures.powerSpawn&&e.processPower()}),this.freshRoom=(e=>{e._powerBank||delete e.memory.powerBank}),this.prototypeExtend=(()=>{this.assignRoomPrototype({powerBank:{get(){return _.isUndefined(this.memory.powerBank)&&([this._powerBank]=this.find(FIND_STRUCTURES,{filter:e=>e instanceof StructurePowerBank}),this._powerBank&&(this.memory.powerBank=this._powerBank.id)),_.isUndefined(this._powerBank)&&(this._powerBank=Game.getObjectById(this.memory.powerBank)),this._powerBank}},savePowerSpawn:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_POWER_SPAWN});if(e.length>0){this.memory.powerSpawns=[];let t=e=>{this.memory.powerSpawns.find(t=>t.id==e.id)||this.memory.powerSpawns.push({id:e.id})};e.forEach(t)}else delete this.memory.powerSpawns}},processPower:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_POWER_SPAWN});for(let t=0;t<e.length;t++){let r=e[t];r.energy>=POWER_SPAWN_ENERGY_RATIO&&r.power>=1&&(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"processPower"}),r.processPower())}}}})}),this.roomExtend=(()=>{this.assignRoom({PowerSpawn:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.powerSpawns,e)}return this._all}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("resources"),this.analyzeRoom=((e,t)=>{t&&e.saveMinerals()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({resourcesStorage:{get(){return _.isUndefined(this._resourcesStorage)&&(this._resourcesStorage={},_.isUndefined(this.storage)||Object.keys(this.storage.store).forEach(e=>{_.isUndefined(this._resourcesStorage[e])&&(this._resourcesStorage[e]=this.storage.store[e])})),this._resourcesStorage}},resourcesTerminal:{get(){return _.isUndefined(this._resourcesTerminal)&&(this._resourcesTerminal={},_.isUndefined(this.terminal)||Object.keys(this.terminal.store).forEach(e=>{_.isUndefined(this._resourcesTerminal[e])&&(this._resourcesTerminal[e]=this.terminal.store[e])})),this._resourcesTerminal}},resourcesLabs:{get(){if(_.isUndefined(this._resourcesLabs)){this._resourcesLabs={};let e=this.memory.resources;if(!_.isUndefined(e)&&!_.isUndefined(e.lab))for(let t of e.lab)if("Storage"!==t.reactionState){const e=Game.getObjectById(t.id),r=e.mineralType,o=e.mineralAmount;_.isUndefined(r)||(_.isUndefined(this._resourcesLabs[r])?this._resourcesLabs[r]=o:this._resourcesLabs[r]+=o)}}return this._resourcesLabs}},resourcesCreeps:{get(){if(_.isUndefined(this._resourcesCreeps)){this._resourcesCreeps={};for(let e of this.creeps)Object.keys(e.carries).forEach(t=>{_.isUndefined(this._resourcesCreeps[t])?this._resourcesCreeps[t]=e.carry[t]:this._resourcesCreeps[t]+=e.carry[t]})}return this._resourcesCreeps}},resourcesOffers:{get(){if(_.isUndefined(this._resourcesOffers)){this._resourcesOffers={};let e=this.memory.resources;_.isUndefined(e)||_.isUndefined(e.offers)||(this._resourcesOffers=Util.sumCompoundType(e.offers))}return this._resourcesOffers}},resourcesOrders:{get(){if(_.isUndefined(this._resourcesOrders)){this._resourcesOrders={};let e=this.memory.resources;_.isUndefined(e)||_.isUndefined(e.orders)||(this._resourcesOrders=Util.sumCompoundType(e.orders))}return this._resourcesOrders}},resourcesReactions:{get(){if(_.isUndefined(this._resourcesReactions)){this._resourcesReactions={};let e=this.memory.resources;if(!_.isUndefined(e)&&!_.isUndefined(e.reactions)&&!_.isUndefined(e.reactions.orders)&&1===e.reactions.orders.length){const t=e.reactions,r=t.orders[0],o=r.type,i=r.amount,s=LAB_REACTIONS[o][0],a=LAB_REACTIONS[o][1],n=Game.getObjectById(t.seed_a),l=Game.getObjectById(t.seed_b),m=n.mineralAmount,c=l.mineralAmount;this._resourcesReactions[s]=i-m,this._resourcesReactions[a]=i-c}}return this._resourcesReactions}},resourcesAll:{get(){return _.isUndefined(this._resourcesAll)&&(this._resourcesAll={},_.isUndefined(this.storage)||Object.keys(this.storage.store).forEach(e=>{_.isUndefined(this._resourcesAll[e])&&(this._resourcesAll[e]=this.storedMinerals(e))}),_.isUndefined(this.terminal)||Object.keys(this.terminal.store).forEach(e=>{_.isUndefined(this._resourcesAll[e])&&(this._resourcesAll[e]=this.storedMinerals(e))})),this._resourcesAll}},droppedResources:{get(){return _.isUndefined(this._droppedResources)&&(this._droppedResources=this.find(FIND_DROPPED_RESOURCES)),this._droppedResources}},minerals:{get(){if(_.isUndefined(this._minerals)){this._minerals=[];let e=e=>{Util.addById(this._minerals,e)};_.forEach(this.memory.minerals,e)}return this._minerals}},mineralType:{get(){if(_.isUndefined(this.memory.mineralType)){let e=this.find(FIND_MINERALS);e&&e.length>0?this.memory.mineralType=e[0].mineralType:this.memory.mineralType=""}return this.memory.mineralType}},sources:{get(){if((_.isUndefined(this.memory.sources)||"sim"==this.name)&&(this._sources=this.find(FIND_SOURCES),this._sources.length>0?this.memory.sources=this._sources.map(e=>e.id):this.memory.sources=[]),_.isUndefined(this._sources)){this._sources=[];let e=e=>{Util.addById(this._sources,e)};this.memory.sources.forEach(e)}return this._sources}},sourceAccessibleFields:{get(){if(_.isUndefined(this.memory.sourceAccessibleFields)){let e=0,t=this.sources,r=t=>e+=t.accessibleFields;_.forEach(t,r),this.memory.sourceAccessibleFields=e}return this.memory.sourceAccessibleFields}},sourceEnergyAvailable:{get(){if(_.isUndefined(this._sourceEnergyAvailable)){this._sourceEnergyAvailable=0;let e=e=>this._sourceEnergyAvailable+=e.energy;_.forEach(this.sources,e)}return this._sourceEnergyAvailable}},ticksToNextRegeneration:{get(){return _.isUndefined(this._ticksToNextRegeneration)&&(this._ticksToNextRegeneration=_(this.sources).map("ticksToRegeneration").min()||0),this._ticksToNextRegeneration}},saveMinerals:{value(){let e=this.structures.all.filter(e=>e.structureType===STRUCTURE_EXTRACTOR&&e.active).map(e=>({x:e.pos.x,y:e.pos.y}));const t=this.find(FIND_MINERALS).filter(t=>_.some(e,{x:t.pos.x,y:t.pos.y}));if(t.length>0){let e=e=>e.id;this.memory.minerals=_.map(t,e)}else delete this.memory.minerals}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("spawn"),this.analyzeRoom=((e,t)=>{t&&e.saveSpawns()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({spawnQueueHigh:{get(){return _.isUndefined(this.memory.spawnQueueHigh)&&(this.memory.spawnQueueHigh=[]),this.memory.spawnQueueHigh}},spawnQueueMedium:{get(){return _.isUndefined(this.memory.spawnQueueMedium)&&(this.memory.spawnQueueMedium=[]),this.memory.spawnQueueMedium}},spawnQueueLow:{get(){return _.isUndefined(this.memory.spawnQueueLow)&&(this.memory.spawnQueueLow=[]),this.memory.spawnQueueLow}},saveSpawns:{value(){let e=this.find(FIND_MY_SPAWNS);if(e.length>0){let t=e=>e.id;this.memory.spawns=_.map(e,t)}else delete this.memory.spawns}}})}),this.roomExtend=(()=>{this.assignRoom({bestSpawnRoomFor:e=>_.min(Game.rooms,t=>t.my?Util.routeRange(t.name,e):1/0),findSpawnRoom:e=>{if(!e||!e.targetRoom)return null;let t=_.filter(Game.rooms,t=>t.my&&(void 0===e.maxRange||Util.routeRange(t.name,e.targetRoom)<=e.maxRange)&&(void 0===e.minEnergyCapacity||e.minEnergyCapacity<=t.energyCapacityAvailable)&&(void 0===e.minEnergyAvailable||e.minEnergyAvailable<=t.energyAvailable)&&(t.name!=e.targetRoom||!0===e.allowTargetRoom)&&(void 0===e.minRCL||t.RCL>=e.minRCL)&&(void 0===e.callBack||e.callBack(t)));if(0==t.length)return null;let r=e=>_.sum(e,e=>3*e.parts.length);return _.min(t,t=>Util.routeRange(t.name,e.targetRoom)+(8-t.RCL)/(e.rangeRclRatio||3)+(e=>(.9*r(e.spawnQueueLow)+r(e.spawnQueueMedium)+1.1*r(e.spawnQueueHigh))/e.structures.spawns.length)(t)/(e.rangeQueueRatio||51))}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("tower"),this.analyzeRoom=((e,t)=>{t&&e.saveTowers()}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r&&r.structures.towers.length>0&&StructureTower.loop(r)}),this.prototypeExtend=(()=>{this.assignRoomPrototype({towerFreeCapacity:{get(){if(_.isUndefined(this._towerFreeCapacity)){this._towerFreeCapacity=0;let e=e=>this._towerFreeCapacity+=e.energyCapacity-e.energy;_.forEach(this.structures.towers,e)}return this._towerFreeCapacity}},saveTowers:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:{structureType:STRUCTURE_TOWER}});if(e.length>0){let t=e=>e.id;this.memory.towers=_.map(e,t)}else delete this.memory.towers}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("fillRoomOrders"),this.analyze=(()=>{this.fillRoomOrders()}),this.fillRoomOrders=(()=>{if(!MAKE_COMPOUNDS&&!ALLOCATE_COMPOUNDS)return;_.isUndefined(Memory.boostTiming)&&(Memory.boostTiming={}),_.isUndefined(Memory.boostTiming.roomTrading)&&(Memory.boostTiming.roomTrading={boostProduction:!1,boostAllocation:!1}),_.isUndefined(Memory.boostTiming.timeStamp)&&(Memory.boostTiming.timeStamp=Game.time);const e=Util.orderingRoom(),t=e.length,r=Memory.boostTiming.roomTrading,o=_.filter(Game.rooms,{my:!0}),i=_.some(o,e=>{let t=e.memory.resources;return!(!t||!t.boostTiming)&&"reactionPlaced"===t.boostTiming.roomState});let s;if(i&&!1===Memory.boostTiming.roomTrading.boostProduction&&(Memory.boostTiming.roomTrading.boostProduction=!0,Memory.boostTiming.timeStamp=Game.time),1===t){let t=e[0];r.boostProduction&&(s=`BOOST_PRODUCTION since: ${Game.time-Memory.boostTiming.timeStamp}`),r.boostAllocation&&(s=`BOOST_ALLOCATION since: ${Game.time-Memory.boostTiming.timeStamp}`),Memory.boostTiming.multiOrderingRoomName?Log.module(t.name,`multi ordering in progress at ${Memory.boostTiming.multiOrderingRoomName}`):Log.module(t.name,`orderingRoom.name: ${t.name}, checkRoomAt: ${(t.memory.resources.boostTiming.checkRoomAt||0)-Game.time} ${s}`)}else t>1&&(Log.warn(`${t} ordering rooms!`),Log.table(e));if(1===e.length&&Game.time>=e[0].memory.resources.boostTiming.checkRoomAt&&!Memory.boostTiming.multiOrderingRoomName){const t=e[0],r=t.memory.resources;if(t.ordersWithOffers()){let e=t.checkOffers();Log.module(t.name,`checkOffers running from ${t.name} returnValue: ${e}`)}else Log.module(t.name,`${t.name} no offers found, updating offers`),t.GCOrders(),Log.stringify(r.orders)}else if(0===e.length){let e=Memory.boostTiming.roomTrading;!0!==e.boostProduction||i?!0===e.boostAllocation&&(e.boostAllocation=!1,Memory.boostTiming.timeStamp=Game.time):(e.boostProduction=!1,Memory.boostTiming.timeStamp=Game.time)}if((MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS)&&Memory.boostTiming&&Memory.boostTiming.multiOrderingRoomName){const e=Game.rooms[Memory.boostTiming.multiOrderingRoomName],t=e.memory.resources.boostTiming.ordersReady,r=t.orderCandidates;let o=!1;if(Game.time<t.time)return;if(0===r.length)return Log.module(e.name,`all ready offers completed to ${Memory.boostTiming.multiOrderingRoomName} Memory.boostTiming.multiOrderingRoomName deleted.`),Game.rooms[Memory.boostTiming.multiOrderingRoomName].memory.resources.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,delete Memory.boostTiming.multiOrderingRoomName,void delete e.memory.resources.boostTiming.ordersReady;for(let i=0;i<r.length;i++){const s=r[i],a=Game.rooms[s.room];if(s.readyOffers>0){if(a.terminal.cooldown>0){Log.module(a.name,`${a.name} terminal.cooldown: ${a.terminal.cooldown} fillARoomOrder() delayed.`),t.time=Game.time+a.terminal.cooldown;continue}t.time=Game.time+1,Log.module(e.name,`running ${s.room} fillARoomOrder() in a row, time: ${Game.time} readyOffers: ${s.readyOffers}`),!0===(o=a.fillARoomOrder())?(s.readyOffers--,s.readyOffers>=1?Log.module(s.room,`has ${s.readyOffers} remains fillRoomOrders check. readyOffers: ${s.readyOffers}`):(Log.module(e.name,`offers from ${s.room} are completed`),r.splice(i,1),i--)):o===ERR_TIRED?(t.time=Game.time+a.terminal.cooldown,Log.module(s.room,`${s.room} offers from ${s.room} failed send to ${e.name}.  Terminal.cooldown: ${a.terminal.cooldown}`)):o===ERR_NOT_ENOUGH_RESOURCES?(Log.module(e.name,`WARNING: offers from ${s.room} are not completed: not enough resources`),r.splice(i,1),i--):!0!==o&&o!==OK&&(Log.module(e.name,`WARNING: offers from ${s.room} are not completed. Offers deleted. terminal.send returns: ${Util.translateErrorCode(o)}`),r.splice(i,1),i--)}}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("boostProduction"),this.analyze=(()=>{this.boostProduction()}),this.boostProduction=(()=>{if(!MAKE_COMPOUNDS)return;let e=Memory.boostTiming.roomTrading;if(!e.boostAllocation&&!e.reallocating&&Game.time%MAKE_COMPOUNDS_INTERVAL==0){const e=_.filter(Game.rooms,{my:!0}),t=Util.orderingRoom(),r=_.some(e,e=>{let t=e.memory.resources;return!(!t||!t.boostTiming)&&"reactionPlaced"===t.boostTiming.roomState}),o=t.length;let i=!1;for(let t of e){let e=t.memory.resources;if(_.isUndefined(e))continue;const s=e.boostTiming,a=()=>{if(0===e.reactions.orders.length)return!1;let t=e.reactions.orders[0].type;return _.some(e.lab,e=>{let r=Game.getObjectById(e.id);return r.mineralType===t&&r.mineralAmount>0})};if(0!==e.orders.length&&0!==_.sum(e.orders,"amount")||"ordersPlaced"!==s.roomState||a()&&(s.roomState="reactionMaking",s.checkRoomAt=Game.time,delete s.getOfferAttempts,Log.module(t.name,`${t.name} orders done.`)),0!==o||r||i||(i=t.makeReaction()),e.reactions&&"burst"===e.reactions.reactorMode&&"reactionMaking"===e.boostTiming.roomState&&s.checkRoomAt-Game.time<=150&&Game.time%50==0){let r=e.reactions.orders[0];Log.module(t.name,`${t.name}, finishing ${r.type}. checkRoomAt: ${s.checkRoomAt-Game.time}`);const o=Game.getObjectById(e.reactions.seed_a),i=Game.getObjectById(e.reactions.seed_b),a=r.type,n=LAB_REACTIONS[a][0],l=LAB_REACTIONS[a][1],m=r.amount,c=t.getSeedLabOrders(),u=c.labOrderAmountA,d=c.labOrderAmountB,h=t.resourcesAll[n],g=t.resourcesAll[l],p=o.mineralAmount+u,f=i.mineralAmount+d;if(Log.module(t.name,`reactionAmount ${m}`),Log.module(t.name,`labs stored: seed_a: ${o.mineralAmount} ${n} seed_b: ${i.mineralAmount} ${l}`),Log.module(t.name,`labs ordered: seed_a: ${u} ${n} seed_b: ${d} ${l}`),p===m&&f===m)Log.module(t.name,"lab orders OK"),m>0&&((_.isUndefined(h)||0===h)&&o.mineralAmount<LAB_REACTION_AMOUNT||(_.isUndefined(g)||0===g)&&i.mineralAmount<LAB_REACTION_AMOUNT)&&(r.amount=0,Log.module(t.name,"resources NOT OK"),Log.module(t.name,`resourcesA: ${h} resourcesB: ${g}`),Log.module(t.name,`reactionOrders fixed: ${r.amount}`));else if(m>p||m>f){Log.module(t.name,"NOT ENOUGH lab orders:"),Log.module(t.name,`${t.name} reactionAmount: ${m} DIFF: labA: ${p-m} labB: ${f-m}`);let e=Math.min(p,f);e>=LAB_REACTION_AMOUNT?r.amount=e:r.amount=0,Log.module(t.name,`reactionOrders fixed: ${r.amount}`)}else if(m<p||m<f){Log.module(t.name,"TOO MUCH lab orders:"),Log.module(t.name,`${t.name} reactionAmount: ${m} DIFF: labA: ${p-m} labB: ${f-m}`);let e=Math.min(p,f);e>=LAB_REACTION_AMOUNT?r.amount=e:r.amount=0,Log.module(t.name,`reactionOrders fixed: ${r.amount}`)}}Game.time>=s.checkRoomAt&&"reactionMaking"===e.boostTiming.roomState&&(_.sum(e.reactions.orders,"amount")>0?(s.reactionMaking=Game.time,t.countCheckRoomAt(),Log.module(t.name,`${t.name} checkRoomAt counted: ${s.checkRoomAt-Game.time}`)):(Log.module("BoostPriduction",`Game.time: ${Game.time}`),Log.module(t.name,`reactions done in in ${t.name}`),e.boostTiming={}))}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.state={},this.loop=(e=>{this.state={casualties:e.casualties,urgentRepairable:e.structures.urgentRepairable,hostiles:e.hostiles,invasion:e.situation.invasion},_.forEach(e.structures.towers,this.run)}),this.run=(e=>{e&&this.runHeal(e,this.state.casualties,this.state.invasion)!==OK&&this.runRepair(e,this.state.urgentRepairable)!==OK&&this.runAttack(e,this.state.hostiles)}),this.runHeal=((e,t,r)=>{if(0===t.length)return;let o=t[0];if(o.hitsMax-o.hits>=400||!r){const t=e.heal(o);return _.isUndefined(o.towers)&&(o.towers=[]),o.towers.push(e.id),t}}),this.runRepair=((e,t)=>{if(0===t.length)return;let r=t[0];const o=e.repair(r);return _.isUndefined(r.towers)&&(r.towers=[]),r.towers.push(e.id),o}),this.runAttack=((e,t)=>{if(0===t.length)return;let r=e.pos.findClosestByRange(t);return r?e.attack(r):void 0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(2);t.default=new class extends o.Component{constructor(){super(...arguments),this.priorityHigh=[Creep.setup.worker,Creep.setup.miner,Creep.setup.hauler,Creep.setup.upgrader],this.priorityLow=[Creep.setup.mineralMiner,Creep.setup.privateer],this.register=(()=>{Creep.spawningCompleted.on(e=>this.handleSpawningCompleted(e))}),this.handleSpawningCompleted=(e=>{LOG_TRACE&&Log.trace("Spawn",{behaviour:e.data.creepType,creepName:e.name,Spawn:"Creep.spawningCompleted"}),CENSUS_ANNOUNCEMENTS&&Log.room(e.pos.roomName,Dye(COLOR_GREEN,i.Emoji.tick,e.name,"was born!"))}),this.run=(()=>{_.forEach(Game.spawns,e=>{e.room.my&&e.run()})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.run=(()=>{Memory.stats={tick:Game.time},Memory.stats.cpu=Game.cpu,Memory.stats.cpu.used=Game.cpu.getUsed(),Memory.stats.gcl=Game.gcl,Memory.stats.market={credits:Game.market.credits,numOrders:Game.market.orders?Object.keys(Game.market.orders).length:0},Memory.stats.rooms={};for(let e in Game.rooms){const t=Game.rooms[e];t&&t.my&&(Memory.stats.rooms[t.name]={name:t.name,spawns:{},storage:{},terminal:{},minerals:{},sources:{}},this.init(t,Memory.stats.rooms[t.name]))}}),this.init=((e,t)=>{this.controller(e,t),this.energy(e,t),this.spawns(e,t.spawns),this.storage(e,t.storage),this.terminal(e,t.terminal),this.minerals(e,t.minerals),this.sources(e,t.sources)}),this.controller=((e,t)=>{e.controller&&(t.controller={level:e.RCL,progress:e.controller.progress,progressTotal:e.controller.progressTotal})}),this.energy=((e,t)=>{t.energy={available:e.energyAvailable,capacityAvailable:e.energyCapacityAvailable}}),this.spawns=((e,t)=>{e.structures.spawns&&e.structures.spawns.forEach(e=>{t[e.name]={name:e.name,spawning:null!==e.spawning?1:0}})}),this.storage=((e,t)=>{e.storage&&(t.store=_.sum(e.storage.store),t.resources={},Object.keys(e.storage.store).forEach(r=>t.resources[r]=e.storage.store[r]))}),this.terminal=((e,t)=>{e.terminal&&(t.store=_.sum(e.terminal.store),t.resources={},Object.keys(e.terminal.store).forEach(r=>t.resources[r]=e.terminal.store[r]))}),this.minerals=((e,t)=>{e.minerals&&e.minerals.forEach(e=>t[e.id]={id:e.id,density:e.density,mineralAmount:e.mineralAmount,mineralType:e.mineralType,ticksToRegeneration:e.ticksToRegeneration})}),this.sources=((e,t)=>{e.sources&&e.sources.forEach(e=>t[e.id]={id:e.id,energy:e.energy,energyCapacity:e.energyCapacity,ticksToRegeneration:e.ticksToRegeneration})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),i=r(162),s=r(163),a=r(164),n=r(165),l=r(166),m=r(167);t.default=new class extends o.VisualsBase{constructor(){super(...arguments),this.state={HeatMap:new n.HeatMap,Piechart:new i.Piechart,Sidebar:new s.Sidebar,ToolTip:new a.ToolTip,CreepVis:new l.CreepVis,RoomVis:new m.RoomVis},this.run=(()=>{const e=VISUALS.VISIBLE_ONLY,t=e?Util.getVisibleRooms():Object.keys(Game.rooms);_.forEach(t,t=>{const r=Game.rooms[t];r&&(ROOM_VISUALS_ALL||r.my)&&(e||r.controller)&&_.forEach(this.state,e=>e.run(r))})}),this.drawLine=((e,t,r)=>{if(e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos),!(e instanceof RoomPosition||t instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(e.roomName!==t.roomName)return;const o=new RoomVisual(e.roomName),i=r instanceof Creep?this.creepPathStyle(r):r||{};o.line(e,t,i)}),this.drawArrow=((e,t,r)=>{if(e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos),!(e instanceof RoomPosition||t instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(e.roomName!==t.roomName)return;const o=new RoomVisual(e.roomName);this.drawLine(e,t,r);const i=e.x-t.x,s=e.y-t.y,a=Math.atan2(s,i),n=.5*Math.log1p(Util.getDistance(e,t)),l=r instanceof Creep?this.creepPathStyle(r):r||{};o.line(t.x,t.y,t.x+n*Math.cos(a+.610865),t.y+n*Math.sin(a+.610865),l),o.line(t.x,t.y,t.x+n*Math.cos(a-.610865),t.y+n*Math.sin(a-.610865),l)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),i=r(2);t.Piechart=class extends o.VisualsBase{constructor(){super(...arguments),this.pieStyle={radius:1.2,fill:"rgba(0,0,0,.5)",stroke:"rgba(255,255,255,.5)"},this.pieFontStyle={color:"#FFFFFF",font:"0.8 Hack",align:"center",stroke:"rgba(0,0,0,0.8)"},this.pieTitleStyle={color:"#FFFFFF",font:"0.6 Hack",align:"center"},this.color="#62e6ac",this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.ROOM&&e.controller&&this.drawRoomInfo(e)}),this.drawPie=((e,t,r,o,i,s)=>{s||(s=e);let a=1;0!==t&&(a=e/t),i={x:i.x,y:1*i.y*4.5},this.vis.circle(i,this.pieStyle);const n=[i],l=2*Math.PI,m=l*(a+.1),c=-Math.PI/2,u=l/32;for(let e=0;e<=m;e+=u)n.push({x:i.x+Math.cos(e+c),y:i.y-Math.cos(e)});n.push(i),this.vis.poly(n,{fill:o,opacity:1,stroke:o,strokeWidth:.05}),this.vis.text(Number.isFinite(s)?Util.formatNumber(s):s,i.x,i.y+.3,this.pieFontStyle);let d=.7;a>.35&&a<.65&&(d+=.3),this.vis.text(r,i.x,i.y+1.5+d,this.pieTitleStyle)}),this.drawRoomInfo=(e=>{this.vis.text(`${i.Emoji.home}${e.name}`,24.5,1.5,{font:"1 Hack",backgroundColor:"rgba(0,0,0,.5)"});let t=.5;this.drawPie(Math.round(Game.cpu.getUsed()),Game.cpu.limit,"CPU",this.color,{x:47,y:t++}),this.drawPie(Game.cpu.bucket,1e4,"Bucket",this.color,{x:47,y:t++}),this.drawPie(Math.round(Game.gcl.progress),Game.gcl.progressTotal,`GCL ${Game.gcl.level}`,this.color,{x:47,y:t++});const r=e.controller;if(r){let e,o,i="RCL",s=!0;8===r.level?(e=1,o=1):r.reservation?(e=r.reservation.ticksToEnd,o=5e3):r.owner?(e=Math.min(r.progress,r.progressTotal),o=r.progressTotal,i+=` ${r.level}`):s=!1,s&&this.drawPie(e,o,i,this.color,{x:47,y:t++},r.level)}const o=e.storage;o&&this.drawPie(o.sum,o.storeCapacity,"Store",this.color,{x:47,y:t++})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.Sidebar=class extends o.VisualsBase{constructor(){super(...arguments),this.infoStyle={align:"left",font:"0.8 Hack",backgroundColor:"rgba(0,0,0,.5)"},this.objectStyle={align:"left",font:"0.6 Hack",backgroundColor:"rgba(0,0,0,.1)",backgroundPadding:.2},this.titleStyle={align:"left",font:"bold 0.5 Hack",color:"rgba(0,0,0,.7)",backgroundPadding:.2},this.subStyle={align:"left",font:"0.4 Hack",opacity:.7},this.Y_PADDING=3,this.Y_MAEGIN=1.2,this.Y_LIST_MARGIN=1,this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.ROOM_ORDERS&&this.drawRoomOrders(e,"orders"),VISUALS.ROOM_OFFERS&&this.drawRoomOrders(e,"offers"),VISUALS.STORAGE&&this.drawStoreInfo(e,"storage"),VISUALS.TERMINAL&&this.drawStoreInfo(e,"terminal")}),this.drawRoomOrders=((e,t)=>{let r=1;e.memory.resources&&e.memory.resources[t]&&_.size(e.memory.resources[t])&&(VISUALS.STORAGE&&e.storage&&(r+=this.Y_PADDING+_.size(e.storage.store)*this.Y_LIST_MARGIN),VISUALS.TERMINAL&&e.terminal&&(r+=this.Y_PADDING+_.size(e.terminal.store)*this.Y_LIST_MARGIN),"offers"===t&&VISUALS.ROOM_ORDERS&&e.memory.resources.orders&&(r+=this.Y_PADDING+_.size(e.memory.resources.orders)*this.Y_LIST_MARGIN),this.vis.text(`Room ${_.capitalize(t)}`,1,++r,this.infoStyle),this._roomOrdersObject(e.memory.resources[t],1,r+this.Y_MAEGIN-.5))}),this.drawStoreInfo=((e,t)=>{const r=e[t];if(!r||!_.size(r.store))return;let o=1;"terminal"===t&&VISUALS.STORAGE&&e.storage&&(o+=this.Y_PADDING+_.size(e.storage.store)*this.Y_LIST_MARGIN),this.vis.text(`${_.capitalize(t)} Contents`,1,++o,this.infoStyle);const i=r.sum,s=r.storeCapacity,a=`L: ${Util.formatNumber(s-i)}`,n=`${Util.formatNumber(i)}/${Util.formatNumber(s)}`;this.vis.text(`${a} (${n})`,1,o+1.2,this.subStyle),this._storageObject(r.store,1,o+this.Y_MAEGIN)}),this._drawList=((e,t,r,o)=>{const i=r===RESOURCE_ENERGY?"E":r,s=this.getResourceColour(r);this.vis.text(`${i}`,e,t,_.assign({backgroundColor:s},this.titleStyle)),this.vis.text(`${Util.formatNumber(o)}`,e+2,t,_.assign({backgroundColor:s},this.objectStyle))}),this._roomOrdersObject=((e,t,r,o)=>{for(let e of t)this._drawList(r,o+=this.Y_LIST_MARGIN,e.type,e.amount)}),this._storageObject=((e,t,r)=>{Object.keys(e).forEach(o=>this._drawList(t,r+=this.Y_LIST_MARGIN,o,e[o]))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(10),i=r(3);t.ToolTip=class extends i.VisualsBase{constructor(){super(...arguments),this.toolTipStyle={align:"left",font:"0.4 Hack",backgroundColor:"rgba(0,0,0,.5)"},this.weakestStyle={radius:.4,fill:"#FF0000",opacity:.3,strokeWidth:0},this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.MINERAL&&this.drawMineralInfo(e.minerals),VISUALS.SOURCE&&e.sources.forEach(e=>this.drawSourceInfo(e)),VISUALS.CONTROLLER&&this.drawControllerInfo(e.controller),VISUALS.TRANSACTIONS&&this.drawTransactions(e),VISUALS.LABS&&e.structures.labs.all.forEach(e=>this.drawLabInfo(e)),VISUALS.TOWER&&e.structures.towers.forEach(e=>this.drawTowerInfo(e)),VISUALS.SPAWN&&e.structures.spawns.filter(e=>e.spawning).forEach(e=>this.drawSpawnInfo(e)),VISUALS.WALL&&this.highlightWeakest(e,STRUCTURE_WALL),VISUALS.RAMPART&&this.highlightWeakest(e,STRUCTURE_RAMPART),VISUALS.ROAD&&this.highlightWeakest(e,STRUCTURE_ROAD)}),this.drawSpawnInfo=(e=>{e.spawning&&this.vis.text(`${o.Emoji.baby} ${e.spawning.name}`,e.pos.x-.5,e.pos.y,this.toolTipStyle)}),this.drawMineralInfo=(e=>{if(!e||!e.room)return;const t=e.pos.x+.5,r=e.pos.y;e.mineralAmount?this.vis.text(`${o.Emoji.harvest} ${Math.floor(e.mineralAmount)}`,t,r,this.toolTipStyle):this.vis.text(`${o.Emoji.reload} ${Util.formatNumber(e.ticksToRegeneration)}`,t,r,this.toolTipStyle)}),this.drawSourceInfo=(e=>{const t=e.pos.x+.5,r=e.pos.y;e.energy?this.vis.text(`${o.Emoji.harvest} ${e.energy}`,t,r,this.toolTipStyle):this.vis.text(`${o.Emoji.reload} ${e.ticksToRegeneration}`,t,r,this.toolTipStyle)}),this.drawControllerInfo=(e=>{const t=e.pos.x+.5;let r=e.pos.y;const i=this.toolTipStyle;let s=`${o.Emoji.upgrade} Lv${e.level}`,a=`${Util.formatNumber(e.progress)}/${Util.formatNumber(e.progressTotal)} (${(e.progress/e.progressTotal*100).toFixed(2)}%)`,n=`${o.Emoji.reload} ${Util.formatNumber(e.ticksToDowngrade)}`;if(8===e.level)a="";else if(e.reservation)s=`${o.Emoji.flag} Reserved`,a="",n=`${o.Emoji.reload} ${e.reservation.ticksToEnd}`;else if(!e.owner)return;if(""!==a?this.vis.text(s+": "+a,t,r,i):this.vis.text(s,t,r,i),e.ticksToDowngrade<CONTROLLER_DOWNGRADE[e.level]||e.reservation){let e=Object.assign({},i,{color:"#FF0000"});this.vis.text(n,t,r+=1.2,e)}}),this.drawLabInfo=(e=>{if(!e.energy&&!e.mineralAmount&&!e.cooldown)return;const t=e.pos.x+.8;let r=e.pos.y-.5;e.mineralAmount&&this.vis.text(`M: ${e.mineralType} (${Util.formatNumber(e.mineralAmount)})`,t,r+=.4,Object.assign({color:this.getResourceColour(e.mineralType)},this.toolTipStyle)),e.cooldown&&this.vis.text(`C: ${e.cooldown}`,t,r+=.4,Object.assign({color:"#FF0000"},this.toolTipStyle))}),this.drawTowerInfo=(e=>{const t=e.energyCapacity-e.energy;t>0&&this.vis.text(`${o.Emoji.fuel} ${t}`,e.pos.x,e.pos.y,this.toolTipStyle)}),this.drawTransactions=(e=>{if(!e.terminal)return;const t=e.terminal.pos.x;let r=e.terminal.pos.y-1;const o=_(Game.market.incomingTransactions).concat(Game.market.outgoingTransactions).filter(t=>t.from===e.name||t.to===e.name).sortByOrder("time","desc").slice(0,2).value();0!==o.length&&(2===o.length&&(r-=.4),_.forEach(o,o=>{const i=!!o.sender&&o.sender.username===e.controller.owner.username,s=!!o.recipient&&o.sender.username===o.recipient.username,a=e.name===o.to,n=i||a?"#00FF00":"#FF0000",l=i?"+":"-";let m="";m=s||!o.order?`${a?o.from:o.to} : ${o.amount} ${o.resourceType}`:`${l}${o.amount*o.order.price}`,this.vis.text(m,t,r,{font:this.toolTipStyle.font,color:n}),r+=.4}))}),this.highlightWeakest=((e,t)=>{const r=_(e.find(FIND_STRUCTURES)).filter({structureType:t}).min("hits");if(r&&r.pos){this.vis.circle(r.pos.x,r.pos.y,this.weakestStyle);let e=r.pos.y-.5;const t=r.pos.lookFor(LOOK_STRUCTURES);if(_.find(t,e=>e instanceof StructureTower)&&VISUALS.TOWER)e+=.4;else if(_.find(t,e=>e instanceof StructureSpawn&&e.spawning)&&VISUALS.SPAWN)e+=.4;else{const r=_.find(t,e=>e instanceof StructureLab);r&&VISUALS.LABS&&(r.energy&&(e+=.4),r.mineralAmount&&(e+=.4),r.cooldown&&(e+=.4))}this.vis.text(`H: ${Util.formatNumber(r.hits)} (${(r.hits/r.hitsMax*100).toFixed(2)}%)`,r.pos.x+1,e,this.toolTipStyle)}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.HeatMap=class extends o.VisualsBase{constructor(){super(...arguments),this.run=(e=>{Util.set(Memory,"heatmap",!1),this.vis=new RoomVisual(e.name),VISUALS.HEATMAP&&(Game.time%VISUALS.HEATMAP_INTERVAL==0&&this.setHeatMapData(e),Memory.heatmap&&this.drawHeatMapData(e))}),this.getColourByPercentage=((e,t)=>`hsl(${(120*(t?e:1-e)).toString(10)}, 100%, 50%)`),this.setHeatMapData=(e=>{Util.set(e.memory,"heatmap",()=>{const t={};for(let r=0;r<50;r++)for(let o=0;o<50;o++)"wall"!==Game.map.getTerrainAt(e.getPositionAt(r,o))&&(t[`${String.fromCharCode(32+r)}${String.fromCharCode(32+o)}_x${r}-y${o}`]=0);return t}),e.creeps.filter(e=>!e.spawning).forEach(t=>{const r=t.pos.x,o=t.pos.y,i=`${String.fromCharCode(32+r)}${String.fromCharCode(32+o)}_x${r}-y${o}`;e.memory.heatmap[i]++})}),this.drawHeatMapData=(e=>{const t=Object.keys(e.memory.heatmap).map(t=>({n:e.memory.heatmap[t],x:t.charCodeAt(0)-32,y:t.charCodeAt(1)-32})),r=_.filter(t,e=>e.n>0),o=_.sum(r,e=>e.n)/r.length*2;r.forEach(e=>{const t=e.n/o,r=this.getColourByPercentage(Math.min(1,t));this.vis.rect(e.x-.5,e.y-.5,1,1,{fill:r})})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.CreepVis=class extends o.VisualsBase{constructor(){super(...arguments),this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.CREEP&&_.forEach(e.creeps,e=>this.drawCreepPath(e))}),this.drawCreepPath=(e=>{if(e.action&&"idle"===e.action.name)return;if(_(e.pos).pick(["x","y"]).eq(e.data.determinatedSpot))return;if(!e.memory||!e.memory._travel||!e.memory._travel.path)return;const t=e.memory._travel.path.substr(1),r=this.creepPathStyle(e);let o=e.pos.x,i=e.pos.y;const s={[TOP]:{x:0,y:-1},[TOP_RIGHT]:{x:1,y:-1},[RIGHT]:{x:1,y:0},[BOTTOM_RIGHT]:{x:1,y:1},[BOTTOM]:{x:0,y:1},[BOTTOM_LEFT]:{x:-1,y:1},[LEFT]:{x:-1,y:0},[TOP_LEFT]:{x:-1,y:-1}};if(0===e.fatigue){const t=+e.memory._travel.path[0];o+=s[t].x,i+=s[t].y}for(let e of t)e=+e,this.vis.line(o,i,o+=s[e].x,i+=s[e].y,r)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.RoomVis=class extends o.VisualsBase{constructor(){super(...arguments),this.lineStyle={fill:"rgba(255,255,255,.5)",opacity:.1,stroke:"rgba(255,255,255,0)"},this.run=(e=>{this.vis=new RoomVisual(e.name),this.bluePring(e),this.bluePring(e)}),this.bluePring=(e=>{if(!e.memory.center)return;const t=e.memory.center,r=this.makePoint(t);this.vis.circle(t),this.vis.poly([r.topLeftA,r.topLeftB,r.topRightA,r.topRightB,r.bottomRightA,r.bottomRightB,r.bottomLeftA,r.bottomLeftB,r.topLeftA],this.lineStyle),this.vis.poly([r.centerTop,r.centerRight,r.centerBottom,r.centerLeft,r.centerTop]),this.vis.poly([r.centerLeft,r.centerLeftA,r.centerTopA,r.centerTop,r.centerTopB,r.centerRightA,r.centerRight,r.centerRightB,r.centerBottomB,r.centerBottom,r.centerBottomA,r.centerLeftB,r.centerLeft],{opacity:.3}),this.vis.poly([r.topA,r.centerTopA,r.topB,r.topC,r.centerTopB,r.topD,r.topRightA,r.topRightB,r.rightA,r.centerRightA,r.rightB,r.rightC,r.centerRightB,r.rightD,r.bottomRightA,r.bottomRightB,r.bottomD,r.centerBottomB,r.bottomC,r.bottomB,r.centerBottomA,r.bottomA,r.bottomLeftA,r.bottomLeftB,r.leftD,r.centerLeftB,r.leftC,r.leftB,r.centerLeftA,r.leftA,r.topLeftA,r.topLeftB,r.topA],{opacity:.2})})}makePoint(e){const{x:t,y:r}=e;return{topLeft:[t-6,r-6],topRight:[t+6,r-6],bottomRight:[t+6,r+6],bottomLeft:[t-6,r+6],topLeftA:[t-6,r-5],topLeftB:[t-5,r-6],topRightA:[t+5,r-6],topRightB:[t+6,r-5],bottomRightA:[t+6,r+5],bottomRightB:[t+5,r+6],bottomLeftA:[t-5,r+6],bottomLeftB:[t-6,r+5],topA:[t-3,r-6],topB:[t-1,r-6],topC:[t+1,r-6],topD:[t+3,r-6],rightA:[t+6,r-3],rightB:[t+6,r-1],rightC:[t+6,r+1],rightD:[t+6,r+3],bottomA:[t-3,r+6],bottomB:[t-1,r+6],bottomC:[t+1,r+6],bottomD:[t+3,r+6],leftA:[t-6,r-3],leftB:[t-6,r-1],leftC:[t-6,r+1],leftD:[t-6,r+3],centerTop:[t,r-3],centerRight:[t+3,r],centerBottom:[t,r+3],centerLeft:[t-3,r],centerTopA:[t-2,r-5],centerTopB:[t+2,r-5],centerRightA:[t+5,r-2],centerRightB:[t+5,r+2],centerBottomA:[t-2,r+5],centerBottomB:[t+2,r+5],centerLeftA:[t-5,r-2],centerLeftB:[t-5,r+2]}}}},function(e,t){e.exports=require("commands")}]);